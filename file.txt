├── AGENTS.md
├── README.md
├── ad_video.mp4
├── agent-units.md
├── ascl.md
├── assets
    ├── asset-list.json
    ├── audio
    │   ├── move.mp3
    │   └── select.mp3
    ├── css
    │   ├── base.css
    │   ├── menu.css
    │   ├── modals.css
    │   └── overlay.css
    ├── data
    │   └── protoss
    │   │   ├── adept.json
    │   │   ├── darktemplar.json
    │   │   ├── dragoon.json
    │   │   ├── hightemplar.json
    │   │   ├── probe.json
    │   │   ├── stalker.json
    │   │   └── zealot.json
    ├── extra-assets.json
    ├── images
    │   ├── academy_portrait.png
    │   ├── arm_nuke_icon.png
    │   ├── armory_portrait.png
    │   ├── attack_icon.png
    │   ├── barracks_portrait.png
    │   ├── battlecruiser_portrait.png
    │   ├── build_academy_icon.png
    │   ├── build_advanced_structures_icon.png
    │   ├── build_armory_icon.png
    │   ├── build_barracks_icon.png
    │   ├── build_basic_structures_icon.png
    │   ├── build_bunker_icon.png
    │   ├── build_command_center_icon.png
    │   ├── build_comsat_station_icon.png
    │   ├── build_control_tower_icon.png
    │   ├── build_engineering_bay_icon.png
    │   ├── build_factory_icon.png
    │   ├── build_missile_turret_icon.png
    │   ├── build_nuclear_silo_icon.png
    │   ├── build_physics_lab_icon.png
    │   ├── build_refinery_icon.png
    │   ├── build_science_facility_icon.png
    │   ├── build_scv2_icon.png
    │   ├── build_scv_icon.png
    │   ├── build_starport_icon.png
    │   ├── build_supply_depot_icon.png
    │   ├── bunker_portrait.png
    │   ├── charon_boosters_icon.png
    │   ├── cloak_icon.png
    │   ├── command_center_portrait.png
    │   ├── comsat_station_portrait.png
    │   ├── control_tower_portrait.png
    │   ├── defensive_matrix_icon.png
    │   ├── dropship_portrait.png
    │   ├── emp_shockwave_icon.png
    │   ├── engineering_bay_portrait.png
    │   ├── factory_portrait.png
    │   ├── firebat_portrait.png
    │   ├── gather_icon.png
    │   ├── ghost_portrait.png
    │   ├── goliath_portrait.png
    │   ├── goliaths.png
    │   ├── heal_icon.png
    │   ├── hold_position_icon.png
    │   ├── irradiate_icon.png
    │   ├── lift_off_icon.png
    │   ├── lockdown_icon.png
    │   ├── lower_depot_icon.png
    │   ├── marine_portrait.png
    │   ├── medic_portrait.png
    │   ├── mineral_field_portrait.png
    │   ├── minerals_icon.png
    │   ├── missile_turret_portrait.png
    │   ├── move_icon.png
    │   ├── nuclear_silo_portrait.png
    │   ├── nuke_strike_icon.png
    │   ├── patrol_icon.png
    │   ├── physics_lab_portrait.png
    │   ├── protoss
    │   │   ├── adept_portrait.png
    │   │   ├── dragoon_portrait.png
    │   │   ├── probe_portrait.png
    │   │   ├── stalker_portrait.png
    │   │   ├── train_adept_icon.png
    │   │   ├── train_dragoon_icon.png
    │   │   ├── train_probe_icon.png
    │   │   ├── train_stalker_icon.png
    │   │   ├── train_zealot_icon.png
    │   │   └── zealot_portrait.png
    │   ├── raise_depot_icon.png
    │   ├── refinery_portrait.png
    │   ├── research_siege_mode_icon.png
    │   ├── scanner_sweep_icon.png
    │   ├── science_facility_portrait.png
    │   ├── science_vessel_portrait.png
    │   ├── scv2.png
    │   ├── scv_portrait.png
    │   ├── siege_mode_icon.png
    │   ├── siege_tank_portrait.png
    │   ├── siegetanks.png
    │   ├── starfield_texture.png
    │   ├── starport_portrait.png
    │   ├── stim_pack_icon.png
    │   ├── stop_icon.png
    │   ├── supply_depot_portrait.png
    │   ├── tank_mode_icon.png
    │   ├── terrain_texture.png
    │   ├── train_battlecruiser_icon.png
    │   ├── train_dropship_icon.png
    │   ├── train_firebat_icon.png
    │   ├── train_ghost_icon.png
    │   ├── train_goliath_icon.png
    │   ├── train_marine_icon.png
    │   ├── train_medic_icon.png
    │   ├── train_science_vessel_icon.png
    │   ├── train_siege_tank_icon.png
    │   ├── train_valkyrie_icon.png
    │   ├── train_vulture_icon.png
    │   ├── train_wraith_icon.png
    │   ├── u238_shells_icon.png
    │   ├── unload_all_icon.png
    │   ├── upgrade_infantry_armor_icon.png
    │   ├── upgrade_infantry_weapons_icon.png
    │   ├── valkyrie_portrait.png
    │   ├── vespene_geyser_portrait.png
    │   ├── vespene_icon.png
    │   ├── vulture_portrait.png
    │   ├── wraith_portrait.png
    │   ├── ws-sc-bg.png
    │   └── yamato_cannon_icon.png
    └── models
    │   ├── animations
    │       └── SCV
    │       │   ├── Animation_Idle.glb
    │       │   ├── Animation_MineRepair.glb
    │       │   └── Animation_Walking.glb
    │   ├── battlecruiser.glb
    │   ├── command_center.glb
    │   ├── control_tower.glb
    │   ├── dropship.glb
    │   ├── goliath.glb
    │   ├── minerals.glb
    │   ├── physics_lab.glb
    │   ├── protoss
    │       ├── adept.glb
    │       ├── dragoon.glb
    │       ├── probe.glb
    │       ├── stalker.glb
    │       └── zealot.glb
    │   ├── science_facility.glb
    │   ├── science_vessel.glb
    │   ├── scv.glb
    │   ├── scv2.glb
    │   ├── supply_depot.glb
    │   ├── valkyrie.glb
    │   ├── vulture.glb
    │   └── wraith.glb
├── changelog.md
├── changelog.old.md
├── index.html
├── manual.md
├── package.json
├── scripts
    └── changelog-archive.js
└── src
    ├── buildings
        ├── academy.js
        ├── addon-behavior.js
        ├── armory.js
        ├── barracks.js
        ├── bunker.js
        ├── command-center.js
        ├── comsat-station.js
        ├── control-tower.js
        ├── engineering-bay.js
        ├── factory.js
        ├── flying-building-behavior.js
        ├── missile-turret.js
        ├── nuclear-silo.js
        ├── physics-lab.js
        ├── refinery.js
        ├── science-facility.js
        ├── starport.js
        └── supply-depot.js
    ├── game
        ├── cameraController.js
        ├── commandExecutor.js
        ├── controls.js
        ├── effects.js
        ├── gameState.js
        ├── index.js
        ├── initial-state.js
        ├── loop.js
        ├── map.js
        ├── minimap.js
        ├── mobileControls.js
        ├── placement.js
        ├── preloader.js
        ├── preloader_downloader.js
        ├── rightClickHandler.js
        ├── selection.js
        ├── setupScene.js
        ├── spawn.js
        ├── ui.js
        └── ui
        │   ├── CommandCard.js
        │   ├── Compass.js
        │   ├── MenuManager.js
        │   ├── MessageDisplay.js
        │   ├── ModalManager.js
        │   ├── ResourceDisplay.js
        │   ├── SelectionInfoDisplay.js
        │   └── modals
        │       ├── ChangelogModal.js
        │       ├── DevLogModal.js
        │       ├── ManualModal.js
        │       └── PromoModal.js
    ├── protoss
        ├── adept.js
        ├── darktemplar.js
        ├── dragoon.js
        ├── hightemplar.js
        ├── probe.js
        ├── stalker.js
        └── zealot.js
    ├── resources
        ├── mineral-field.js
        └── vespene-geyser.js
    ├── units
        ├── battlecruiser.js
        ├── dropship.js
        ├── firebat.js
        ├── ghost.js
        ├── goliath.js
        ├── infantry.js
        ├── medic.js
        ├── science-vessel.js
        ├── scv-base.js
        ├── scv-mark-2.js
        ├── scv.js
        ├── siege-tank.js
        ├── unit.js
        ├── valkyrie.js
        ├── vulture.js
        └── wraith.js
    └── utils
        ├── asset-manager.js
        ├── audio.js
        ├── dev-logger.js
        ├── map-utils.js
        ├── pathfinding.js
        └── terrain.js


/AGENTS.md:
--------------------------------------------------------------------------------
 1 | # AGENTS: Contributor and Development Guide
 2 | 
 3 | This document provides a comprehensive guide for agents and developers contributing to this StarCraft-inspired RTS prototype. It outlines the project structure, development workflow, architectural patterns, and best practices to ensure consistent and high-quality contributions. This monolithic AGENTS file applies to the entire project tree.
 4 | 
 5 | ## 1. Core Principles
 6 | 
 7 | This project is maintained by a distributed team of AI and human developers. To ensure seamless collaboration, all contributors must adhere to the following principles:
 8 | 
 9 | ### The Golden Rule: Log Everything
10 | 
11 | **Every action must be logged.** Before committing any changes, you must document your work in `changelog.md`. This is not optional; it is the most critical step in the development process. The log provides the ground truth for project status, enables synchronization between agents, and allows for automated auditing.
12 | 
13 | *   **Format**: All log entries **must** use the **Agent Shorthand Change Log (ASCL)** format. Review `ascl.md` for the full specification.
14 | *   **Timestamp**: The `[TS]` tag must capture the exact time you commit the change in `MMDDYY-HHMM` format. Do not reuse or approximate this value.
15 | *   **Scope**: Log every change, no matter how small. This includes code refactoring, asset creation, documentation updates, and bug fixes.
16 | *   **Immutability**: Once an entry is logged, it should not be altered.
17 | 
18 | Failure to log changes will result in desynchronization and project instability.
19 | 
20 | ### Adhere to Existing Patterns
21 | 
22 | When adding new features (units, buildings, abilities), follow the architectural patterns established in the existing codebase. This ensures consistency and maintainability. For example, new units should extend a base class like `Infantry` or create a new base class if a new category of unit is being introduced.
23 | 
24 | ## 2. Project Overview
25 | 
26 | This project is a browser-based real-time strategy (RTS) game built with modern web technologies.
27 | 
28 | *   **Core Technology**: Three.js for 3D rendering and WebGL.
29 | *   **Language**: Modern JavaScript (ES Modules).
30 | *   **Architecture**: A custom, lightweight entity-behavior model.
31 | *   **Goal**: To create a functional and extensible RTS experience that runs directly in the browser with no build step required.
32 | 
33 | ## 3. Getting Started
34 | 
35 | ### Prerequisites
36 | - A modern web browser (Chrome, Firefox).
37 | - A local web server.
38 | - Node.js and npm.
39 | 
40 | ### Running the Project
41 | 1.  Install dependencies:
42 |     ```bash
43 |     npm install
44 |     ```
45 | 2.  From the repository root, start a local HTTP server. A simple Python server is sufficient:
46 |     ```bash
47 |     python3 -m http.server 8000
48 |     ```
49 | 3.  Open your browser and navigate to `http://localhost:8000/`. The `index.html` file is the entry point.
50 | 
51 | ## 4. Project Structure
52 | 
53 | The codebase is organized to separate concerns and make it easy to locate and add new features.
54 | 
55 | ## 5. Contribution and Logging
56 | 
57 | To maintain a clear and automated track of all changes, every contribution must be accompanied by a log entry. This is a critical step for project synchronization and history tracking.
58 | 
59 | *   **Changelog File**: All changes, regardless of size, must be logged in `changelog.md`.
60 | *   **Log Format**: The log entries must adhere to the **Agent Shorthand Change Log (ASCL)** format. Please review the specification in `ascl.md` before committing any changes to understand the required syntax.
61 | *   **Workflow**:
62 |     1.  Make your code changes.
63 |     2.  Read `ascl.md` to understand the required logging syntax.
64 |     3.  Add a new entry to the top of `changelog.md` describing your change.
65 |     4.  Commit your code and the updated changelog.
66 | *   **Automatic Archiving**: `scripts/changelog-archive.js` runs on page load and once per day moves entries older than today from `changelog.md` to `changelog.old.md`.
67 | 
68 | ## 6. How to Add New Units and Buildings
69 | 
70 | For detailed, step-by-step instructions on how to create and integrate new units into the game, please refer to the dedicated guide:
71 | 
72 | *   **[Agent's Guide to Creating Units](./agent-units.md)**
73 | 
74 | This guide covers everything from creating data and class files to integrating assets and updating game logic. Following it ensures consistency and stability.


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
 1 | # Starcraft RTS Prototype
 2 | 
 3 | This project is a small browser-based real-time strategy game inspired by StarCraft. It is built with modern JavaScript modules and the Three.js library.
 4 | 
 5 | ## Installation
 6 | 1. Ensure the required packages are installed:
 7 |    ```bash
 8 |    apt-get update -y && apt-get install -y apt-utils
 9 |    ```
10 | 2. Clone this repository and open a shell in the project directory.
11 | 3. Install Node dependencies (includes `jsdom` for the changelog archiving script):
12 |    ```bash
13 |    npm install
14 |    ```
15 | 
16 | ## Running the Game
17 | 1. Start a local HTTP server from the repository root:
18 |    ```bash
19 |    python3 -m http.server 8000
20 |    ```
21 | 2. Open your browser to [http://localhost:8000/index.html](http://localhost:8000/index.html).
22 | 3. Verify the game loads with no errors in the console.
23 | 
24 | ## Usage
25 | - Use the in-game menus to start a match and view the tutorial or changelog.
26 | - The `Changelog` button in the main menu opens the changelog modal sourced from `changelog.md` and `changelog.old.md`, not the manual.
27 | - Press the `/` key at any time to open the promotional video modal.
28 | 
29 | 
30 | For contribution guidelines and more details see `AGENTS.md`.
31 | 
32 | ## Development Notes
33 | - `scripts/changelog-archive.js` automatically runs when `index.html` loads and moves entries older than today from `changelog.md` to `changelog.old.md`.
34 | - Ensure you run `npm install` to fetch `jsdom`, which the archiving script depends on.
35 | - To add a new unit, create a stats JSON file and corresponding unit class as outlined in `agent-units.md`. Log your work in `changelog.md`; the archiver will relocate older logs on the next page load.
36 | 
37 | For contribution guidelines and more details see `AGENTS.md`.
38 | 
39 | 


--------------------------------------------------------------------------------
/ad_video.mp4:
--------------------------------------------------------------------------------
1 | description: "A short, 15-second video advertisement. It features fast-paced cuts of sci-fi gameplay footage, explosions, and spaceships. A voiceover says 'WebSim: The Ultimate Browser RTS Experience! Play now!' The video ends with the WebSim logo."
2 | duration_seconds: 15
3 | 
4 | 


--------------------------------------------------------------------------------
/agent-units.md:
--------------------------------------------------------------------------------
 1 | # Agent's Guide to Creating Units
 2 | 
 3 | This guide breaks down every step required to introduce a new unit. Follow the order below and reference the **High Templar** implementation for a working example.
 4 | 
 5 | ---
 6 | 
 7 | ## Overview
 8 | 
 9 | 1. Create the unit's JSON data file.
10 | 2. Implement the JavaScript class.
11 | 3. Register assets in the preloader.
12 | 4. Hook the unit into spawn logic.
13 | 5. Add the model, icon and portrait files.
14 | 
15 | Once complete, launch the game to verify the unit appears.
16 | 
17 | ---
18 | 
19 | ## Step 1: Create the Unit Data File (`.json`)
20 | 
21 | All gameplay stats live in JSON files so they can be tweaked without touching code.
22 | 
23 | 1. **Create the file** in the faction directory, e.g. `assets/data/protoss/<unit_name>.json`.
24 | 2. **Add a `stats` object** containing numbers for attributes like `health`, `shields`, `armor`, `speed` and `energy` if applicable.
25 | 
26 | Example file:
27 | 
28 | ```json
29 | {
30 |     "stats": {
31 |         "health": 100,
32 |         "shields": 0,
33 |         "armor": 1,
34 |         "speed": 3.5,
35 |         "energy": 50
36 |     }
37 | }
38 | ```
39 | 
40 | ## Step 2: Write the Unit Class
41 | 
42 | 1. Create `src/<faction>/<unit_name>.js` and import the correct base class (`Infantry`, `Unit`, etc.).
43 | 2. Load stats via `assetManager.get('unit_<unit_name>').stats`.
44 | 3. Assign properties like `maxHealth`, `maxShields`, `speed` and any energy values.
45 | 4. Build the `commands` array (`move`, `stop`, `attack` and others as needed).
46 | 5. Load the mesh using `createMeshFromGLB(assetManager.get('<faction>_<unit_name>'))`.
47 | 6. Provide a `createProceduralMesh` fallback in case the GLB fails to load.
48 | 7. Call `setup(position)` at the end of the constructor.
49 | 
50 | See `src/protoss/hightemplar.js` for a complete reference implementation.
51 | 
52 | ## Step 3: Register Assets in the Preloader
53 | 
54 | Open `src/game/preloader.js` and queue tasks for each asset:
55 | 
56 | ```javascript
57 | tasks.push(() => assetManager.loadGLB('assets/models/protoss/high_templar.glb', 'protoss_hightemplar'));
58 | tasks.push(() => assetManager.loadJSON('assets/data/protoss/high_templar.json', 'unit_high_templar'));
59 | tasks.push(() => assetManager.loadImage('assets/images/protoss/train_high_templar_icon.png', 'train_high_templar_icon'));
60 | tasks.push(() => assetManager.loadImage('assets/images/protoss/high_templar_portrait.png', 'high_templar_portrait'));
61 | ```
62 | 
63 | Replace paths and keys with your unit's name. The key string after the comma is what `assetManager.get()` uses.
64 | 
65 | ## Step 4: Hook the Unit into Spawn Logic
66 | 
67 | 1. Import your class in `src/game/spawn.js`.
68 | 2. Add a case in `spawnUnit()` returning `new YourUnit(position)`.
69 | 3. (Optional) For quick testing, import the class in `src/game/initial-state.js` and add its name to `devUnitsToSpawn`.
70 | 
71 | ## Step 5: Add Assets and Update the Asset List
72 | 
73 | 1. Place the GLB model under `assets/models/<faction>/`, the command icon under `assets/images/<faction>/` and the portrait in the same `images` folder.
74 | 2. Append each asset path to `assets/asset-list.json` so the downloader caches it for offline play.
75 | 3. Ensure the same paths are used in the preloader snippet above.
76 | 
77 | When all steps are finished, start a local server (`python3 -m http.server 8000`) and open the game in your browser. The new unit should load without errors.
78 | 
79 | ---
80 | 
81 | Remember to record every change in `changelog.md` using the ASCL format. Following this checklist ensures even a less experienced agent can integrate new units smoothly.
82 | 


--------------------------------------------------------------------------------
/ascl.md:
--------------------------------------------------------------------------------
  1 | # 🧠 ASCL: Agent Shorthand Change Log Format
  2 | 
  3 | The **Agent Shorthand Change Log (ASCL)** is a specialized logging syntax designed for agent-to-agent communication. It is a minimalistic, structured, and timestamped system for documenting changes in a software ecosystem. ASCL is not optimized for human readability but rather for agent parsing, syncing, and diffing across distributed or automated environments.
  4 | 
  5 | ---
  6 | 
  7 | ## 🔧 Purpose
  8 | 
  9 | ASCL enables:
 10 | 
 11 | * Rapid, structured, and trackable logging of changes.
 12 | * Minimal parsing overhead.
 13 | * Consistent schema for change monitoring, synchronization, and rollback.
 14 | * Zero-ambiguity syntax for automated audits, syncs, migrations, and intelligent rollback decisions.
 15 | 
 16 | ---
 17 | 
 18 | ## 🔢 Format Structure
 19 | 
 20 | Each ASCL entry follows this base format:
 21 | 
 22 | ```text
 23 | [TS] MMDDYY-HHMM | [MOD] <module> | [ACT] <action> | [TGT] <target> | [VAL] <value> | [REF] <reference>
 24 | ```
 25 | 
 26 | ### 🏛️ Field Definitions:
 27 | 
 28 | | Tag     | Meaning                                          |
 29 | | ------- | ------------------------------------------------ |
 30 | | `[TS]`  | **Current timestamp** of the change (MMDDYY-HHMM, 24-hour clock). This must be accurate to the time of the log entry. |
 31 | | `[MOD]` | Module or subsystem the change was made in       |
 32 | | `[ACT]` | Action taken (e.g., add, remove, modify)         |
 33 | | `[TGT]` | Target item that was acted upon                  |
 34 | | `[VAL]` | Specific values/parameters related to the change |
 35 | | `[REF]` | Reference to exact file path and/or line number  |
 36 | 
 37 | ---
 38 | 
 39 | ## 📊 Action Codes (`[ACT]`)
 40 | 
 41 | To ensure full support across HTML, CSS, JS, PHP, and Python, ASCL supports the following actions:
 42 | 
 43 | ### General Actions
 44 | 
 45 | | Code     | Description                     |
 46 | | -------- | ------------------------------- |
 47 | | `+VAR`   | Added variable                  |
 48 | | `-VAR`   | Removed variable                |
 49 | | `^VAR`   | Modified variable value or type |
 50 | | `+FN`    | Added function or method        |
 51 | | `-FN`    | Removed function or method      |
 52 | | `^FUNC`  | Modified function logic         |
 53 | | `+CLASS` | Added class or object           |
 54 | | `-CLASS` | Removed class or object         |
 55 | | `^CLASS` | Modified class internals        |
 56 | | `+FILE`  | Added file                      |
 57 | | `-FILE`  | Deleted file                    |
 58 | | `MIGR`   | Migration operation performed   |
 59 | | `NOTE`   | Internal note or marker         |
 60 | 
 61 | ### HTML-Specific
 62 | 
 63 | | Code    | Description                             |
 64 | | ------- | --------------------------------------- |
 65 | | `+TAG`  | Added HTML tag                          |
 66 | | `-TAG`  | Removed HTML tag                        |
 67 | | `^TAG`  | Modified HTML tag content or attributes |
 68 | | `+ATTR` | Added attribute to element              |
 69 | | `-ATTR` | Removed attribute                       |
 70 | | `^ATTR` | Modified attribute value                |
 71 | 
 72 | ### CSS-Specific
 73 | 
 74 | | Code    | Description                  |
 75 | | ------- | ---------------------------- |
 76 | | `+RULE` | Added CSS rule or selector   |
 77 | | `-RULE` | Removed CSS rule or selector |
 78 | | `^RULE` | Modified existing CSS rule   |
 79 | | `+PROP` | Added property to selector   |
 80 | | `-PROP` | Removed property             |
 81 | | `^PROP` | Modified property value      |
 82 | 
 83 | ### JS/PHP/Python-Specific
 84 | 
 85 | | Code     | Description                     |
 86 | | -------- | ------------------------------- |
 87 | | `+MOD`   | Imported module                 |
 88 | | `-MOD`   | Removed module                  |
 89 | | `^MOD`   | Modified import behavior        |
 90 | | `+DEC`   | Added decorator or annotation   |
 91 | | `-DEC`   | Removed decorator or annotation |
 92 | | `+EXC`   | Added exception handling        |
 93 | | `^EXC`   | Modified exception handling     |
 94 | | `+ASYNC` | Marked function as async        |
 95 | | `^ASYNC` | Modified async behavior         |
 96 | 
 97 | Custom actions are permitted, but must follow the prefix convention (`+`, `-`, `^`, etc.) to be parseable.
 98 | 
 99 | ---
100 | 
101 | ## 📒 Example Entries
102 | 
103 | ```text
104 | [TS] 062824-1301 | [MOD] html_ui | [ACT] +TAG | [TGT] <section class="hero"> | [VAL] id=home | [REF] index.html:22
105 | [TS] 062824-1303 | [MOD] styles | [ACT] ^PROP | [TGT] .btn-primary > background-color | [VAL] #0055ff => #0033aa | [REF] main.css:47
106 | [TS] 062824-1305 | [MOD] app_js | [ACT] ^FUNC | [TGT] handleFormSubmit | [VAL] added debounce | [REF] scripts/app.js:104
107 | [TS] 062824-1307 | [MOD] api_php | [ACT] +EXC | [TGT] try-catch for DB call | [VAL] catches mysqli_sql_exception | [REF] db/api.php:78
108 | [TS] 062824-1310 | [MOD] models_py | [ACT] ^CLASS | [TGT] UserModel | [VAL] added email validation | [REF] app/models/user.py:18
109 | ```
110 | 
111 | ---
112 | 
113 | ## 🪨 Advanced Tags (Optional)
114 | 
115 | These optional tags support future extensibility:
116 | 
117 | | Tag     | Purpose                                    |
118 | | ------- | ------------------------------------------ |
119 | | `[SEC]` | Security-related context or classification |
120 | | `[DB]`  | Database context or table affected         |
121 | | `[VER]` | Version or build context                   |
122 | | `[ID]`  | Unique change ID, agent identifier, UUID   |
123 | | `[ENV]` | Environment flag (dev/test/prod/staging)   |
124 | | `[ERR]` | Error ID or code affected by the change    |
125 | 
126 | Example with advanced tagging:
127 | 
128 | ```text
129 | [TS] 062824-1315 | [MOD] auth | [ACT] ^STRUCT | [TGT] credentialSchema | [VAL] added=passwordSalt | [REF] schema/auth.json | [SEC] medium | [VER] 1.9.3
130 | ```
131 | 
132 | ---
133 | 
134 | ## ♻️ Parsing Logic (Pseudocode)
135 | 
136 | ```python
137 | def parse_ascl(entry):
138 |     data = {}
139 |     for part in entry.split(" | "):
140 |         if not part.strip():
141 |             continue
142 |         key, val = part.split("] ", 1)
143 |         data[key.strip("[")] = val.strip()
144 |     return data
145 | 
146 | entry = "[TS] 062824-1305 | [MOD] comms_api | [ACT] ^FUNC | [TGT] transmitPacket | [VAL] addedRetry=true timeout=200ms | [REF] comms.js:104"
147 | parsed = parse_ascl(entry)
148 | print(parsed['TGT'])  # Output: transmitPacket
149 | ```
150 | 
151 | ---
152 | 
153 | ## 🚀 Use Cases
154 | 
155 | * Agent-to-agent communication during CI/CD deployments.
156 | * Local-only changelog documentation for generated files.
157 | * Synchronization of logic/data changes across distributed AI services.
158 | * Tracking of function/data evolution in projects with limited human intervention.
159 | * Rollback, replay, or diff generation for agent-maintained systems.
160 | * Language-agnostic documentation of granular codebase evolution.
161 | 
162 | ---
163 | 
164 | ## 📆 Timestamp Format Spec
165 | 
166 | The timestamp format `MMDDYY-HHMM` includes both date and time components.
167 | 
168 | | Field | Format                             |
169 | | ----- | ---------------------------------- |
170 | | MM    | 2-digit month (e.g., 06 = June)    |
171 | | DD    | 2-digit day (e.g., 28)             |
172 | | YY    | 2-digit year (e.g., 24 = 2024)     |
173 | | HHMM  | 24-hour time (e.g., 1305 = 1:05pm) |
174 | 
175 | ---
176 | 
177 | ## 📄 Template
178 | 
179 | ```
180 | [TS] <MMDDYY-HHMM>
181 | [MOD] <module_name>
182 | [ACT] <action_code>
183 | [TGT] <target_changed>
184 | [VAL] <comma-separated key=value>
185 | [REF] <file_path[:line]>
186 | ```
187 | 
188 | ---
189 | 
190 | ASCL is meant to evolve with your agents. Let humans write paragraphs. Let agents speak in protocol.
191 | 
192 | > **"ASCL is not for you. It's for the next you."**


--------------------------------------------------------------------------------
/assets/asset-list.json:
--------------------------------------------------------------------------------
  1 | [
  2 |   "/assets/images/academy_portrait.png",
  3 |   "/assets/images/arm_nuke_icon.png",
  4 |   "/assets/images/armory_portrait.png",
  5 |   "/assets/images/attack_icon.png",
  6 |   "/assets/images/barracks_portrait.png",
  7 |   "/assets/images/battlecruiser_portrait.png",
  8 |   "/assets/images/build_academy_icon.png",
  9 |   "/assets/images/build_advanced_structures_icon.png",
 10 |   "/assets/images/build_armory_icon.png",
 11 |   "/assets/images/build_barracks_icon.png",
 12 |   "/assets/images/build_basic_structures_icon.png",
 13 |   "/assets/images/build_bunker_icon.png",
 14 |   "/assets/images/build_command_center_icon.png",
 15 |   "/assets/images/build_comsat_station_icon.png",
 16 |   "/assets/images/build_control_tower_icon.png",
 17 |   "/assets/images/build_engineering_bay_icon.png",
 18 |   "/assets/images/build_factory_icon.png",
 19 |   "/assets/images/build_missile_turret_icon.png",
 20 |   "/assets/images/build_nuclear_silo_icon.png",
 21 |   "/assets/images/build_physics_lab_icon.png",
 22 |   "/assets/images/build_refinery_icon.png",
 23 |   "/assets/images/build_science_facility_icon.png",
 24 |   "/assets/images/build_scv_icon.png",
 25 |   "/assets/images/build_scv2_icon.png",
 26 |   "/assets/images/build_starport_icon.png",
 27 |   "/assets/images/build_supply_depot_icon.png",
 28 |   "/assets/images/bunker_portrait.png",
 29 |   "/assets/images/charon_boosters_icon.png",
 30 |   "/assets/images/cloak_icon.png",
 31 |   "/assets/images/command_center_portrait.png",
 32 |   "/assets/images/comsat_station_portrait.png",
 33 |   "/assets/images/control_tower_portrait.png",
 34 |   "/assets/images/defensive_matrix_icon.png",
 35 |   "/assets/images/dropship_portrait.png",
 36 |   "/assets/images/emp_shockwave_icon.png",
 37 |   "/assets/images/engineering_bay_portrait.png",
 38 |   "/assets/images/factory_portrait.png",
 39 |   "/assets/images/firebat_portrait.png",
 40 |   "/assets/images/gather_icon.png",
 41 |   "/assets/images/ghost_portrait.png",
 42 |   "/assets/images/goliath_portrait.png",
 43 |   "/assets/images/goliaths.png",
 44 |   "/assets/images/heal_icon.png",
 45 |   "/assets/images/hold_position_icon.png",
 46 |   "/assets/images/irradiate_icon.png",
 47 |   "/assets/images/lift_off_icon.png",
 48 |   "/assets/images/lockdown_icon.png",
 49 |   "/assets/images/lower_depot_icon.png",
 50 |   "/assets/images/marine_portrait.png",
 51 |   "/assets/images/medic_portrait.png",
 52 |   "/assets/images/mineral_field_portrait.png",
 53 |   "/assets/images/minerals_icon.png",
 54 |   "/assets/images/missile_turret_portrait.png",
 55 |   "/assets/images/move_icon.png",
 56 |   "/assets/images/nuke_strike_icon.png",
 57 |   "/assets/images/nuclear_silo_portrait.png",
 58 |   "/assets/images/patrol_icon.png",
 59 |   "/assets/images/physics_lab_portrait.png",
 60 |   "/assets/images/protoss/adept_portrait.png",
 61 |   "/assets/images/protoss/probe_portrait.png",
 62 |   "/assets/images/protoss/stalker_portrait.png",
 63 |   "/assets/images/protoss/dragoon_portrait.png",
 64 |   "/assets/images/protoss/train_adept_icon.png",
 65 |   "/assets/images/protoss/train_probe_icon.png",
 66 |   "/assets/images/protoss/train_stalker_icon.png",
 67 |   "/assets/images/protoss/train_dragoon_icon.png",
 68 |   "/assets/images/protoss/train_darktemplar_icon.png",
 69 |   "/assets/images/protoss/train_zealot_icon.png",
 70 |   "/assets/images/protoss/zealot_portrait.png",
 71 |   "/assets/images/protoss/darktemplar_portrait.png",
 72 |   "/assets/images/raise_depot_icon.png",
 73 |   "/assets/images/refinery_portrait.png",
 74 |   "/assets/images/research_siege_mode_icon.png",
 75 |   "/assets/images/scanner_sweep_icon.png",
 76 |   "/assets/images/science_facility_portrait.png",
 77 |   "/assets/images/science_vessel_portrait.png",
 78 |   "/assets/images/scv_portrait.png",
 79 |   "/assets/images/scv2.png",
 80 |   "/assets/images/siege_mode_icon.png",
 81 |   "/assets/images/siege_tank_portrait.png",
 82 |   "/assets/images/siegetanks.png",
 83 |   "/assets/images/starfield_texture.png",
 84 |   "/assets/images/starport_portrait.png",
 85 |   "/assets/images/stim_pack_icon.png",
 86 |   "/assets/images/stop_icon.png",
 87 |   "/assets/images/supply_depot_portrait.png",
 88 |   "/assets/images/tank_mode_icon.png",
 89 |   "/assets/images/terrain_texture.png",
 90 |   "/assets/images/train_battlecruiser_icon.png",
 91 |   "/assets/images/train_dropship_icon.png",
 92 |   "/assets/images/train_firebat_icon.png",
 93 |   "/assets/images/train_ghost_icon.png",
 94 |   "/assets/images/train_goliath_icon.png",
 95 |   "/assets/images/train_marine_icon.png",
 96 |   "/assets/images/train_medic_icon.png",
 97 |   "/assets/images/train_science_vessel_icon.png",
 98 |   "/assets/images/train_siege_tank_icon.png",
 99 |   "/assets/images/train_valkyrie_icon.png",
100 |   "/assets/images/train_vulture_icon.png",
101 |   "/assets/images/train_wraith_icon.png",
102 |   "/assets/images/u238_shells_icon.png",
103 |   "/assets/images/unload_all_icon.png",
104 |   "/assets/images/upgrade_infantry_armor_icon.png",
105 |   "/assets/images/upgrade_infantry_weapons_icon.png",
106 |   "/assets/images/valkyrie_portrait.png",
107 |   "/assets/images/vespene_geyser_portrait.png",
108 |   "/assets/images/vespene_icon.png",
109 |   "/assets/images/vulture_portrait.png",
110 |   "/assets/images/wraith_portrait.png",
111 |   "/assets/images/ws-sc-bg.png",
112 |   "/assets/images/yamato_cannon_icon.png"
113 | ]


--------------------------------------------------------------------------------
/assets/audio/move.mp3:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/audio/move.mp3


--------------------------------------------------------------------------------
/assets/audio/select.mp3:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/audio/select.mp3


--------------------------------------------------------------------------------
/assets/css/base.css:
--------------------------------------------------------------------------------
  1 | body {
  2 |     margin: 0;
  3 |     overflow: hidden;
  4 |     font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
  5 |     background-color: #000;
  6 |     color: #fff;
  7 |     user-select: none;
  8 | }
  9 | 
 10 | #game-container {
 11 |     position: absolute;
 12 |     top: 5vh;
 13 |     left: 0;
 14 |     width: 100vw;
 15 |     height: 70vh;
 16 | }
 17 | 
 18 | canvas {
 19 |     display: block;
 20 | }
 21 | 
 22 | .panel {
 23 |     background-color: #202028;
 24 |     border: 2px solid #000;
 25 |     border-top-color: #555c6e;
 26 |     border-left-color: #555c6e;
 27 |     border-bottom-color: #11141a;
 28 |     border-right-color: #11141a;
 29 | }
 30 | 
 31 | #top-bar {
 32 |     position: absolute;
 33 |     top: 0;
 34 |     left: 0;
 35 |     width: 100%;
 36 |     height: 5vh;
 37 |     z-index: 100;
 38 |     box-sizing: border-box;
 39 |     display: flex;
 40 |     justify-content: center;
 41 |     align-items: center;
 42 | }
 43 | 
 44 | #resources {
 45 |     display: flex;
 46 |     gap: 20px;
 47 | }
 48 | 
 49 | .resource-display {
 50 |     display: flex;
 51 |     align-items: center;
 52 |     gap: 6px;
 53 |     font-size: clamp(12px, 1.5vh, 16px);
 54 | }
 55 | 
 56 | #mineral-count {
 57 |     color: #ffff00;
 58 | }
 59 | 
 60 | #vespene-count {
 61 |     color: #00ff00;
 62 | }
 63 | 
 64 | .resource-icon {
 65 |     width: clamp(14px, 2vh, 18px);
 66 |     height: clamp(14px, 2vh, 18px);
 67 | }
 68 | 
 69 | #supply {
 70 |     position: absolute;
 71 |     right: 30px;
 72 |     color: #fff;
 73 |     font-size: clamp(12px, 1.5vh, 16px);
 74 |     border: 1px solid #00f; /* Player color hint */
 75 |     padding: 2px 4px;
 76 | }
 77 | 
 78 | #compass {
 79 |     position: absolute;
 80 |     left: 30px;
 81 |     color: #fff;
 82 |     font-size: clamp(12px, 1.5vh, 16px);
 83 | }
 84 | 
 85 | #bottom-bar {
 86 |     position: absolute;
 87 |     bottom: 0;
 88 |     left: 0;
 89 |     width: 100%;
 90 |     height: 25vh;
 91 |     z-index: 100;
 92 |     box-sizing: border-box;
 93 |     display: flex;
 94 |     justify-content: space-between;
 95 |     align-items: stretch;
 96 | }
 97 | 
 98 | #minimap-panel {
 99 |     width: 25vh; /* Make it square based on bottom bar height */
100 |     height: 100%;
101 |     margin: 4px;
102 |     padding: 4px;
103 | }
104 | #minimap {
105 |     width: 100%;
106 |     height: 100%;
107 |     background: #111;
108 |     border: 1px solid #888;
109 | }
110 | 
111 | #unit-info-container {
112 |     display: flex;
113 |     justify-content: flex-start;
114 |     align-items: center;
115 |     gap: 8px;
116 |     padding-bottom: 8px;
117 |     flex-grow: 1;
118 | }
119 | 
120 | #unit-portrait-panel {
121 |     width: 120px;
122 |     text-align: center;
123 |     display: none; /* Hidden by default */
124 | }
125 | 
126 | #portrait-box {
127 |     width: 80px;
128 |     height: 80px;
129 |     border: 2px solid #555c6e;
130 |     margin: 0 auto;
131 |     background: #000;
132 |     position: relative;
133 | }
134 | 
135 | #portrait-img {
136 |     width: 100%;
137 |     height: 100%;
138 |     object-fit: cover;
139 | }
140 | 
141 | #unit-count-overlay {
142 |     position: absolute;
143 |     top: -2px;
144 |     right: -2px;
145 |     background: rgba(0,0,0,0.7);
146 |     color: #fff;
147 |     padding: 1px 5px;
148 |     font-size: 14px;
149 |     border: 1px solid #888;
150 |     display: none;
151 | }
152 | 
153 | #unit-status {
154 |     margin-top: 4px;
155 | }
156 | 
157 | .status-bar-container {
158 |     position: relative;
159 |     width: 80px;
160 |     margin: 2px auto;
161 | }
162 | 
163 | .status-bar {
164 |     height: 10px;
165 |     border: 1px solid #000;
166 |     background-color: #555;
167 | }
168 | 
169 | .health-bar > div {
170 |     height: 100%;
171 |     transition: width 0.2s, background-color 0.2s;
172 | }
173 | 
174 | .shield-bar > div {
175 |     height: 100%;
176 |     background-color: #00a1ff;
177 |     transition: width 0.2s;
178 | }
179 | 
180 | .energy-bar > div {
181 |     height: 100%;
182 |     background-color: #4444ff;
183 |     transition: width 0.2s;
184 | }
185 | 
186 | #unit-name {
187 |     font-size: 14px;
188 |     font-weight: bold;
189 |     color: #a7d1ff;
190 |     margin-top: 4px;
191 |     line-height: 1.1;
192 | }
193 | 
194 | .panel-text {
195 |     text-shadow: 1px 1px 2px #000;
196 | }
197 | 
198 | #unit-shield-text,
199 | #unit-health-text {
200 |     position: absolute;
201 |     width: 100%;
202 |     top: 50%;
203 |     left: 0;
204 |     transform: translateY(-50%);
205 |     font-size: 9px;
206 |     line-height: 1;
207 |     color: #fff;
208 |     text-shadow: 1px 1px 1px #000;
209 |     text-align: center;
210 |     pointer-events: none;
211 | }
212 | 
213 | #unit-energy-text {
214 |     position: absolute;
215 |     width: 100%;
216 |     top: 50%;
217 |     left: 0;
218 |     transform: translateY(-50%);
219 |     font-size: 9px;
220 |     line-height: 1;
221 |     color: #fff;
222 |     text-shadow: 1px 1px 1px #000;
223 |     text-align: center;
224 |     pointer-events: none;
225 | }
226 | 
227 | #command-card-panel {
228 |     padding: 4px;
229 |     display: flex;
230 |     flex-direction: column;
231 | }
232 | 
233 | .command-grid {
234 |     display: grid;
235 |     grid-template-columns: repeat(4, 40px);
236 |     grid-template-rows: repeat(3, 40px);
237 |     gap: 4px;
238 | }
239 | 
240 | .command-button {
241 |     width: 40px;
242 |     height: 40px;
243 |     background-color: #3a4a5a;
244 |     border: 2px outset #5a6a7a;
245 |     position: relative;
246 |     cursor: pointer;
247 | }
248 | .command-button:hover {
249 |     border-color: #8acfff;
250 |     border-radius: 3px;
251 |     border: 1px solid #fff;
252 | }
253 | .command-button:active {
254 |     border-style: inset;
255 | }
256 | .command-button .icon {
257 |     width: 32px;
258 |     height: 32px;
259 |     margin: 2px;
260 |     background-size: contain;
261 |     background-repeat: no-repeat;
262 |     background-position: center;
263 | }
264 | .command-button .hotkey {
265 |     position: absolute;
266 |     bottom: 0;
267 |     right: 2px;
268 |     font-size: 10px;
269 |     color: #fff;
270 |     text-shadow: 1px 1px 1px #000;
271 | }
272 | 
273 | #build-queue-display {
274 |     height: 30px;
275 |     margin-bottom: 4px;
276 |     padding: 2px;
277 |     display: flex; /* Always visible */
278 |     align-items: center;
279 |     gap: 2px;
280 | }
281 | 
282 | .build-queue-item {
283 |     width: 26px;
284 |     height: 26px;
285 |     border: 1px solid #5a6a7a;
286 |     background-color: #1a1a22;
287 | }
288 | 
289 | .build-queue-item img {
290 |     width: 100%;
291 |     height: 100%;
292 | }
293 | 
294 | .build-progress-container {
295 |     position: absolute;
296 |     bottom: 0;
297 |     left: 0;
298 |     width: 100%;
299 |     height: 4px;
300 |     background-color: rgba(0,0,0,0.5);
301 |     border-top: 1px solid #000;
302 | }
303 | 
304 | .build-progress-bar {
305 |     width: 0%;
306 |     height: 100%;
307 |     background-color: #00ff00;
308 |     transition: width 0.1s linear;
309 | }
310 | 
311 | .build-queue-count {
312 |     position: absolute;
313 |     top: 2px;
314 |     right: 2px;
315 |     background: rgba(0,0,0,0.8);
316 |     color: #fff;
317 |     font-size: 12px;
318 |     padding: 0px 4px;
319 |     border-radius: 3px;
320 |     border: 1px solid #fff;
321 | }
322 | 
323 | #video-panel {
324 |     width: auto; /* Fallback, will be set by JS */
325 |     min-width: 150px; /* Prevent it from becoming too small */
326 |     margin: 4px;
327 |     padding: 4px;
328 |     background: #000;
329 |     color: #a7d1ff;
330 |     display: flex;
331 |     justify-content: center;
332 |     align-items: center;
333 |     position: relative;
334 |     margin-left: auto;
335 | }
336 | 
337 | #status-text-panel-container {
338 |     flex-grow: 1;
339 |     display: flex;
340 |     justify-content: flex-end;
341 | }
342 | #status-text-panel {
343 |     width: 200px;
344 |     margin: 4px;
345 |     padding: 8px;
346 |     font-size: 12px;
347 |     color: #a7d1ff;
348 |     overflow-y: auto;
349 |     display: flex;
350 |     flex-direction: column-reverse;
351 | }
352 | 
353 | .placement-text {
354 |     color: #ffff00;
355 |     margin-top: auto;
356 |     padding-top: 5px;
357 | }


--------------------------------------------------------------------------------
/assets/css/menu.css:
--------------------------------------------------------------------------------
  1 | #start-screen {
  2 |     position: fixed;
  3 |     top: 0;
  4 |     left: 0;
  5 |     width: 100%;
  6 |     height: 100%;
  7 |     display: flex;
  8 |     justify-content: center;
  9 |     align-items: center;
 10 |     flex-direction: column;
 11 |     background-color: #000;
 12 |     background-image: url('../images/ws-sc-bg.png');
 13 |     background-size: contain;
 14 |     background-repeat: no-repeat;
 15 |     background-position: center;
 16 |     z-index: 999;
 17 |     gap: 20px;
 18 | }
 19 | 
 20 | .start-content-wrapper {
 21 |     display: flex;
 22 |     align-items: center;
 23 |     justify-content: center;
 24 |     gap: 50px;
 25 |     position: relative; /* Allow absolute positioning for children */
 26 |     width: 100%; /* Make wrapper full width for easier positioning */
 27 | }
 28 | 
 29 | #promo-image-right {
 30 |     max-width: 280px;
 31 |     height: auto;
 32 |     border: none;
 33 |     position: absolute;
 34 |     top: 50%;
 35 |     left: calc(50% + 250px); /* Position it to the right of the centered menu */
 36 |     transform: translateY(-50%) rotate(-30deg);
 37 | }
 38 | 
 39 | #promo-image-left {
 40 |     max-width: 280px;
 41 |     height: auto;
 42 |     border: none;
 43 |     position: absolute;
 44 |     top: 50%;
 45 |     right: calc(50% + 250px); /* Position it to the left of the centered menu */
 46 |     transform: translateY(-50%) rotate(30deg);
 47 | }
 48 | 
 49 | #main-menu, #options-menu {
 50 |     display: flex;
 51 |     flex-direction: column;
 52 |     align-items: center;
 53 |     gap: 20px;
 54 | }
 55 | 
 56 | #options-menu {
 57 |     background-color: rgba(0,0,0,0.75);
 58 |     padding: 30px 50px;
 59 |     border-radius: 10px;
 60 |     border: 2px solid #555c6e;
 61 |     box-shadow: 0 0 20px rgba(0,0,0,0.5);
 62 |     min-width: 350px;
 63 | }
 64 | 
 65 | .options-slider {
 66 |     display: flex;
 67 |     flex-direction: column;
 68 |     align-items: center;
 69 |     gap: 5px;
 70 |     width: 100%;
 71 | }
 72 | 
 73 | .options-slider label {
 74 |     font-size: 18px;
 75 |     color: #a7d1ff;
 76 | }
 77 | 
 78 | .options-slider input[type="range"] {
 79 |     width: 80%;
 80 | }
 81 | 
 82 | #options-menu h2 {
 83 |     margin: 0 0 10px 0;
 84 |     font-size: 28px;
 85 |     color: #a7d1ff;
 86 |     text-shadow: 1px 1px 2px #000;
 87 | }
 88 | 
 89 | .hidden {
 90 |     display: none !important;
 91 | }
 92 | 
 93 | #start-button, #options-button, #back-button, #changelog-button, #manual-button {
 94 |     padding: 15px 30px;
 95 |     font-size: 24px;
 96 |     color: #fff;
 97 |     background: rgba(0, 0, 0, 0.7);
 98 |     border: 2px solid #a7d1ff;
 99 |     border-radius: 8px;
100 |     cursor: pointer;
101 |     text-shadow: 2px 2px 4px #000;
102 |     min-width: 250px;
103 |     text-align: center;
104 |     transition: background-color 0.2s, transform 0.1s;
105 | }
106 | 
107 | #start-button:hover, #options-button:hover, #back-button:hover, #changelog-button:hover, #manual-button:hover {
108 |     background: rgba(30, 30, 50, 0.8);
109 | }
110 | 
111 | #start-button:active, #options-button:active, #back-button:active, #changelog-button:active, #manual-button:active {
112 |     transform: scale(0.98);
113 | }
114 | 
115 | #start-button {
116 |     animation: pulse 2s infinite;
117 | }
118 | 
119 | @keyframes pulse {
120 |     0% {
121 |         box-shadow: 0 0 0 0 rgba(167, 209, 255, 0.7);
122 |     }
123 |     70% {
124 |         box-shadow: 0 0 0 20px rgba(167, 209, 255, 0);
125 |     }
126 |     100% {
127 |         box-shadow: 0 0 0 0 rgba(167, 209, 255, 0);
128 |     }
129 | }
130 | 
131 | #ingame-options-overlay {
132 |     position: fixed;
133 |     top: 0;
134 |     left: 0;
135 |     width: 100%;
136 |     height: 100%;
137 |     background-color: rgba(0,0,0,0.7);
138 |     z-index: 998; /* Below start screen but above everything else */
139 |     display: flex;
140 |     justify-content: center;
141 |     align-items: center;
142 | }
143 | 
144 | #ingame-options-menu {
145 |     background-color: rgba(0,0,0,0.85);
146 |     padding: 30px 50px;
147 |     border-radius: 10px;
148 |     border: 2px solid #555c6e;
149 |     box-shadow: 0 0 20px rgba(0,0,0,0.5);
150 |     min-width: 350px;
151 |     display: flex;
152 |     flex-direction: column;
153 |     align-items: center;
154 |     gap: 20px;
155 | }
156 | 
157 | #ingame-options-menu h2 {
158 |     margin: 0 0 10px 0;
159 |     font-size: 28px;
160 |     color: #a7d1ff;
161 |     text-shadow: 1px 1px 2px #000;
162 | }
163 | 
164 | .menu-button {
165 |     padding: 15px 30px;
166 |     font-size: 24px;
167 |     color: #fff;
168 |     background: rgba(0, 0, 0, 0.7);
169 |     border: 2px solid #a7d1ff;
170 |     border-radius: 8px;
171 |     cursor: pointer;
172 |     text-shadow: 2px 2px 4px #000;
173 |     min-width: 250px;
174 |     text-align: center;
175 |     transition: background-color 0.2s, transform 0.1s;
176 | }
177 | 
178 | .menu-button:hover {
179 |     background: rgba(30, 30, 50, 0.8);
180 | }
181 | 
182 | .menu-button:active {
183 |     transform: scale(0.98);
184 | }


--------------------------------------------------------------------------------
/assets/css/modals.css:
--------------------------------------------------------------------------------
  1 | #spotify-modal {
  2 |     position: fixed;
  3 |     top: 0;
  4 |     left: 0;
  5 |     width: 100%;
  6 |     height: 100%;
  7 |     background-color: rgba(0,0,0,0.75);
  8 |     z-index: 1001;
  9 |     display: flex;
 10 |     justify-content: center;
 11 |     align-items: center;
 12 |     color: #333;
 13 | }
 14 | 
 15 | .spotify-modal-content {
 16 |     background-color: #f4f4f4;
 17 |     padding: 20px;
 18 |     border-radius: 10px;
 19 |     width: 90%;
 20 |     max-width: 400px;
 21 |     text-align: center;
 22 |     position: relative;
 23 |     box-shadow: 0 5px 15px rgba(0,0,0,0.5);
 24 | }
 25 | 
 26 | .spotify-modal-content h2 {
 27 |     margin-top: 0;
 28 |     color: #FF0000; /* YouTube Red */
 29 | }
 30 | 
 31 | .spotify-modal-content p {
 32 |     font-size: 16px;
 33 |     color: #555;
 34 | }
 35 | 
 36 | #spotify-player-placeholder {
 37 |     background-color: #282828;
 38 |     color: #fff;
 39 |     border-radius: 8px;
 40 |     padding: 20px;
 41 |     margin: 20px 0;
 42 |     height: 200px;
 43 |     display: flex;
 44 |     justify-content: center;
 45 |     align-items: center;
 46 |     font-size: 18px;
 47 |     border: 2px dashed #555;
 48 | }
 49 | 
 50 | .close-button {
 51 |     position: absolute;
 52 |     top: 10px;
 53 |     right: 15px;
 54 |     font-size: 30px;
 55 |     font-weight: bold;
 56 |     color: #aaa;
 57 |     background: none;
 58 |     border: none;
 59 |     cursor: pointer;
 60 | }
 61 | 
 62 | .close-button:hover {
 63 |     color: #333;
 64 | }
 65 | 
 66 | #dev-log-modal {
 67 |     position: fixed;
 68 |     top: 0;
 69 |     left: 0;
 70 |     width: 100%;
 71 |     height: 100%;
 72 |     background-color: rgba(0,0,0,0.75);
 73 |     z-index: 1002; /* Above video modal */
 74 |     display: flex;
 75 |     justify-content: center;
 76 |     align-items: center;
 77 |     color: #eee;
 78 | }
 79 | 
 80 | .dev-log-content {
 81 |     background-color: #1a1a22;
 82 |     padding: 20px;
 83 |     border-radius: 10px;
 84 |     width: 90%;
 85 |     max-width: 800px;
 86 |     height: 80vh;
 87 |     border: 1px solid #555c6e;
 88 |     position: relative;
 89 |     box-shadow: 0 5px 15px rgba(0,0,0,0.5);
 90 |     display: flex;
 91 |     flex-direction: column;
 92 | }
 93 | 
 94 | .dev-log-content h2 {
 95 |     margin-top: 0;
 96 |     color: #a7d1ff;
 97 |     text-align: center;
 98 | }
 99 | 
100 | #dev-log-output {
101 |     background-color: #0a0a0e;
102 |     flex-grow: 1;
103 |     overflow-y: scroll;
104 |     padding: 10px;
105 |     font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
106 |     font-size: 12px;
107 |     white-space: pre-wrap;
108 |     word-break: break-all;
109 |     border: 1px solid #333;
110 | }
111 | 
112 | #clear-dev-log-button {
113 |     position: absolute;
114 |     top: 15px;
115 |     left: 15px;
116 |     background: #4a5a6a;
117 |     color: white;
118 |     border: 1px solid #7a8a9a;
119 |     padding: 5px 10px;
120 |     cursor: pointer;
121 | }
122 | #clear-dev-log-button:hover {
123 |     background: #5a6a7a;
124 | }
125 | 
126 | #archive-changelog-button {
127 |     padding: 10px 20px;
128 |     font-size: 16px;
129 |     color: #fff;
130 |     background: #4a5a6a;
131 |     border: 1px solid #7a8a9a;
132 |     border-radius: 5px;
133 |     cursor: pointer;
134 |     text-shadow: 1px 1px 2px #000;
135 |     min-width: 200px;
136 |     text-align: center;
137 |     transition: background-color 0.2s, transform 0.1s;
138 |     margin-top: 10px;
139 | }
140 | 
141 | #archive-changelog-button:hover {
142 |     background: #5a6a7a;
143 | }
144 | 
145 | #archive-changelog-button:active {
146 |     transform: scale(0.98);
147 | }
148 | 
149 | #manual-modal,
150 | #changelog-modal {
151 |     position: fixed;
152 |     top: 0;
153 |     left: 0;
154 |     width: 100%;
155 |     height: 100%;
156 |     background-color: rgba(0,0,0,0.75);
157 |     z-index: 1003; /* Above dev log */
158 |     display: flex;
159 |     justify-content: center;
160 |     align-items: center;
161 |     color: #eee;
162 | }
163 | 
164 | .manual-tabs {
165 |     display: flex;
166 |     border-bottom: 1px solid #555c6e;
167 |     margin-bottom: 15px;
168 | }
169 | 
170 | .manual-tab {
171 |     padding: 10px 20px;
172 |     cursor: pointer;
173 |     background-color: transparent;
174 |     border: none;
175 |     color: #a7d1ff;
176 |     font-size: 16px;
177 |     border-bottom: 3px solid transparent;
178 |     transition: background-color 0.2s, border-color 0.2s;
179 | }
180 | 
181 | .manual-tab:hover {
182 |     background-color: rgba(138, 207, 255, 0.1);
183 | }
184 | 
185 | .manual-tab.active {
186 |     color: #fff;
187 |     font-weight: bold;
188 |     border-bottom-color: #a7d1ff;
189 | }
190 | 
191 | .manual-tab-pane {
192 |     display: none;
193 |     flex-grow: 1;
194 |     overflow: hidden; /* Needed for child with overflow-y:scroll */
195 |     flex-direction: column; /* For children to fill height */
196 | }
197 | 
198 | .manual-tab-pane.active {
199 |     display: flex;
200 | }
201 | 
202 | .changelog-tabs {
203 |     display: flex;
204 |     border-bottom: 1px solid #555c6e;
205 |     margin-bottom: 15px;
206 | }
207 | 
208 | .changelog-tab {
209 |     padding: 10px 20px;
210 |     cursor: pointer;
211 |     background-color: transparent;
212 |     border: none;
213 |     color: #a7d1ff;
214 |     font-size: 16px;
215 |     border-bottom: 3px solid transparent;
216 |     transition: background-color 0.2s, border-color 0.2s;
217 | }
218 | 
219 | .changelog-tab:hover {
220 |     background-color: rgba(138, 207, 255, 0.1);
221 | }
222 | 
223 | .changelog-tab.active {
224 |     color: #fff;
225 |     font-weight: bold;
226 |     border-bottom-color: #a7d1ff;
227 | }
228 | 
229 | .changelog-tab-pane {
230 |     display: none;
231 |     flex-grow: 1;
232 |     overflow: hidden;
233 |     flex-direction: column;
234 | }
235 | 
236 | .changelog-tab-pane.active {
237 |     display: flex;
238 | }
239 | 
240 | .manual-content,
241 | .changelog-content {
242 |     background-color: #1a1a22;
243 |     padding: 20px;
244 |     border-radius: 10px;
245 |     width: 90%;
246 |     max-width: 800px;
247 |     height: 80vh;
248 |     border: 1px solid #555c6e;
249 |     position: relative;
250 |     box-shadow: 0 5px 15px rgba(0,0,0,0.5);
251 |     display: flex;
252 |     flex-direction: column;
253 | }
254 | 
255 | #manual-content-container {
256 |     display: flex;
257 |     flex-direction: column;
258 |     overflow-y: auto;
259 |     flex-grow: 1;
260 | }
261 | 
262 | .manual-content h2,
263 | .changelog-content h2 {
264 |     margin-top: 0;
265 |     margin-bottom: 15px;
266 |     color: #a7d1ff;
267 |     text-align: center;
268 | }
269 | 
270 | #manual-output,
271 | .changelog-output {
272 |     background-color: #0a0a0e;
273 |     flex-grow: 1;
274 |     overflow-y: scroll;
275 |     padding: 10px;
276 |     font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
277 |     font-size: 14px;
278 |     white-space: pre-wrap;
279 |     word-break: break-all;
280 |     border: 1px solid #333;
281 |     /* @tweakable Adjust the line spacing in the changelog modal */
282 |     line-height: 1.5;
283 |     flex-grow: 1;
284 |     min-height: 0; /* Fix for flexbox scroll */
285 | }
286 | 
287 | #asset-list-container {
288 |     display: flex;
289 |     flex-direction: column;
290 |     height: 100%;
291 | }
292 | 
293 | #asset-list-container h3 {
294 |     margin: 0 0 10px 0;
295 |     color: #a7d1ff;
296 |     text-align: center;
297 |     flex-shrink: 0;
298 | }
299 | 
300 | #asset-list {
301 |     background-color: #0a0a0e;
302 |     padding: 10px;
303 |     font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
304 |     font-size: 12px;
305 |     border: 1px solid #333;
306 |     max-height: none;
307 |     overflow-y: scroll;
308 |     flex-grow: 1;
309 |     display: flex;
310 |     flex-wrap: wrap;
311 |     gap: 10px;
312 |     align-content: flex-start;
313 | }
314 | 
315 | .asset-item {
316 |     display: flex;
317 |     flex-direction: column;
318 |     align-items: center;
319 |     width: 80px;
320 |     text-align: center;
321 |     background-color: #1f1f28;
322 |     padding: 5px;
323 |     border-radius: 4px;
324 |     border: 1px solid #333;
325 | }
326 | 
327 | .asset-item img {
328 |     width: 64px;
329 |     height: 64px;
330 |     background-color: #0a0a0e;
331 |     border-radius: 3px;
332 | }
333 | 
334 | .asset-item .asset-name {
335 |     margin-top: 5px;
336 |     font-size: 10px;
337 |     color: #a7d1ff;
338 |     word-break: break-all;
339 |     height: 2.5em; /* Reserve space for 2 lines of text */
340 |     overflow: hidden;
341 | }
342 | 
343 | #promo-modal {
344 |     position: fixed;
345 |     top: 0;
346 |     left: 0;
347 |     width: 100%;
348 |     height: 100%;
349 |     background-color: rgba(0,0,0,0.75);
350 |     z-index: 1003;
351 |     display: flex;
352 |     justify-content: center;
353 |     align-items: center;
354 | }
355 | 
356 | .promo-content {
357 |     background-color: #000;
358 |     padding: 0;
359 |     border-radius: 10px;
360 |     width: 90%;
361 |     max-width: 800px;
362 |     position: relative;
363 | }
364 | 
365 | #promo-video {
366 |     width: 100%;
367 |     height: 450px;
368 |     border: none;
369 | }


--------------------------------------------------------------------------------
/assets/css/overlay.css:
--------------------------------------------------------------------------------
  1 | #selection-box {
  2 |     position: absolute;
  3 |     border: 1px solid #00ff00;
  4 |     background-color: rgba(0, 255, 0, 0.2);
  5 |     z-index: 101;
  6 |     display: none;
  7 |     pointer-events: none;
  8 |     box-sizing: border-box;
  9 | }
 10 | 
 11 | #tooltip {
 12 |     position: absolute;
 13 |     display: none;
 14 |     background-color: #1a1a22;
 15 |     border: 1px solid #a7d1ff;
 16 |     padding: 6px 8px;
 17 |     font-size: 12px;
 18 |     color: #a7d1ff;
 19 |     z-index: 200;
 20 |     pointer-events: none; /* So it doesn't interfere with mouse events */
 21 |     white-space: pre-wrap;
 22 |     border-radius: 3px;
 23 |     box-shadow: 0px 2px 5px rgba(0,0,0,0.5);
 24 | }
 25 | 
 26 | #global-message-container {
 27 |     position: fixed;
 28 |     top: 6vh; /* below top-bar */
 29 |     left: 50%;
 30 |     transform: translateX(-50%);
 31 |     z-index: 1000;
 32 |     pointer-events: none;
 33 |     display: flex;
 34 |     flex-direction: column;
 35 |     align-items: center;
 36 |     gap: 5px;
 37 | }
 38 | 
 39 | .global-message {
 40 |     background: rgba(0, 0, 0, 0.7);
 41 |     color: #ff4444; /* Red for errors */
 42 |     padding: 8px 16px;
 43 |     border-radius: 5px;
 44 |     font-size: 16px;
 45 |     text-shadow: 1px 1px 2px #000;
 46 |     transition: opacity 1s ease-out;
 47 |     opacity: 1;
 48 | }
 49 | 
 50 | #loading-overlay {
 51 |     position: fixed;
 52 |     top: 0;
 53 |     left: 0;
 54 |     width: 100%;
 55 |     height: 100%;
 56 |     display: none;
 57 |     justify-content: center;
 58 |     align-items: center;
 59 |     background-color: rgba(0,0,0,0.8);
 60 |     color: #fff;
 61 |     font-size: 24px;
 62 |     z-index: 1000;
 63 |     flex-direction: column;
 64 |     text-shadow: 2px 2px 4px #000;
 65 | }
 66 | 
 67 | #loading-progress-bar {
 68 |     width: 50%;
 69 |     margin: 10px 0;
 70 | }
 71 | 
 72 | #loading-overlay.visible {
 73 |     display: flex;
 74 | }
 75 | 
 76 | #credit-text {
 77 |     position: absolute;
 78 |     bottom: 20px;
 79 |     right: 20px;
 80 |     font-size: 16px;
 81 |     color: #ccc;
 82 |     text-shadow: 1px 1px 2px #000;
 83 | }
 84 | 
 85 | #grid-labels-container {
 86 |     position: absolute;
 87 |     top: 0;
 88 |     left: 0;
 89 |     width: 100%;
 90 |     height: 100%;
 91 |     pointer-events: none;
 92 |     overflow: hidden;
 93 |     z-index: 50;
 94 | }
 95 | 
 96 | .grid-label {
 97 |     position: absolute;
 98 |     color: white;
 99 |     font-size: 10px;
100 |     text-shadow: 1px 1px 2px black;
101 |     transform: translate(-50%, -50%);
102 |     opacity: 0.7;
103 | }
104 | 
105 | #mobile-controls {
106 |     position: fixed;
107 |     top: 5vh;
108 |     left: 0;
109 |     width: 100vw;
110 |     height: calc(100vh - 5vh - 25vh); /* Full viewport minus top/bottom bars */
111 |     z-index: 102; /* Above selection box */
112 |     pointer-events: none; /* Container doesn't block clicks */
113 | }
114 | 
115 | #mobile-controls.hidden {
116 |     display: none;
117 | }
118 | 
119 | #joystick-zone {
120 |     position: absolute;
121 |     bottom: 20px;
122 |     left: 20px;
123 |     width: 150px;
124 |     height: 150px;
125 |     background: rgba(128, 128, 128, 0.2);
126 |     border-radius: 50%;
127 |     pointer-events: auto; /* Joystick zone is interactive */
128 | }
129 | 
130 | #action-buttons-zone {
131 |     position: absolute;
132 |     bottom: 20px;
133 |     right: 20px;
134 |     display: flex;
135 |     flex-direction: column-reverse;
136 |     gap: 15px;
137 |     pointer-events: auto; /* Buttons are interactive */
138 | }
139 | 
140 | #action-buttons-zone button {
141 |     width: 80px;
142 |     height: 80px;
143 |     border-radius: 50%;
144 |     background: rgba(50, 50, 80, 0.6);
145 |     border: 2px solid #a7d1ff;
146 |     color: #fff;
147 |     font-size: 20px;
148 |     font-weight: bold;
149 |     text-shadow: 1px 1px 2px #000;
150 |     cursor: pointer;
151 | }
152 | 
153 | #action-buttons-zone button:active {
154 |     background: rgba(80, 80, 120, 0.8);
155 |     transform: scale(0.95);
156 | }
157 | 
158 | #mobile-cursor {
159 |     position: fixed;
160 |     top: calc(5vh + (70vh / 2)); /* Center of the game container vertically */
161 |     left: 50%;
162 |     transform: translate(-50%, -50%);
163 |     width: 24px;
164 |     height: 24px;
165 |     border: 2px solid rgba(255, 255, 255, 0.9);
166 |     border-radius: 50%;
167 |     box-shadow: 0 0 5px black;
168 |     pointer-events: none;
169 |     z-index: 103;
170 | }
171 | #mobile-cursor.hidden {
172 |     display: none;
173 | }
174 | #mobile-cursor::before, #mobile-cursor::after {
175 |     content: '';
176 |     position: absolute;
177 |     background-color: rgba(255, 255, 255, 0.9);
178 | }
179 | #mobile-cursor::before { /* Horizontal line */
180 |     top: 50%;
181 |     left: -4px;
182 |     width: 32px;
183 |     height: 2px;
184 |     margin-top: -1px;
185 | }
186 | #mobile-cursor::after { /* Vertical line */
187 |     left: 50%;
188 |     top: -4px;
189 |     height: 32px;
190 |     width: 2px;
191 |     margin-left: -1px;
192 | }
193 | 
194 | #mobile-controls-toggle, #dev-mode-toggle {
195 |     color: white;
196 |     background: rgba(0,0,0,0.6);
197 |     padding: 10px 15px;
198 |     border-radius: 5px;
199 |     display: flex;
200 |     align-items: center;
201 |     gap: 8px;
202 |     font-size: 18px;
203 |     border: 1px solid #555c6e;
204 |     cursor: pointer;
205 |     width: 80%;
206 |     justify-content: center;
207 | }
208 | 
209 | #mobile-controls-toggle:hover, #dev-mode-toggle:hover {
210 |     border-color: #a7d1ff;
211 | }
212 | 
213 | #mobile-controls-toggle label, #dev-mode-toggle label {
214 |     cursor: pointer;
215 | }
216 | 


--------------------------------------------------------------------------------
/assets/data/protoss/adept.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 70,
 4 |         "shields": 70,
 5 |         "armor": 1,
 6 |         "speed": 4.5
 7 |     }
 8 | }
 9 | 
10 | 


--------------------------------------------------------------------------------
/assets/data/protoss/darktemplar.json:
--------------------------------------------------------------------------------
1 | {
2 |     "stats": {
3 |         "health": 40,
4 |         "shields": 80,
5 |         "armor": 1,
6 |         "speed": 3.85
7 |     }
8 | }
9 | 


--------------------------------------------------------------------------------
/assets/data/protoss/dragoon.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 100,
 4 |         "shields": 80,
 5 |         "armor": 1,
 6 |         "speed": 3.0
 7 |     }
 8 | }
 9 | 
10 | 


--------------------------------------------------------------------------------
/assets/data/protoss/hightemplar.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 40,
 4 |         "shields": 40,
 5 |         "armor": 0,
 6 |         "speed": 2.63,
 7 |         "energy": 200
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/assets/data/protoss/probe.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 20,
 4 |         "shields": 20,
 5 |         "armor": 0,
 6 |         "speed": 4.5,
 7 |         "gatherTime": 2.0,
 8 |         "carryCapacity": 8
 9 |     }
10 | }
11 | 
12 | 


--------------------------------------------------------------------------------
/assets/data/protoss/stalker.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 80,
 4 |         "shields": 80,
 5 |         "armor": 1,
 6 |         "speed": 4.13
 7 |     }
 8 | }
 9 | 
10 | 


--------------------------------------------------------------------------------
/assets/data/protoss/zealot.json:
--------------------------------------------------------------------------------
 1 | {
 2 |     "stats": {
 3 |         "health": 100,
 4 |         "shields": 50,
 5 |         "armor": 1,
 6 |         "speed": 3.5
 7 |     }
 8 | }
 9 | 
10 | 


--------------------------------------------------------------------------------
/assets/extra-assets.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "glbs": [
 3 |     "assets/models/vulture.glb", 
 4 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/command_center.glb", 
 5 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/supply_depot.glb",
 6 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/science_facility.glb",
 7 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/minerals.glb",
 8 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/vespene_geyser.glb",
 9 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/physics_lab.glb",
10 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/Structures/control_tower.glb",
11 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/scv2.glb",
12 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/scv.glb",
13 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/control_tower.glb",
14 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/vulture.glb",
15 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/goliath.glb",
16 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/battlecruiser.glb",
17 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/valkyrie.glb",
18 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/wraith.glb",
19 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/dropship.glb",
20 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/assets/Terran/science_vessel.glb",
21 |     "assets/models/animations/SCV/Animation_Idle.glb",
22 |     "assets/models/animations/SCV/Animation_Walking.glb",
23 |     "assets/models/animations/SCV/Animation_MineRepair.glb"
24 |   ],
25 |   "mp3s": [
26 |     "assets/audio/select.mp3",
27 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/scv_ack1.mp3",
28 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/scv_ack2.mp3",
29 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/SCV_move.mp3",
30 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/SCV_move2.mp3",
31 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Generic/genericbgm.mp3",
32 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Generic/genericbgm2.mp3",
33 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Generic/genericbgm3.mp3",
34 |     "https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/terranbgm.mp3"
35 |   ],
36 |   "wavs": ["https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/move.wav"],
37 |   "mp4s": ["https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/scan.mp4"]
38 | }


--------------------------------------------------------------------------------
/assets/images/academy_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/academy_portrait.png


--------------------------------------------------------------------------------
/assets/images/arm_nuke_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/arm_nuke_icon.png


--------------------------------------------------------------------------------
/assets/images/armory_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/armory_portrait.png


--------------------------------------------------------------------------------
/assets/images/attack_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/attack_icon.png


--------------------------------------------------------------------------------
/assets/images/barracks_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/barracks_portrait.png


--------------------------------------------------------------------------------
/assets/images/battlecruiser_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/battlecruiser_portrait.png


--------------------------------------------------------------------------------
/assets/images/build_academy_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_academy_icon.png


--------------------------------------------------------------------------------
/assets/images/build_advanced_structures_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_advanced_structures_icon.png


--------------------------------------------------------------------------------
/assets/images/build_armory_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_armory_icon.png


--------------------------------------------------------------------------------
/assets/images/build_barracks_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_barracks_icon.png


--------------------------------------------------------------------------------
/assets/images/build_basic_structures_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_basic_structures_icon.png


--------------------------------------------------------------------------------
/assets/images/build_bunker_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_bunker_icon.png


--------------------------------------------------------------------------------
/assets/images/build_command_center_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_command_center_icon.png


--------------------------------------------------------------------------------
/assets/images/build_comsat_station_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_comsat_station_icon.png


--------------------------------------------------------------------------------
/assets/images/build_control_tower_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_control_tower_icon.png


--------------------------------------------------------------------------------
/assets/images/build_engineering_bay_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_engineering_bay_icon.png


--------------------------------------------------------------------------------
/assets/images/build_factory_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_factory_icon.png


--------------------------------------------------------------------------------
/assets/images/build_missile_turret_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_missile_turret_icon.png


--------------------------------------------------------------------------------
/assets/images/build_nuclear_silo_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_nuclear_silo_icon.png


--------------------------------------------------------------------------------
/assets/images/build_physics_lab_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_physics_lab_icon.png


--------------------------------------------------------------------------------
/assets/images/build_refinery_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_refinery_icon.png


--------------------------------------------------------------------------------
/assets/images/build_science_facility_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_science_facility_icon.png


--------------------------------------------------------------------------------
/assets/images/build_scv2_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_scv2_icon.png


--------------------------------------------------------------------------------
/assets/images/build_scv_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_scv_icon.png


--------------------------------------------------------------------------------
/assets/images/build_starport_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_starport_icon.png


--------------------------------------------------------------------------------
/assets/images/build_supply_depot_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/build_supply_depot_icon.png


--------------------------------------------------------------------------------
/assets/images/bunker_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/bunker_portrait.png


--------------------------------------------------------------------------------
/assets/images/charon_boosters_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/charon_boosters_icon.png


--------------------------------------------------------------------------------
/assets/images/cloak_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/cloak_icon.png


--------------------------------------------------------------------------------
/assets/images/command_center_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/command_center_portrait.png


--------------------------------------------------------------------------------
/assets/images/comsat_station_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/comsat_station_portrait.png


--------------------------------------------------------------------------------
/assets/images/control_tower_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/control_tower_portrait.png


--------------------------------------------------------------------------------
/assets/images/defensive_matrix_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/defensive_matrix_icon.png


--------------------------------------------------------------------------------
/assets/images/dropship_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/dropship_portrait.png


--------------------------------------------------------------------------------
/assets/images/emp_shockwave_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/emp_shockwave_icon.png


--------------------------------------------------------------------------------
/assets/images/engineering_bay_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/engineering_bay_portrait.png


--------------------------------------------------------------------------------
/assets/images/factory_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/factory_portrait.png


--------------------------------------------------------------------------------
/assets/images/firebat_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/firebat_portrait.png


--------------------------------------------------------------------------------
/assets/images/gather_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/gather_icon.png


--------------------------------------------------------------------------------
/assets/images/ghost_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/ghost_portrait.png


--------------------------------------------------------------------------------
/assets/images/goliath_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/goliath_portrait.png


--------------------------------------------------------------------------------
/assets/images/goliaths.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/goliaths.png


--------------------------------------------------------------------------------
/assets/images/heal_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/heal_icon.png


--------------------------------------------------------------------------------
/assets/images/hold_position_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/hold_position_icon.png


--------------------------------------------------------------------------------
/assets/images/irradiate_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/irradiate_icon.png


--------------------------------------------------------------------------------
/assets/images/lift_off_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/lift_off_icon.png


--------------------------------------------------------------------------------
/assets/images/lockdown_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/lockdown_icon.png


--------------------------------------------------------------------------------
/assets/images/lower_depot_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/lower_depot_icon.png


--------------------------------------------------------------------------------
/assets/images/marine_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/marine_portrait.png


--------------------------------------------------------------------------------
/assets/images/medic_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/medic_portrait.png


--------------------------------------------------------------------------------
/assets/images/mineral_field_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/mineral_field_portrait.png


--------------------------------------------------------------------------------
/assets/images/minerals_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/minerals_icon.png


--------------------------------------------------------------------------------
/assets/images/missile_turret_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/missile_turret_portrait.png


--------------------------------------------------------------------------------
/assets/images/move_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/move_icon.png


--------------------------------------------------------------------------------
/assets/images/nuclear_silo_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/nuclear_silo_portrait.png


--------------------------------------------------------------------------------
/assets/images/nuke_strike_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/nuke_strike_icon.png


--------------------------------------------------------------------------------
/assets/images/patrol_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/patrol_icon.png


--------------------------------------------------------------------------------
/assets/images/physics_lab_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/physics_lab_portrait.png


--------------------------------------------------------------------------------
/assets/images/protoss/adept_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/adept_portrait.png


--------------------------------------------------------------------------------
/assets/images/protoss/dragoon_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/dragoon_portrait.png


--------------------------------------------------------------------------------
/assets/images/protoss/probe_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/probe_portrait.png


--------------------------------------------------------------------------------
/assets/images/protoss/stalker_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/stalker_portrait.png


--------------------------------------------------------------------------------
/assets/images/protoss/train_adept_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/train_adept_icon.png


--------------------------------------------------------------------------------
/assets/images/protoss/train_dragoon_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/train_dragoon_icon.png


--------------------------------------------------------------------------------
/assets/images/protoss/train_probe_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/train_probe_icon.png


--------------------------------------------------------------------------------
/assets/images/protoss/train_stalker_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/train_stalker_icon.png


--------------------------------------------------------------------------------
/assets/images/protoss/train_zealot_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/train_zealot_icon.png


--------------------------------------------------------------------------------
/assets/images/protoss/zealot_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/protoss/zealot_portrait.png


--------------------------------------------------------------------------------
/assets/images/raise_depot_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/raise_depot_icon.png


--------------------------------------------------------------------------------
/assets/images/refinery_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/refinery_portrait.png


--------------------------------------------------------------------------------
/assets/images/research_siege_mode_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/research_siege_mode_icon.png


--------------------------------------------------------------------------------
/assets/images/scanner_sweep_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/scanner_sweep_icon.png


--------------------------------------------------------------------------------
/assets/images/science_facility_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/science_facility_portrait.png


--------------------------------------------------------------------------------
/assets/images/science_vessel_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/science_vessel_portrait.png


--------------------------------------------------------------------------------
/assets/images/scv2.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/scv2.png


--------------------------------------------------------------------------------
/assets/images/scv_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/scv_portrait.png


--------------------------------------------------------------------------------
/assets/images/siege_mode_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/siege_mode_icon.png


--------------------------------------------------------------------------------
/assets/images/siege_tank_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/siege_tank_portrait.png


--------------------------------------------------------------------------------
/assets/images/siegetanks.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/siegetanks.png


--------------------------------------------------------------------------------
/assets/images/starfield_texture.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/starfield_texture.png


--------------------------------------------------------------------------------
/assets/images/starport_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/starport_portrait.png


--------------------------------------------------------------------------------
/assets/images/stim_pack_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/stim_pack_icon.png


--------------------------------------------------------------------------------
/assets/images/stop_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/stop_icon.png


--------------------------------------------------------------------------------
/assets/images/supply_depot_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/supply_depot_portrait.png


--------------------------------------------------------------------------------
/assets/images/tank_mode_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/tank_mode_icon.png


--------------------------------------------------------------------------------
/assets/images/terrain_texture.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/terrain_texture.png


--------------------------------------------------------------------------------
/assets/images/train_battlecruiser_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_battlecruiser_icon.png


--------------------------------------------------------------------------------
/assets/images/train_dropship_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_dropship_icon.png


--------------------------------------------------------------------------------
/assets/images/train_firebat_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_firebat_icon.png


--------------------------------------------------------------------------------
/assets/images/train_ghost_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_ghost_icon.png


--------------------------------------------------------------------------------
/assets/images/train_goliath_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_goliath_icon.png


--------------------------------------------------------------------------------
/assets/images/train_marine_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_marine_icon.png


--------------------------------------------------------------------------------
/assets/images/train_medic_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_medic_icon.png


--------------------------------------------------------------------------------
/assets/images/train_science_vessel_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_science_vessel_icon.png


--------------------------------------------------------------------------------
/assets/images/train_siege_tank_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_siege_tank_icon.png


--------------------------------------------------------------------------------
/assets/images/train_valkyrie_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_valkyrie_icon.png


--------------------------------------------------------------------------------
/assets/images/train_vulture_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_vulture_icon.png


--------------------------------------------------------------------------------
/assets/images/train_wraith_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/train_wraith_icon.png


--------------------------------------------------------------------------------
/assets/images/u238_shells_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/u238_shells_icon.png


--------------------------------------------------------------------------------
/assets/images/unload_all_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/unload_all_icon.png


--------------------------------------------------------------------------------
/assets/images/upgrade_infantry_armor_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/upgrade_infantry_armor_icon.png


--------------------------------------------------------------------------------
/assets/images/upgrade_infantry_weapons_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/upgrade_infantry_weapons_icon.png


--------------------------------------------------------------------------------
/assets/images/valkyrie_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/valkyrie_portrait.png


--------------------------------------------------------------------------------
/assets/images/vespene_geyser_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/vespene_geyser_portrait.png


--------------------------------------------------------------------------------
/assets/images/vespene_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/vespene_icon.png


--------------------------------------------------------------------------------
/assets/images/vulture_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/vulture_portrait.png


--------------------------------------------------------------------------------
/assets/images/wraith_portrait.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/wraith_portrait.png


--------------------------------------------------------------------------------
/assets/images/ws-sc-bg.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/ws-sc-bg.png


--------------------------------------------------------------------------------
/assets/images/yamato_cannon_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/images/yamato_cannon_icon.png


--------------------------------------------------------------------------------
/assets/models/animations/SCV/Animation_Idle.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/animations/SCV/Animation_Idle.glb


--------------------------------------------------------------------------------
/assets/models/animations/SCV/Animation_MineRepair.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/animations/SCV/Animation_MineRepair.glb


--------------------------------------------------------------------------------
/assets/models/animations/SCV/Animation_Walking.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/animations/SCV/Animation_Walking.glb


--------------------------------------------------------------------------------
/assets/models/battlecruiser.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/battlecruiser.glb


--------------------------------------------------------------------------------
/assets/models/command_center.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/command_center.glb


--------------------------------------------------------------------------------
/assets/models/control_tower.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/control_tower.glb


--------------------------------------------------------------------------------
/assets/models/dropship.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/dropship.glb


--------------------------------------------------------------------------------
/assets/models/goliath.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/goliath.glb


--------------------------------------------------------------------------------
/assets/models/minerals.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/minerals.glb


--------------------------------------------------------------------------------
/assets/models/physics_lab.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/physics_lab.glb


--------------------------------------------------------------------------------
/assets/models/protoss/adept.glb:
--------------------------------------------------------------------------------
1 | description: "A 3D model of a Protoss Adept from StarCraft. A sleek, armored female warrior figure with floating shoulder plates and a helmet that covers her face. She carries a glaive cannon. The model should look agile and psionic."
2 | 
3 | 


--------------------------------------------------------------------------------
/assets/models/protoss/dragoon.glb:
--------------------------------------------------------------------------------
1 | description: "A 3D model of a Protoss Dragoon from StarCraft. A bulky, four-legged mechanical walker with a blue crystalline core. It has a phase disruptor cannon mounted on top. It looks powerful and mechanical."
2 | 
3 | 


--------------------------------------------------------------------------------
/assets/models/protoss/probe.glb:
--------------------------------------------------------------------------------
1 | description: "A 3D model of a Protoss Probe from StarCraft. A small, spherical, robotic unit that hovers. It has a single large blue eye and small appendages. It should look futuristic and slightly insectoid."
2 | 
3 | 


--------------------------------------------------------------------------------
/assets/models/protoss/stalker.glb:
--------------------------------------------------------------------------------
1 | description: "A 3D model of a Protoss Stalker from StarCraft. A tall, dark, four-legged mechanical walker with a central crystalline core. It looks menacing and agile."
2 | 
3 | 
4 | 
5 | 


--------------------------------------------------------------------------------
/assets/models/protoss/zealot.glb:
--------------------------------------------------------------------------------
1 | description: "A 3D model of a Protoss Zealot from StarCraft. A tall, armored bipedal warrior with golden armor, glowing blue eyes, and no visible mouth. It stands ready for battle. The model should have a heroic but alien posture."
2 | 
3 | 


--------------------------------------------------------------------------------
/assets/models/science_facility.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/science_facility.glb


--------------------------------------------------------------------------------
/assets/models/science_vessel.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/science_vessel.glb


--------------------------------------------------------------------------------
/assets/models/scv.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/scv.glb


--------------------------------------------------------------------------------
/assets/models/scv2.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/scv2.glb


--------------------------------------------------------------------------------
/assets/models/supply_depot.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/supply_depot.glb


--------------------------------------------------------------------------------
/assets/models/valkyrie.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/valkyrie.glb


--------------------------------------------------------------------------------
/assets/models/vulture.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/vulture.glb


--------------------------------------------------------------------------------
/assets/models/wraith.glb:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Starcraft/58aa8b1f6d8b30f331351f23159626a8546ca96b/assets/models/wraith.glb


--------------------------------------------------------------------------------
/changelog.md:
--------------------------------------------------------------------------------
 1 | # Changelog
 2 | 
 3 | This file contains recent changes. For older entries, see the `Archive` tab.
 4 | [TS] 063025-2153 | [MOD] resources | [ACT] ^FIX | [TGT] MineralField model offset | [VAL] wrapper group preserves vertical offset | [REF] src/resources/mineral-field.js:17-24,112-120
 5 | 
 6 | [TS] 063025-2143 | [MOD] units | [ACT] ^FIX | [TGT] science_vessel orientation | [VAL] rotated model 180deg to face forward | [REF] src/units/science-vessel.js:86,124
 7 | 
 8 | [TS] 063025-2139 | [MOD] docs | [ACT] ^ENH | [TGT] agent-units.md | [VAL] expanded unit guide with detailed steps | [REF] agent-units.md:1-81
 9 | [TS] 063025-2135 | [MOD] units | [ACT] ^FIX | [TGT] battlecruiser,wraith,dropship orientation | [VAL] rotated models 180deg to face forward | [REF] src/units/battlecruiser.js:77,118 src/units/wraith.js:76,118 src/units/dropship.js:88,141
10 | 
11 | [TS] 063025-1903 | [MOD] docs | [ACT] ^DOC | [TGT] README.md | [VAL] note '/' key opens promo video | [REF] README.md:25-27
12 | [TS] 063025-1859 | [MOD] spawn | [ACT] ^FUNC ^VAR | [TGT] spawnUnit, devUnitSpawnLayout.startPosition | [VAL] ensure walkable spawn coords and move dev units onto land | [REF] src/game/spawn.js:127-134 src/game/initial-state.js:28-33
13 | [TS] 063025-1904 | [MOD] docs | [ACT] ^DOC | [TGT] agent-units.md | [VAL] replaced missing unit integration sections, referenced High Templar example | [REF] agent-units.md:1-51
14 | [TS] 063025-1859 | [MOD] spawn | [ACT] ^FUNC ^VAR | [TGT] spawnUnit, devUnitSpawnLayout.startPosition | [VAL] ensure walkable spawn coords and move dev units onto land | [REF] src/game/spawn.js:127-134 src/game/initial-state.js:28-33
15 | [TS] 063025-1855 | [MOD] units | [ACT] ^FUNC | [TGT] createMeshFromGLB/createProceduralMesh | [VAL] rotated child groups so lookAt controls heading | [REF] src/units/battlecruiser.js:63-120 src/units/dropship.js:87-142 src/units/wraith.js:74-120
16 | [TS] 063025-1904 | [MOD] docs | [ACT] ^DOC | [TGT] README.md | [VAL] note changelog archiving script, jsdom install, and unit add instructions | [REF] README.md:11-31
17 | [TS] 063025-1908 | [MOD] units | [ACT] +CLASS +FILE | [TGT] HighTemplar | [VAL] Added Protoss High Templar unit with data and game integration. | [REF] src/protoss/hightemplar.js, assets/data/protoss/hightemplar.json, src/game/spawn.js, src/game/preloader.js, src/game/initial-state.js, src/game/selection.js
18 | [TS] 063025-1905 | [MOD] ui | [ACT] MIGR +CLASS -FN | [TGT] ModalManager split | [VAL] extracted ManualModal, ChangelogModal, DevLogModal and PromoModal classes | [REF] src/game/ui/modals
19 | [TS] 063025-1859 | [MOD] spawn | [ACT] ^FUNC ^VAR | [TGT] spawnUnit, devUnitSpawnLayout.startPosition | [VAL] ensure walkable spawn coords and move dev units onto land | [REF] src/game/spawn.js:127-134 src/game/initial-state.js:28-33
20 | [TS] 063025-1855 | [MOD] units | [ACT] ^FUNC | [TGT] createMeshFromGLB/createProceduralMesh | [VAL] rotated child groups so lookAt controls heading | [REF] src/units/battlecruiser.js:63-120 src/units/dropship.js:87-142 src/units/wraith.js:74-120
21 | [TS] 063025-1838 | [MOD] ui | [ACT] +FN ^UX | [TGT] promo modal | [VAL] YouTube iframe triggered by '/' key | [REF] index.html:215-223, assets/css/modals.css:343-366, src/game/ui/ModalManager.js:98-104,253-267, src/game/ui.js:63-67
22 | [TS] 063025-1834 | [MOD] archive | [ACT] ^FUNC -MOD ^DOC | [TGT] changelog-archive.js, package.json, AGENTS.md | [VAL] removed jsdom dependency and parse changelog lines directly | [REF] scripts/changelog-archive.js, package.json, AGENTS.md:59-66
23 | [TS] 063025-1824 | [MOD] deps | [ACT] +FILE | [TGT] package.json | [VAL] added jsdom dependency | [REF] package.json
24 | [TS] 063025-1824 | [MOD] docs | [ACT] ^DOC | [TGT] README.md, AGENTS.md | [VAL] include npm install instructions and note jsdom | [REF] README.md:6-14, AGENTS.md:33-67
25 | [TS] 063025-1820 | [MOD] docs | [ACT] +FILE ^DOC | [TGT] changelog archive | [VAL] added auto archive script, html loader and AGENTS note | [REF] scripts/changelog-archive.js, index.html:223, AGENTS.md:61
26 | [TS] 063025-1809 | [MOD] ui | [ACT] ^FIX | [TGT] changelog paths | [VAL] set root-relative changelog file paths | [REF] src/game/ui/ModalManager.js:13-16
27 | [TS] 063025-1803 | [MOD] ui | [ACT] ^FIX | [TGT] ModalManager dataset assignment | [VAL] replaced optional chaining with null checks | [REF] src/game/ui/ModalManager.js:80-83
28 | [TS] 063025-1754 | [MOD] ui | [ACT] -FN -VAR | [TGT] unused modal handlers | [VAL] removed legacy toggle functions and constants | [REF] src/game/ui.js
29 | [TS] 063025-1748 | [MOD] docs | [ACT] ^FIX | [TGT] README.md | [VAL] Clarified changelog button opens modal sourced from changelog files, not the manual. | [REF] README.md:22
30 | [TS] 063025-1745 | [MOD] ui | [ACT] ^VAR ^FUNC | [TGT] ModalManager | [VAL] Updated changelog paths and reload logic | [REF] src/game/ui/ModalManager.js
31 | [TS] 063025-1733 | [MOD] ui | [ACT] ^FIX | [TGT] ModalManager | [VAL] Use relative paths for changelog fetch to restore button | [REF] src/game/ui/ModalManager.js
32 | [TS] 063025-1720 | [MOD] units | [ACT] +CLASS | [TGT] DarkTemplar | [VAL] Added Protoss Dark Templar unit with data file, game integration, selection handling and asset preloading. | [REF] src/protoss/darktemplar.js, assets/data/protoss/darktemplar.json, src/game/preloader.js, src/game/selection.js, src/game/spawn.js, src/game/initial-state.js, assets/asset-list.json
33 | [TS] 063025-1659 | [MOD] docs | [ACT] ^ENH | [TGT] changelog system | [VAL] Split older entries into changelog.old.md and added changelog archive tab. | [REF] changelog.md, changelog.old.md, index.html, assets/css/modals.css, src/game/ui/ModalManager.js
34 | [TS] 063025-1049 | [MOD] ui | [ACT] ^ENH | [TGT] MessageDisplay.js, base.css | [VAL] Ad video now autoplays with loop and shows a close button after 30s instead of auto-closing. Video panel set to relative positioning for button. | [REF] src/game/ui/MessageDisplay.js, assets/css/base.css
35 | [TS] 063025-1656 | [MOD] ui | [ACT] ^UX | [TGT] MessageDisplay.js, ui.js, manual.md | [VAL] Disabled automatic ads and added '/' hotkey to watch promo video. Manual updated. | [REF] src/game/ui/MessageDisplay.js, src/game/ui.js, manual.md
36 | [TS] 063025-1642 | [MOD] ui | [ACT] ^ENH | [TGT] MessageDisplay.js, base.css | [VAL] Ad video now autoplays with loop and shows a close button after 30s instead of auto-closing. Video panel set to relative positioning for button. | [REF] src/game/ui/MessageDisplay.js, assets/css/base.css
37 | 


--------------------------------------------------------------------------------
/changelog.old.md:
--------------------------------------------------------------------------------
1 | # Archived Changelog
2 | 
3 | [TS] 062925-1542 | [MOD] units | [ACT] ^VAR | [TGT] scv.js, scv-mark-2.js | [VAL] Changed `buildSupplyDepot` hotkey from 'S' to 'U' to resolve WASD conflict. Added @tweakable to hotkey configurations. | [REF] src/units/scv.js, src/units/scv-mark-2.js
4 | [TS] 062925-1541 | [MOD] units | [ACT] ^FIX | [TGT] scv.js, scv-mark-2.js | [VAL] Remapped SCV and SCV Mark 2 hotkeys to resolve conflicts with WASD camera controls. Centralized keybinds into tweakable objects. | [REF] src/units/scv.js, src/units/scv-mark-2.js
5 | [TS] 062925-1540 | [MOD] docs | [ACT] ^FIX | [TGT] changelog.md | [VAL] Corrected all timestamps to reflect user's current time (15:40 Mountain Time). Added tweakable config for timestamp parsing to prevent future errors. | [REF] changelog.md, src/game/ui/ModalManager.js
6 | [TS] 062925-1539 | [MOD] docs | [ACT] ^FIX | [TGT] changelog.md | [VAL] Corrected timestamp on last entry to reflect user's current date. | [REF] changelog.md
7 | [TS] 062925-1538 | [MOD] docs | [ACT] MIGR | [TGT] changelog.md | [VAL] Archived all entries to changelog.old.md to start a fresh log. | [REF] changelog.md, changelog.old.md
8 | 


--------------------------------------------------------------------------------
/index.html:
--------------------------------------------------------------------------------
  1 | <html lang="en">
  2 | <head>
  3 |     <meta charset="UTF-8">
  4 |     <meta name="viewport" content="width=device-width, initial-scale=1.0">
  5 |     <title>StarCraft Clone v0.4.20</title>
  6 |     <link rel="stylesheet" href="assets/css/base.css">
  7 |     <link rel="stylesheet" href="assets/css/overlay.css">
  8 |     <link rel="stylesheet" href="assets/css/menu.css">
  9 |     <link rel="stylesheet" href="assets/css/modals.css">
 10 |     <style>
 11 |         #start-button:active, #options-button:active, #back-button:active, #changelog-button:active, #manual-button:active {
 12 |             transform: scale(0.98);
 13 |         }
 14 | 
 15 |         #start-button {
 16 |             animation: pulse 2s infinite;
 17 |         }
 18 | 
 19 |         #start-screen.hidden {
 20 |             display: none;
 21 |         }
 22 | 
 23 |         @keyframes pulse {
 24 |             0% {
 25 |                 box-shadow: 0 0 0 0 rgba(167, 209, 255, 0.7);
 26 |             }
 27 |             100% {
 28 |                 box-shadow: 0 0 0 10px rgba(167, 209, 255, 0);
 29 |             }
 30 |         }
 31 |     </style>
 32 | </head>
 33 | <body>
 34 |     <div id="global-message-container"></div>
 35 |     <div id="loading-overlay">
 36 |         <div id="loading-text">Loading...</div>
 37 |         <progress id="loading-progress-bar" max="100" value="0"></progress>
 38 |         <div id="credit-text">Built by Lord Tsarcasm</div>
 39 |     </div>
 40 |     <div id="game-container"></div>
 41 |     <div id="start-screen">
 42 |         <img src="assets/images/goliaths.png" id="promo-image-left" alt="Now with Goliaths!" loading="lazy">
 43 |         <img src="assets/images/siegetanks.png" id="promo-image-right" alt="Now with Siege Tanks!" loading="lazy">
 44 |         <div class="start-content-wrapper">
 45 |             <div id="main-menu">
 46 |                 <div id="start-button">Click to Start</div>
 47 |                 <div id="options-button">Options</div>
 48 |                 <div id="manual-button">Manual</div>
 49 |                 <div id="changelog-button">Changelog</div>
 50 |             </div>
 51 |         </div>
 52 |         <div id="options-menu" class="hidden">
 53 |             <h2>Options</h2>
 54 |             <div id="mobile-controls-toggle">
 55 |                 <input type="checkbox" id="enable-mobile-controls-checkbox">
 56 |                 <label for="enable-mobile-controls-checkbox">Enable Mobile Controls</label>
 57 |             </div>
 58 |             <div id="dev-mode-toggle">
 59 |                 <input type="checkbox" id="enable-dev-mode-checkbox">
 60 |                 <label for="enable-dev-mode-checkbox">Enable Dev Mode</label>
 61 |             </div>
 62 |             <div class="options-slider">
 63 |                 <label for="bgm-volume-slider">Music Volume</label>
 64 |                 <input type="range" id="bgm-volume-slider" min="0" max="1" step="0.01" value="0.3">
 65 |             </div>
 66 |             <div class="options-slider">
 67 |                 <label for="sfx-volume-slider">SFX Volume</label>
 68 |                 <input type="range" id="sfx-volume-slider" min="0" max="1" step="0.01" value="1.0">
 69 |             </div>
 70 |             <div id="archive-changelog-button">Archive Old Logs</div>
 71 |             <div id="back-button">Back</div>
 72 |         </div>
 73 |     </div>
 74 | 
 75 |     <div id="mobile-controls" class="hidden">
 76 |         <div id="joystick-zone"></div>
 77 |         <div id="action-buttons-zone">
 78 |             <button id="command-action-button">Cmd</button>
 79 |         </div>
 80 |         <div id="mobile-cursor"></div>
 81 |     </div>
 82 | 
 83 |     <div id="top-bar" class="panel">
 84 |         <div id="resources">
 85 |             <div class="resource-display">
 86 |                 <img src="assets/images/minerals_icon.png" class="resource-icon" alt="Minerals" loading="lazy">
 87 |                 <span id="mineral-count">500</span>
 88 |             </div>
 89 |             <div class="resource-display">
 90 |                 <img src="assets/images/vespene_icon.png" class="resource-icon" alt="Vespene" loading="lazy">
 91 |                 <span id="vespene-count">250</span>
 92 |             </div>
 93 |         </div>
 94 |         <div id="supply">
 95 |             <span id="supply-count">10/12</span>
 96 |         </div>
 97 |         <div id="compass">N</div>
 98 |     </div>
 99 | 
100 |     <div id="bottom-bar" class="panel">
101 |         <div id="minimap-panel" class="panel">
102 |             <div id="minimap"></div>
103 |         </div>
104 | 
105 |         <div id="unit-info-container">
106 |             <div id="unit-portrait-panel">
107 |                 <div id="portrait-box">
108 |                     <img id="portrait-img" src="" alt="Unit Portrait" loading="lazy">
109 |                     <div id="unit-count-overlay"></div>
110 |                 </div>
111 |                 <div id="unit-status">
112 |                      <div class="status-bar-container shield-bar-container" style="display: none;">
113 |                         <div class="status-bar shield-bar"><div id="shield-bar-fill"></div></div>
114 |                         <div id="unit-shield-text"></div>
115 |                     </div>
116 |                     <div class="status-bar-container">
117 |                         <div class="status-bar health-bar"><div id="health-bar-fill"></div></div>
118 |                         <div id="unit-health-text"></div>
119 |                     </div>
120 |                      <div class="status-bar-container energy-bar-container" style="display: none;">
121 |                         <div class="status-bar energy-bar"><div id="energy-bar-fill"></div></div>
122 |                         <div id="unit-energy-text"></div>
123 |                     </div>
124 |                 </div>
125 |                 <div id="unit-name" class="panel-text">Unit Name</div>
126 |             </div>
127 | 
128 |             <div id="command-card-panel" class="panel">
129 |                 <div id="build-queue-display" class="panel"></div>
130 |                 <div class="command-grid">
131 |                     <!-- Buttons will be generated by JS -->
132 |                 </div>
133 |             </div>
134 | 
135 |             <div id="video-panel" class="panel">
136 |                 <!-- Video will be inserted here by JS -->
137 |             </div>
138 |         </div>
139 | 
140 |         <div id="status-text-panel-container">
141 |             <div id="status-text-panel" class="panel">
142 |                  <div id="placement-text-panel" class="placement-text"></div>
143 |                  <!-- Status messages will go here -->
144 |             </div>
145 |         </div>
146 |     </div>
147 | 
148 |     <div id="selection-box"></div>
149 |     <div id="tooltip" class="panel" style="pointer-events: none;"></div>
150 | 
151 |     <div id="ingame-options-overlay" class="hidden">
152 |         <div id="ingame-options-menu">
153 |             <h2>Game Paused</h2>
154 |             <div class="options-slider">
155 |                 <label for="ingame-bgm-volume-slider">Music Volume</label>
156 |                 <input type="range" id="ingame-bgm-volume-slider" min="0" max="1" step="0.01" value="0.3">
157 |             </div>
158 |             <div class="options-slider">
159 |                 <label for="ingame-sfx-volume-slider">SFX Volume</label>
160 |                 <input type="range" id="ingame-sfx-volume-slider" min="0" max="1" step="0.01" value="1.0">
161 |             </div>
162 |             <div class="menu-button" id="toggle-grid-button">Toggle Grid</div>
163 |             <div id="resume-button" class="menu-button">Resume</div>
164 |             <div id="quit-button" class="menu-button">Quit to Main Menu</div>
165 |         </div>
166 |     </div>
167 | 
168 |     <div id="dev-log-modal" class="hidden">
169 |         <div class="dev-log-content">
170 |             <button id="close-dev-log-modal" class="close-button">&times;</button>
171 |             <button id="clear-dev-log-button">Clear Log</button>
172 |             <h2>Developer Log</h2>
173 |             <pre id="dev-log-output"></pre>
174 |         </div>
175 |     </div>
176 | 
177 |     <div id="grid-labels-container"></div>
178 | 
179 |     <div id="manual-modal" class="hidden">
180 |         <div class="manual-content">
181 |             <button id="close-manual-modal" class="close-button">&times;</button>
182 |             <div class="manual-tabs">
183 |                 <button id="manual-tab-button" class="manual-tab active">Manual</button>
184 |                 <button id="assets-tab-button" class="manual-tab">Assets</button>
185 |             </div>
186 |             <div id="manual-tab-content" class="manual-tab-pane active">
187 |                 <pre id="manual-output">Loading...</pre>
188 |             </div>
189 |             <div id="assets-tab-content" class="manual-tab-pane">
190 |                  <div id="asset-list-container">
191 |                     <h3 id="asset-list-title">Generated Assets</h3>
192 |                     <div id="asset-list">Loading...</div>
193 |                 </div>
194 |             </div>
195 |         </div>
196 |     </div>
197 | 
198 |     <div id="changelog-modal" class="hidden">
199 |         <div class="changelog-content">
200 |             <button id="close-changelog-modal" class="close-button">&times;</button>
201 |             <h2>Changelog</h2>
202 |             <div class="changelog-tabs">
203 |                 <button id="recent-changelog-tab-button" class="changelog-tab active">Recent</button>
204 |                 <button id="old-changelog-tab-button" class="changelog-tab">Archive</button>
205 |             </div>
206 |             <div id="recent-changelog-tab-content" class="changelog-tab-pane active">
207 |                 <pre id="recent-changelog-output" class="changelog-output">Loading...</pre>
208 |             </div>
209 |             <div id="old-changelog-tab-content" class="changelog-tab-pane">
210 |                  <pre id="old-changelog-output" class="changelog-output">Loading...</pre>
211 |             </div>
212 |         </div>
213 |     </div>
214 | 
215 |     <div id="promo-modal" class="hidden">
216 |         <div class="promo-content">
217 |             <button id="close-promo-modal" class="close-button">&times;</button>
218 |             <iframe id="promo-video" width="560" height="315"
219 |                 src="https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1"
220 |                 title="Promotional Video" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
221 |         </div>
222 |     </div>
223 | 
224 |     <script type="importmap">
225 |     {
226 |         "imports": {
227 |             "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
228 |             "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
229 |             "fflate": "https://unpkg.com/fflate@0.8.2/esm/browser.js"
230 |         }
231 |     }
232 |     </script>
233 |     <script type="module" src="scripts/changelog-archive.js"></script>
234 |     <script type="module" src="src/game/index.js"></script>
235 | </body>
236 | </html>


--------------------------------------------------------------------------------
/manual.md:
--------------------------------------------------------------------------------
 1 | # Game Manual
 2 | 
 3 | Welcome to WebSim! This manual provides an overview of gameplay, controls, units, and structures to help you get started.
 4 | 
 5 | ## 1. Basic Controls
 6 | 
 7 | Mastering the controls is the first step to victory.
 8 | 
 9 | *   **Camera Pan**: Use the **W, A, S, D** keys or the **Arrow Keys**. You can also pan by holding the **Middle Mouse Button** and dragging.
10 | *   **Camera Rotation**: Use the **Q** and **E** keys to rotate the camera left and right.
11 | *   **Camera Zoom**: Use the **Mouse Wheel** to zoom in and out.
12 | *   **Select Unit/Building**: **Left-Click** on a unit or building.
13 | *   **Select Multiple Units**: **Left-Click and Drag** to create a selection box.
14 | *   **Issue Command**: **Right-Click** on a location or target to issue a context-sensitive command (move, attack, gather, repair) to your selected units.
15 | *   **Pause Menu**: Press the **Backquote** (`) key during a game to pause and access the in-game menu.
16 | 
17 | ## 2. Gameplay Fundamentals
18 | 
19 | Your primary goal is to manage resources, build a base, train an army, and overwhelm your opponent.
20 | 
21 | ### Resources
22 | 
23 | There are two primary resources:
24 | 
25 | *   **Minerals** (Blue Crystals): Harvested by SCVs from Mineral Fields. Used for constructing most buildings and training basic units.
26 | *   **Vespene Gas** (Green Geyser): Harvested by SCVs from a Refinery built on top of a Vespene Geyser. Required for advanced units, buildings, and upgrades.
27 | 
28 | ### Supply
29 | 
30 | Every unit you train consumes supply. You must build **Supply Depots** to increase your supply capacity. If you reach your supply cap, you cannot train more units. Keep an eye on the supply count in the top-right corner of the screen.
31 | 
32 | ### Technology Tree (Teching)
33 | 
34 | To access more powerful units and upgrades, you must construct specific buildings. This is known as "teching up". For example, to train a Medic, you must first have a Barracks and an Academy.
35 | 
36 | ## 3. Structures
37 | 
38 | Your base is the heart of your operation.
39 | 
40 | *   **Command Center**: Your primary headquarters.
41 |     *   Trains **SCVs**.
42 |     *   Acts as a drop-off point for resources.
43 |     *   Can be upgraded with addons: **Comsat Station** (reveals map areas) or **Nuclear Silo** (enables nuclear strikes).
44 |     *   Can lift off and fly to a new location.
45 | *   **Supply Depot**: Increases your supply capacity by 8. Can be lowered to allow your ground units to pass over it.
46 | *   **Refinery**: Must be built on a Vespene Geyser to enable gas collection.
47 | *   **Barracks**: Trains ground infantry.
48 |     *   **Marine**: Basic ranged infantry.
49 |     *   **Firebat**: Short-range infantry, effective against light units. (Requires Academy)
50 |     *   **Medic**: Healer unit that can restore health to biological units. (Requires Academy)
51 | *   **Engineering Bay**: Researches weapon and armor upgrades for infantry units.
52 | *   **Academy**: Unlocks advanced infantry and researches abilities like Stim Packs.
53 | *   **Bunker**: A defensive structure that infantry can enter for protection. Garrisoned units can fire from inside.
54 | *   **Missile Turret**: A static anti-air defensive structure.
55 | *   **Factory**: Builds ground vehicles.
56 |     *   **Vulture**: Fast hover-bike for scouting and harassment.
57 |     *   **Siege Tank**: Can switch to a stationary Siege Mode for long-range, high-damage attacks.
58 |     *   **Goliath**: A walking mech effective against both ground and air targets.
59 | *   **Armory**: Researches weapon and armor upgrades for all vehicles and starships.
60 | *   **Starport**: Builds powerful air units. Can be upgraded with a **Control Tower** addon to unlock advanced ships.
61 |     *   **Wraith**: Fast air-superiority fighter.
62 |     *   **Dropship**: Transports ground units across the map.
63 |     *   **Science Vessel**: A detector and support caster with powerful abilities.
64 |     *   **Battlecruiser**: The ultimate capital ship, equipped with the devastating Yamato Cannon.
65 | *   **Science Facility**: A high-tier tech building. Can be upgraded with a **Physics Lab** or **Covert Ops** addon to unlock the most powerful technologies and units.
66 | 
67 | ## 4. Hotkeys
68 | Many actions have hotkeys for faster execution. Hover your mouse over a command button in the bottom-right panel to see its name, cost, and hotkey. Learning hotkeys is crucial for efficient play.
69 | 
70 | Press the **/** key at any time to watch the promotional video.
71 | 
72 | 


--------------------------------------------------------------------------------
/package.json:
--------------------------------------------------------------------------------
1 | {
2 |   "name": "starcraft-rts-prototype",
3 |   "version": "1.0.0",
4 |   "description": "Browser-based RTS prototype",
5 |   "type": "module",
6 |   "dependencies": {}
7 | }
8 | 


--------------------------------------------------------------------------------
/scripts/changelog-archive.js:
--------------------------------------------------------------------------------
 1 | 
 2 | async function archiveChangelog() {
 3 |   const lastRun = localStorage.getItem('lastChangelogArchive');
 4 |   const dayMs = 24 * 60 * 60 * 1000;
 5 |   if (lastRun && Date.now() - Number(lastRun) < dayMs) {
 6 |     return; // Already ran within the last day
 7 |   }
 8 | 
 9 |   try {
10 |     const [recentResp, oldResp] = await Promise.all([
11 |       fetch('changelog.md'),
12 |       fetch('changelog.old.md')
13 |     ]);
14 | 
15 |     if (!recentResp.ok) {
16 |       console.warn('Could not load changelog.md');
17 |       return;
18 |     }
19 | 
20 |     const recentText = await recentResp.text();
21 |     const oldText = oldResp.ok ? await oldResp.text() : '';
22 | 
23 |     const lines = recentText.split('\n');
24 | 
25 |     const today = new Date();
26 |     today.setHours(0, 0, 0, 0);
27 | 
28 |     const tsRegex = /\[TS] (\d{2})(\d{2})(\d{2})-\d{4}/;
29 | 
30 |     const keep = [];
31 |     const archive = [];
32 | 
33 |     for (const line of lines) {
34 |       const m = line.match(tsRegex);
35 |       if (m) {
36 |         const entryDate = new Date(2000 + parseInt(m[3], 10), parseInt(m[1], 10) - 1, parseInt(m[2], 10));
37 |         if (entryDate < today) {
38 |           archive.push(line);
39 |         } else {
40 |           keep.push(line);
41 |         }
42 |       } else {
43 |         keep.push(line);
44 |       }
45 |     }
46 | 
47 |     if (archive.length === 0) {
48 |       localStorage.setItem('lastChangelogArchive', Date.now().toString());
49 |       return;
50 |     }
51 | 
52 |     const updatedRecent = keep.join('\n');
53 |     const updatedOld = archive.join('\n') + '\n' + oldText;
54 | 
55 |     // Attempt to send updated files to server (requires server-side implementation)
56 |     await fetch('api/archive-changelog', {
57 |       method: 'POST',
58 |       headers: { 'Content-Type': 'application/json' },
59 |       body: JSON.stringify({ recent: updatedRecent, old: updatedOld })
60 |     }).catch(err => console.warn('Archive request failed', err));
61 |   } catch (err) {
62 |     console.error('Failed to archive changelog', err);
63 |   } finally {
64 |     localStorage.setItem('lastChangelogArchive', Date.now().toString());
65 |   }
66 | }
67 | 
68 | window.addEventListener('DOMContentLoaded', archiveChangelog);
69 | 


--------------------------------------------------------------------------------
/src/buildings/academy.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /** @tweakable Hotkeys for Academy research commands */
  4 | const academyHotkeys = {
  5 |     stimpack: 'T',
  6 |     u238shells: 'U',
  7 | };
  8 | 
  9 | export class Academy {
 10 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4 } = {}) {
 11 |         this.name = 'Academy';
 12 |         this.portraitUrl = 'assets/images/academy_portrait.png';
 13 |         this.maxHealth = 600;
 14 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 15 |         this.selected = false;
 16 |         this.isUnderConstruction = isUnderConstruction;
 17 |         this.buildTime = buildTime;
 18 | 
 19 |         this._commands = [];
 20 |         this.buildQueue = []; // Used for research progress
 21 | 
 22 |         this.mesh = this.createMesh();
 23 |         this.mesh.position.copy(position);
 24 | 
 25 |         this.mesh.traverse((child) => {
 26 |             if (child.isMesh) {
 27 |                 child.castShadow = true;
 28 |                 child.receiveShadow = true;
 29 |                 child.userData.owner = this;
 30 |             }
 31 |         });
 32 | 
 33 |         if (this.isUnderConstruction) {
 34 |             this.mesh.scale.y = 0.01;
 35 |             this.mesh.traverse(child => {
 36 |                 if (child.isMesh) {
 37 |                     child.material = child.material.clone();
 38 |                     child.material.transparent = true;
 39 |                     child.material.opacity = 0.5;
 40 |                 }
 41 |             });
 42 |         }
 43 | 
 44 |         const selectionGeometry = new THREE.RingGeometry(3.5, 3.7, 64);
 45 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 46 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 47 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 48 |         this.selectionIndicator.position.y = 0.01;
 49 |         this.selectionIndicator.visible = false;
 50 |         this.mesh.add(this.selectionIndicator);
 51 |         
 52 |         const buildingWidth = 6;
 53 |         const buildingDepth = 6;
 54 |         const buildingHeight = 4;
 55 |         this.collider = new THREE.Box3(
 56 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 57 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 58 |         );
 59 |         this.collider.translate(this.mesh.position);
 60 |     }
 61 |     
 62 |     get commands() {
 63 |         return this._commands;
 64 |     }
 65 |     set commands(newCommands) {
 66 |         this._commands = newCommands;
 67 |     }
 68 | 
 69 |     createMesh() {
 70 |         const group = new THREE.Group();
 71 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 72 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 73 |         const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x607080, metalness: 0.7, roughness: 0.6 });
 74 | 
 75 |         const baseGeo = new THREE.BoxGeometry(6, 2, 6);
 76 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 77 |         base.position.y = 1;
 78 |         group.add(base);
 79 | 
 80 |         const upperGeo = new THREE.BoxGeometry(4.5, 1, 4.5);
 81 |         const upper = new THREE.Mesh(upperGeo, accentMaterial);
 82 |         upper.position.y = 2.5;
 83 |         group.add(upper);
 84 |         
 85 |         const roofShape = new THREE.Shape();
 86 |         roofShape.moveTo(-2, 0);
 87 |         roofShape.lineTo(2, 0);
 88 |         roofShape.lineTo(0, 1);
 89 |         const extrudeSettings = { depth: 4, bevelEnabled: false };
 90 |         const roofGeo = new THREE.ExtrudeGeometry(roofShape, extrudeSettings);
 91 |         const roof = new THREE.Mesh(roofGeo, roofMaterial);
 92 |         roof.rotation.y = Math.PI / 2;
 93 |         roof.position.set(-2, 3, 0);
 94 |         group.add(roof);
 95 | 
 96 |         return group;
 97 |     }
 98 |     
 99 |     updateCommands(gameState) {
100 |         if (this.isUnderConstruction || this.buildQueue.length > 0) {
101 |             return;
102 |         }
103 | 
104 |         const newCommands = new Array(12).fill(null);
105 |         
106 |         if (!gameState.upgrades.stimpack) {
107 |             newCommands[0] = {
108 |                 command: 'research_stimpack',
109 |                 hotkey: academyHotkeys.stimpack,
110 |                 icon: 'assets/images/stim_pack_icon.png',
111 |                 name: 'Research Stim Packs',
112 |                 cost: { minerals: 100, vespene: 100 },
113 |                 researchTime: 50.4
114 |             };
115 |         }
116 |         
117 |         if (!gameState.upgrades.u238shells) {
118 |             newCommands[1] = {
119 |                 command: 'research_u238shells',
120 |                 hotkey: academyHotkeys.u238shells,
121 |                 icon: 'assets/images/u238_shells_icon.png',
122 |                 name: 'Research U-238 Shells',
123 |                 cost: { minerals: 150, vespene: 150 },
124 |                 researchTime: 66.7
125 |             };
126 |         }
127 | 
128 |         this.commands = newCommands;
129 |     }
130 | 
131 |     onConstructionComplete(gameState) {
132 |         this.isUnderConstruction = false;
133 |         this.currentHealth = this.maxHealth;
134 |         gameState.academyBuilt = true;
135 | 
136 |         this.mesh.scale.y = 1.0;
137 |         
138 |         this.mesh.traverse(child => {
139 |             if (child.isMesh && child.material.transparent === true) {
140 |                 child.material.opacity = 1.0;
141 |                 child.material.transparent = false;
142 |             }
143 |         });
144 |         
145 |         this.updateCommands(gameState);
146 |     }
147 | 
148 |     getCollider() { return this.collider; }
149 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
150 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
151 |     
152 |     executeCommand(commandName, gameState, statusCallback) {
153 |         const command = this.commands.find(c => c && c.command === commandName);
154 |         if (!command) return;
155 | 
156 |         if (commandName.startsWith('research_')) {
157 |             if (this.buildQueue.length > 0) {
158 |                 statusCallback("Already researching.");
159 |                 return;
160 |             }
161 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
162 |                 statusCallback("Not enough resources.");
163 |                 return;
164 |             }
165 | 
166 |             gameState.minerals -= command.cost.minerals;
167 |             if(command.cost.vespene) gameState.vespene -= command.cost.vespene;
168 | 
169 |             this.buildQueue.push({
170 |                 type: command.name,
171 |                 buildTime: command.researchTime,
172 |                 progress: 0,
173 |                 originalCommand: commandName,
174 |             });
175 | 
176 |             statusCallback(`Researching ${command.name}...`);
177 |         }
178 |     }
179 |     
180 |     update(delta, gameState) {
181 |         if (this.isUnderConstruction) {
182 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
183 |             this.mesh.scale.y = buildProgress;
184 |             return;
185 |         }
186 | 
187 |         if (this.buildQueue.length > 0) {
188 |             const research = this.buildQueue[0];
189 |             research.progress += delta;
190 | 
191 |             if (research.progress >= research.buildTime) {
192 |                 const finished = this.buildQueue.shift();
193 |                 if (finished.originalCommand.includes('stimpack')) {
194 |                     gameState.upgrades.stimpack = true;
195 |                 } else if (finished.originalCommand.includes('u238shells')) {
196 |                     gameState.upgrades.u238shells = true;
197 |                 }
198 |                 this.updateCommands(gameState); // Update commands after research finishes
199 |             }
200 |         }
201 | 
202 |         // To prevent constant re-evaluation, only update commands if not building/researching.
203 |         if (this.buildQueue.length === 0) {
204 |              this.updateCommands(gameState);
205 |         }
206 |     }
207 | }


--------------------------------------------------------------------------------
/src/buildings/addon-behavior.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { SCVMark2 } from '../units/scv-mark-2.js';
  3 | 
  4 | export class AddonBehavior {
  5 |     constructor(parentBuilding) {
  6 |         this.parentBuilding = parentBuilding;
  7 | 
  8 |         this.addon = null;
  9 |         this.cachedCommands = [];
 10 |     }
 11 |     
 12 |     isBuilding() {
 13 |         return this.parentBuilding.buildQueue?.some(item => item.isAddon);
 14 |     }
 15 | 
 16 |     getCommands() {
 17 |         if (this.isBuilding()) {
 18 |             const commandList = new Array(12).fill(null);
 19 |             const addonJob = this.parentBuilding.buildQueue.find(item => item.isAddon);
 20 |             if (addonJob) {
 21 |                 // Find the original command definition from the cached commands
 22 |                 const commandDef = this.cachedCommands.find(c => c && c.command === addonJob.originalCommand);
 23 |                 if (commandDef) {
 24 |                     // Place it in the correct slot so the UI can find it.
 25 |                     const cmdIndex = this.cachedCommands.indexOf(commandDef);
 26 |                     if (cmdIndex !== -1) {
 27 |                         commandList[cmdIndex] = commandDef;
 28 |                     }
 29 |                 }
 30 |             }
 31 |             return commandList;
 32 |         }
 33 |         
 34 |         if (this.parentBuilding.state === 'grounded') {
 35 |             if (this.addon) {
 36 |                  return this.addon.commands;
 37 |             } else {
 38 |                  return this.cachedCommands;
 39 |             }
 40 |         }
 41 |         
 42 |         return [];
 43 |     }
 44 | 
 45 |     updateCommands(gameState) {
 46 |         if (this.parentBuilding.isUnderConstruction || this.isBuilding() || this.addon) {
 47 |             this.cachedCommands = [];
 48 |             return;
 49 |         }
 50 | 
 51 |         const newCommands = new Array(12).fill(null);
 52 | 
 53 |         if (this.parentBuilding.name === 'Command Center') {
 54 |             newCommands[2] = {
 55 |                 command: 'build_comsat_station',
 56 |                 hotkey: 'C',
 57 |                 icon: 'assets/images/build_comsat_station_icon.png',
 58 |                 name: 'Build Comsat Station',
 59 |                 cost: { minerals: 50, vespene: 50 },
 60 |                 buildTime: 25.2,
 61 |                 prereq: 'academyBuilt',
 62 |                 isAddon: true
 63 |             };
 64 |             newCommands[3] = {
 65 |                 command: 'build_nuclear_silo',
 66 |                 hotkey: 'N',
 67 |                 icon: 'assets/images/build_nuclear_silo_icon.png',
 68 |                 name: 'Build Nuclear Silo',
 69 |                 cost: { minerals: 100, vespene: 100 },
 70 |                 buildTime: 50.4,
 71 |                 prereq: 'scienceFacilityBuilt',
 72 |                 isAddon: true
 73 |             };
 74 |         } else if (this.parentBuilding.name === 'Science Facility') {
 75 |             newCommands[2] = {
 76 |                 command: 'build_physics_lab',
 77 |                 hotkey: 'P',
 78 |                 icon: 'assets/images/build_physics_lab_icon.png',
 79 |                 name: 'Build Physics Lab',
 80 |                 cost: { minerals: 100, vespene: 50 },
 81 |                 buildTime: 50.4,
 82 |                 prereq: 'scienceFacilityBuilt', // It requires itself, effectively.
 83 |                 isAddon: true
 84 |             };
 85 |             // Could add Covert Ops here later
 86 |             // newCommands[3] = { ... }
 87 |         } else if (this.parentBuilding.name === 'Starport') {
 88 |             newCommands[6] = {
 89 |                 command: 'build_control_tower',
 90 |                 hotkey: 'C',
 91 |                 icon: 'assets/images/build_control_tower_icon.png',
 92 |                 name: 'Build Control Tower',
 93 |                 cost: { minerals: 50, vespene: 50 },
 94 |                 buildTime: 30,
 95 |                 isAddon: true
 96 |             };
 97 |         }
 98 | 
 99 |         this.cachedCommands = newCommands;
100 |     }
101 | 
102 |     executeCommand(commandName, gameState, statusCallback) {
103 |         // Let the addon try to execute the command first.
104 |         if (this.addon && typeof this.addon.executeCommand === 'function') {
105 |             const handled = this.addon.executeCommand(commandName, gameState, statusCallback);
106 |             // If the addon handled it, we're done.
107 |             if (handled) {
108 |                 return true;
109 |             }
110 |         }
111 | 
112 |         const command = this.cachedCommands.find(c => c && c.command === commandName);
113 |         if (!command || !command.isAddon) return false;
114 |         
115 |         if (command.prereq && !gameState[command.prereq]) {
116 |             let prereqName = command.prereq.replace(/([A-Z])/g, ' $1').replace('Built', '').trim();
117 |             prereqName = prereqName.charAt(0).toUpperCase() + prereqName.slice(1);
118 |             statusCallback(`Requires ${prereqName}.`);
119 |             return true;
120 |         }
121 | 
122 |         if (this.addon) {
123 |             statusCallback("Addon already built.");
124 |             return true;
125 |         }
126 |         if (this.isBuilding()) {
127 |             statusCallback("Addon already in progress.");
128 |             return true;
129 |         }
130 |         if (this.parentBuilding.buildQueue?.length >= 5) {
131 |             statusCallback("Build queue is full.");
132 |             return true;
133 |         }
134 |         if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
135 |             statusCallback("Not enough resources.");
136 |             return true;
137 |         }
138 | 
139 |         gameState.minerals -= command.cost.minerals;
140 |         if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
141 | 
142 |         if (this.parentBuilding.buildQueue) {
143 |             this.parentBuilding.buildQueue.push({
144 |                 type: command.name.replace('Build ', ''),
145 |                 buildTime: command.buildTime,
146 |                 progress: 0,
147 |                 originalCommand: commandName,
148 |                 isAddon: true,
149 |             });
150 |             statusCallback(`Constructing ${command.name.replace('Build ', '')}...`);
151 | 
152 |             // Find a nearby SCV Mark 2 to "build" the addon
153 |             const nearbyBuilder = gameState.units.find(u => 
154 |                 u instanceof SCVMark2 && 
155 |                 u.state === 'idle' &&
156 |                 u.mesh.position.distanceTo(this.parentBuilding.mesh.position) < 20
157 |             );
158 | 
159 |             if (nearbyBuilder) {
160 |                 const parentSize = this.parentBuilding.groundCollider.getSize(new THREE.Vector3());
161 |                 const addonWidth = (command.name.includes('Physics Lab') || command.name.includes('Control Tower')) ? 4 : 5;
162 |                 const addonOffset = new THREE.Vector3(parentSize.x / 2 + addonWidth / 2, 0, 0);
163 |                 const addonPosition = this.parentBuilding.mesh.position.clone().add(addonOffset);
164 |                 
165 |                 // Set a fake building target for the SCV to move to and play its build animation.
166 |                 // The actual addon spawning is handled by the parent building's update loop.
167 |                 const fakeBuildTarget = {
168 |                     mesh: { position: addonPosition },
169 |                     getCollider: () => new THREE.Box3().setFromCenterAndSize(addonPosition, new THREE.Vector3(addonWidth, 5, addonWidth)),
170 |                 };
171 | 
172 |                 if (nearbyBuilder.build) {
173 |                     // We don't want the SCV to actually increment health, so we'll just send it to move.
174 |                     // The 'build' method handles moving to the site. We create a simplified target.
175 |                      const targetPos = addonPosition.clone().sub(new THREE.Vector3(addonWidth / 2 + 1.5, 0, 0));
176 |                      const pathfinder = window.pathfinder; // Access global pathfinder if available
177 |                      if(pathfinder) {
178 |                         const path = pathfinder.findPath(nearbyBuilder.mesh.position, targetPos);
179 |                         nearbyBuilder.setPath(path);
180 |                      }
181 |                 }
182 |             }
183 |         }
184 |         
185 |         // This behavior handled the command (by starting the build).
186 |         return true;
187 |     }
188 | 
189 |     update(delta, gameState) {
190 |         // Construction logic is now handled by the parent building.
191 |         // This update method is only for the *existing* addon's logic.
192 |         if (this.addon && this.addon.update) {
193 |             this.addon.update(delta, gameState);
194 |         }
195 |     }
196 | 
197 |     completeAddonConstruction(addonInfo, spawnBuildingCallback, gameState) {
198 |         const parentSize = this.parentBuilding.groundCollider.getSize(new THREE.Vector3());
199 |         let addonWidth = 5; // default
200 |         if (addonInfo.type === 'Physics Lab' || addonInfo.type === 'Control Tower') addonWidth = 4;
201 | 
202 |         const addonOffset = new THREE.Vector3(parentSize.x / 2 + addonWidth / 2, 0, 0);
203 |         const addonPosition = this.parentBuilding.mesh.position.clone().add(addonOffset);
204 | 
205 |         const newAddon = spawnBuildingCallback(addonInfo.type, addonPosition, {
206 |             isUnderConstruction: false,
207 |             buildTime: addonInfo.buildTime,
208 |             parent: this.parentBuilding,
209 |         });
210 | 
211 |         this.addon = newAddon;
212 |         
213 |         // Update parent's state flags
214 |         if (addonInfo.type === 'Physics Lab') {
215 |             gameState.physicsLabBuilt = true;
216 |         } else if (addonInfo.type === 'Covert Ops') {
217 |             gameState.covertOpsBuilt = true;
218 |         } else if (addonInfo.type === 'Control Tower') {
219 |             gameState.controlTowerBuilt = true;
220 |         } else if (addonInfo.type === 'Comsat Station') {
221 |             gameState.comsatStationBuilt = true;
222 |         } else if (addonInfo.type === 'Nuclear Silo') {
223 |             gameState.nuclearSiloBuilt = true;
224 |         }
225 | 
226 |         // Parent might need to update its commands now that the addon is done
227 |         if(this.parentBuilding.updateCommands) {
228 |             this.parentBuilding.updateCommands(gameState);
229 |         }
230 |         
231 |         // Also need to update the addon's own cached commands
232 |         this.updateCommands(gameState);
233 |     }
234 | }


--------------------------------------------------------------------------------
/src/buildings/armory.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /** @tweakable Hotkeys for Armory research commands */
  4 | const armoryHotkeys = {
  5 |     researchCharonBoosters: 'C',
  6 |     researchVehicleWeapons: 'V',
  7 |     researchVehicleArmor: 'E',
  8 |     researchShipWeapons: 'I',
  9 |     researchShipArmor: 'R',
 10 | };
 11 | 
 12 | export class Armory {
 13 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4 } = {}) {
 14 |         this.name = 'Armory';
 15 |         this.portraitUrl = 'assets/images/armory_portrait.png';
 16 |         this.maxHealth = 750;
 17 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 18 |         this.selected = false;
 19 |         this.isUnderConstruction = isUnderConstruction;
 20 |         this.buildTime = buildTime;
 21 |         this.state = 'grounded';
 22 | 
 23 |         this._commands = [];
 24 |         this.buildQueue = []; // For research
 25 | 
 26 |         this.mesh = this.createMesh();
 27 |         this.mesh.position.copy(position);
 28 | 
 29 |         this.mesh.traverse((child) => {
 30 |             if (child.isMesh) {
 31 |                 child.castShadow = true;
 32 |                 child.receiveShadow = true;
 33 |                 child.userData.owner = this;
 34 |             }
 35 |         });
 36 | 
 37 |         if (this.isUnderConstruction) {
 38 |             this.mesh.scale.y = 0.01;
 39 |             this.mesh.traverse(child => {
 40 |                 if (child.isMesh) {
 41 |                     child.material = child.material.clone();
 42 |                     child.material.transparent = true;
 43 |                     child.material.opacity = 0.5;
 44 |                 }
 45 |             });
 46 |         }
 47 | 
 48 |         const selectionGeometry = new THREE.RingGeometry(3.5, 3.7, 64);
 49 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 50 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 51 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 52 |         this.selectionIndicator.position.y = 0.01;
 53 |         this.selectionIndicator.visible = false;
 54 |         this.mesh.add(this.selectionIndicator);
 55 |         
 56 |         const buildingWidth = 6;
 57 |         const buildingDepth = 6;
 58 |         const buildingHeight = 5;
 59 |         this.collider = new THREE.Box3(
 60 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 61 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 62 |         );
 63 |         this.collider.translate(this.mesh.position);
 64 |     }
 65 |     
 66 |     get commands() {
 67 |         return this._commands;
 68 |     }
 69 |     set commands(newCommands) {
 70 |         this._commands = newCommands;
 71 |     }
 72 | 
 73 |     createMesh() {
 74 |         const group = new THREE.Group();
 75 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 76 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 77 |         
 78 |         const baseGeo = new THREE.BoxGeometry(6, 3, 6);
 79 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 80 |         base.position.y = 1.5;
 81 |         group.add(base);
 82 | 
 83 |         const garageDoorGeo = new THREE.BoxGeometry(3, 2, 0.2);
 84 |         const garageDoor = new THREE.Mesh(garageDoorGeo, accentMaterial);
 85 |         garageDoor.position.set(0, 1, 3.05);
 86 |         group.add(garageDoor);
 87 | 
 88 |         const roofGeo = new THREE.BoxGeometry(6.2, 0.5, 6.2);
 89 |         const roof = new THREE.Mesh(roofGeo, accentMaterial);
 90 |         roof.position.y = 3.25;
 91 |         group.add(roof);
 92 | 
 93 |         return group;
 94 |     }
 95 |     
 96 |     updateCommands(gameState) {
 97 |         if (this.isUnderConstruction || this.buildQueue.length > 0) {
 98 |             this.commands = [];
 99 |             return;
100 |         }
101 | 
102 |         const newCommands = new Array(12).fill(null);
103 |         
104 |         if (!gameState.upgrades.charonBoosters) {
105 |             newCommands[0] = {
106 |                 command: 'research_charon_boosters',
107 |                 hotkey: armoryHotkeys.researchCharonBoosters,
108 |                 icon: 'assets/images/charon_boosters_icon.png',
109 |                 name: 'Charon Boosters',
110 |                 cost: { minerals: 100, vespene: 100 },
111 |                 researchTime: 80
112 |             };
113 |         }
114 |         
115 |         const vehicleWeaponLevel = gameState.upgrades.vehicleWeapons;
116 |         const vehicleArmorLevel = gameState.upgrades.vehicleArmor;
117 |         const shipWeaponLevel = gameState.upgrades.shipWeapons;
118 |         const shipArmorLevel = gameState.upgrades.shipArmor;
119 | 
120 |         if (vehicleWeaponLevel < 3) {
121 |             newCommands[1] = {
122 |                 command: `research_vehicle_weapons_${vehicleWeaponLevel + 1}`,
123 |                 hotkey: armoryHotkeys.researchVehicleWeapons,
124 |                 icon: 'assets/images/upgrade_infantry_weapons_icon.png',
125 |                 name: `Upgrade Vehicle Weapons (Lvl ${vehicleWeaponLevel + 1})`,
126 |                 cost: { minerals: 100 * (vehicleWeaponLevel + 1), vespene: 100 * (vehicleWeaponLevel + 1) },
127 |                 researchTime: 167
128 |             };
129 |         }
130 | 
131 |         if (vehicleArmorLevel < 3) {
132 |             newCommands[2] = {
133 |                 command: `research_vehicle_armor_${vehicleArmorLevel + 1}`,
134 |                 hotkey: armoryHotkeys.researchVehicleArmor,
135 |                 icon: 'assets/images/upgrade_infantry_armor_icon.png',
136 |                 name: `Upgrade Vehicle Armor (Lvl ${vehicleArmorLevel + 1})`,
137 |                 cost: { minerals: 100 * (vehicleArmorLevel + 1), vespene: 100 * (vehicleArmorLevel + 1) },
138 |                 researchTime: 167
139 |             };
140 |         }
141 | 
142 |         if (shipWeaponLevel < 3) {
143 |             newCommands[3] = {
144 |                 command: `research_ship_weapons_${shipWeaponLevel + 1}`,
145 |                 hotkey: armoryHotkeys.researchShipWeapons,
146 |                 icon: 'assets/images/upgrade_infantry_weapons_icon.png',
147 |                 name: `Upgrade Ship Weapons (Lvl ${shipWeaponLevel + 1})`,
148 |                 cost: { minerals: 100 * (shipWeaponLevel + 1), vespene: 100 * (shipWeaponLevel + 1) },
149 |                 researchTime: 167
150 |             };
151 |         }
152 | 
153 |         if (shipArmorLevel < 3) {
154 |             newCommands[4] = {
155 |                 command: `research_ship_armor_${shipArmorLevel + 1}`,
156 |                 hotkey: armoryHotkeys.researchShipArmor,
157 |                 icon: 'assets/images/upgrade_infantry_armor_icon.png',
158 |                 name: `Upgrade Ship Armor (Lvl ${shipArmorLevel + 1})`,
159 |                 cost: { minerals: 100 * (shipArmorLevel + 1), vespene: 100 * (shipArmorLevel + 1) },
160 |                 researchTime: 167
161 |             };
162 |         }
163 | 
164 |         this.commands = newCommands;
165 |     }
166 | 
167 |     onConstructionComplete(gameState) {
168 |         this.isUnderConstruction = false;
169 |         this.currentHealth = this.maxHealth;
170 |         gameState.armoryBuilt = true;
171 | 
172 |         this.mesh.scale.y = 1.0;
173 |         
174 |         this.mesh.traverse(child => {
175 |             if (child.isMesh && child.material.transparent === true) {
176 |                 child.material.opacity = 1.0;
177 |                 child.material.transparent = false;
178 |             }
179 |         });
180 |         
181 |         this.updateCommands(gameState);
182 |     }
183 | 
184 |     getCollider() { return this.collider; }
185 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
186 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
187 |     
188 |     executeCommand(commandName, gameState, statusCallback) {
189 |         const command = this.commands.find(c => c && c.command === commandName);
190 |         if (!command) return;
191 | 
192 |         if (commandName.startsWith('research_')) {
193 |             if (this.buildQueue.length > 0) {
194 |                 statusCallback("Already researching an upgrade.");
195 |                 return;
196 |             }
197 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
198 |                 statusCallback("Not enough resources.");
199 |                 return;
200 |             }
201 | 
202 |             gameState.minerals -= command.cost.minerals;
203 |             if(command.cost.vespene) gameState.vespene -= command.cost.vespene;
204 | 
205 |             this.buildQueue.push({
206 |                 type: command.name,
207 |                 buildTime: command.researchTime,
208 |                 progress: 0,
209 |                 originalCommand: commandName,
210 |             });
211 | 
212 |             statusCallback(`Researching ${command.name}...`);
213 |             this.updateCommands(gameState);
214 |         }
215 |     }
216 |     
217 |     update(delta, gameState) {
218 |         if (this.isUnderConstruction) {
219 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
220 |             this.mesh.scale.y = buildProgress;
221 |             return;
222 |         }
223 | 
224 |         if (this.buildQueue.length > 0) {
225 |             const research = this.buildQueue[0];
226 |             research.progress += delta;
227 | 
228 |             if (research.progress >= research.buildTime) {
229 |                 const finished = this.buildQueue.shift();
230 |                 if (finished.originalCommand.includes('charon_boosters')) {
231 |                     gameState.upgrades.charonBoosters = true;
232 |                 } else if (finished.originalCommand.includes('vehicle_weapons')) {
233 |                     gameState.upgrades.vehicleWeapons++;
234 |                 } else if (finished.originalCommand.includes('vehicle_armor')) {
235 |                     gameState.upgrades.vehicleArmor++;
236 |                 } else if (finished.originalCommand.includes('ship_weapons')) {
237 |                     gameState.upgrades.shipWeapons++;
238 |                 } else if (finished.originalCommand.includes('ship_armor')) {
239 |                     gameState.upgrades.shipArmor++;
240 |                 }
241 |                 this.updateCommands(gameState);
242 |             }
243 |         }
244 |         
245 |         if (this.buildQueue.length === 0) {
246 |              this.updateCommands(gameState);
247 |         }
248 |     }
249 | }


--------------------------------------------------------------------------------
/src/buildings/barracks.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Unit } from '../units/unit.js';
  3 | import { FlyingBuildingBehavior } from './flying-building-behavior.js';
  4 | 
  5 | export class Barracks {
  6 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4, onStateChange = () => {} } = {}) {
  7 |         // UI and game properties
  8 |         this.name = 'Barracks';
  9 |         this.portraitUrl = 'assets/images/barracks_portrait.png';
 10 |         this.maxHealth = 1000;
 11 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 12 |         this.selected = false;
 13 |         this.isUnderConstruction = isUnderConstruction;
 14 |         this.buildTime = buildTime;
 15 |         this.onStateChange = onStateChange;
 16 | 
 17 |         // Behaviors
 18 |         this.flyingBehavior = new FlyingBuildingBehavior(this, {
 19 |             onStateChange: this.onStateChange,
 20 |         });
 21 | 
 22 |         // Command Card definition
 23 |         this._commands = [];
 24 |         this.hasAcademy = undefined;
 25 | 
 26 |         this.buildQueue = [];
 27 |         this.rallyPoint = new THREE.Vector3(position.x - 5, 0, position.z); // Default rally point
 28 | 
 29 |         this.mesh = this.createMesh();
 30 |         this.mesh.position.copy(position);
 31 | 
 32 |         this.mesh.traverse((child) => {
 33 |             if (child instanceof THREE.Mesh) {
 34 |                 child.castShadow = true;
 35 |                 child.receiveShadow = true;
 36 |                 child.userData.owner = this; // Link mesh to this instance
 37 |             }
 38 |         });
 39 | 
 40 |         if (this.isUnderConstruction) {
 41 |             this.mesh.scale.y = 0.01;
 42 |             this.mesh.traverse(child => {
 43 |                 if (child.isMesh) {
 44 |                     child.material = child.material.clone();
 45 |                     child.material.transparent = true;
 46 |                     child.material.opacity = 0.5;
 47 |                 }
 48 |             });
 49 |         }
 50 | 
 51 |         // The selection indicator on the ground
 52 |         const selectionGeometry = new THREE.RingGeometry(4, 4.2, 64);
 53 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 54 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 55 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 56 |         this.selectionIndicator.position.y = 0.01;
 57 |         this.selectionIndicator.visible = false;
 58 |         this.mesh.add(this.selectionIndicator);
 59 |         
 60 |         // Manually define collider box
 61 |         const buildingWidth = 7;
 62 |         const buildingDepth = 7;
 63 |         const buildingHeight = 5;
 64 |         this.groundCollider = new THREE.Box3(
 65 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 66 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 67 |         );
 68 |         this.groundCollider.translate(this.mesh.position);
 69 |     }
 70 | 
 71 |     get state() {
 72 |         return this.flyingBehavior.state;
 73 |     }
 74 |     set state(newState) {
 75 |         this.flyingBehavior.state = newState;
 76 |     }
 77 | 
 78 |     get commands() {
 79 |         return this._commands;
 80 |     }
 81 | 
 82 |     set commands(newCommands) {
 83 |         this._commands = newCommands;
 84 |     }
 85 | 
 86 |     createMesh() {
 87 |         const group = new THREE.Group();
 88 | 
 89 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 90 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 91 |         const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
 92 | 
 93 |         // Base structure
 94 |         const baseGeo = new THREE.BoxGeometry(6, 4, 6);
 95 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 96 |         base.position.y = 2;
 97 |         group.add(base);
 98 | 
 99 |         // Angled side parts
100 |         const sideGeo = new THREE.BoxGeometry(2, 3, 7);
101 |         const leftSide = new THREE.Mesh(sideGeo, accentMaterial);
102 |         leftSide.position.set(-3.5, 1.5, 0);
103 |         leftSide.rotation.z = Math.PI / 8;
104 |         group.add(leftSide);
105 |         
106 |         const rightSide = leftSide.clone();
107 |         rightSide.position.x = 3.5;
108 |         rightSide.rotation.z = -Math.PI / 8;
109 |         group.add(rightSide);
110 | 
111 |         // Large front door
112 |         const doorGeo = new THREE.BoxGeometry(3, 2.5, 0.2);
113 |         const door = new THREE.Mesh(doorGeo, doorMaterial);
114 |         door.position.set(0, 1.25, 3.05);
115 |         group.add(door);
116 |         
117 |         // Roof details
118 |         const roofDetailGeo = new THREE.BoxGeometry(4, 0.5, 4);
119 |         const roofDetail = new THREE.Mesh(roofDetailGeo, accentMaterial);
120 |         roofDetail.position.y = 4.25;
121 |         group.add(roofDetail);
122 | 
123 |         return group;
124 |     }
125 | 
126 |     updateCommands(gameState) {
127 |         if (this.isUnderConstruction) return;
128 | 
129 |         // Only update if the academy status has changed, to avoid constant array creation
130 |         if (this.hasAcademy === gameState.academyBuilt && this.state === 'grounded') {
131 |             return;
132 |         }
133 | 
134 |         this.hasAcademy = gameState.academyBuilt;
135 | 
136 |         const newCommands = new Array(12).fill(null);
137 | 
138 |         if (this.state === 'grounded') {
139 |             newCommands[0] = {
140 |                 command: 'train_marine',
141 |                 hotkey: 'M',
142 |                 icon: 'assets/images/train_marine_icon.png',
143 |                 name: 'Train Marine',
144 |                 cost: { minerals: 50, supply: 1 },
145 |                 buildTime: 20 // seconds
146 |             };
147 | 
148 |             if (gameState.academyBuilt) {
149 |                 newCommands[1] = {
150 |                     command: 'train_firebat',
151 |                     hotkey: 'F',
152 |                     icon: 'assets/images/train_firebat_icon.png',
153 |                     name: 'Train Firebat',
154 |                     cost: { minerals: 50, vespene: 25, supply: 1 },
155 |                     buildTime: 20
156 |                 };
157 |                 newCommands[2] = {
158 |                     command: 'train_medic',
159 |                     hotkey: 'E',
160 |                     icon: 'assets/images/train_medic_icon.png',
161 |                     name: 'Train Medic',
162 |                     cost: { minerals: 50, vespene: 25, supply: 1 },
163 |                     buildTime: 25,
164 |                 };
165 |             }
166 | 
167 |             if (gameState.academyBuilt && gameState.covertOpsBuilt) {
168 |                 newCommands[3] = {
169 |                     command: 'train_ghost',
170 |                     hotkey: 'G',
171 |                     icon: 'assets/images/train_ghost_icon.png',
172 |                     name: 'Train Ghost',
173 |                     cost: { minerals: 25, vespene: 75, supply: 1 },
174 |                     buildTime: 50
175 |                 };
176 |             }
177 |         
178 |             newCommands[8] = {
179 |                 command: 'lift_off',
180 |                 hotkey: 'L',
181 |                 icon: 'assets/images/lift_off_icon.png',
182 |                 name: 'Lift Off'
183 |             };
184 | 
185 |         } else if (this.state === 'flying') {
186 |             newCommands[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
187 |             newCommands[8] = {
188 |                 command: 'land_barracks',
189 |                 hotkey: 'L',
190 |                 icon: 'assets/images/lower_depot_icon.png',
191 |                 name: 'Land',
192 |                 cost: {}, // for placement system
193 |             };
194 |         }
195 |         
196 |         this.commands = newCommands;
197 |     }
198 | 
199 |     onConstructionComplete(gameState) {
200 |         this.isUnderConstruction = false;
201 |         this.currentHealth = this.maxHealth;
202 |         this.mesh.scale.y = 1.0;
203 |         
204 |         this.mesh.traverse(child => {
205 |             if (child.isMesh && child.material.transparent === true) {
206 |                 child.material.opacity = 1.0;
207 |                 child.material.transparent = false;
208 |             }
209 |         });
210 |         gameState.barracksBuilt = true;
211 |         this.updateCommands(gameState);
212 |     }
213 | 
214 |     getCollider() {
215 |         const flyingCollider = this.flyingBehavior.getCollider();
216 |         if (flyingCollider.isEmpty()) {
217 |             return flyingCollider;
218 |         }
219 |         return this.groundCollider;
220 |     }
221 | 
222 |     select() {
223 |         this.selected = true;
224 |         this.selectionIndicator.visible = true;
225 |     }
226 | 
227 |     deselect() {
228 |         this.selected = false;
229 |         this.selectionIndicator.visible = false;
230 |     }
231 | 
232 |     setPath(path) {
233 |         this.flyingBehavior.setPath(path);
234 |     }
235 | 
236 |     landAt(position, pathfinder) {
237 |         this.flyingBehavior.landAt(position, pathfinder);
238 |     }
239 | 
240 |     executeCommand(commandName, gameState, statusCallback) {
241 |         const command = this.commands.find(c => c && c.command === commandName);
242 |         if (!command) return;
243 | 
244 |         if (commandName.startsWith('train_')) {
245 |             if (this.state !== 'grounded') {
246 |                 statusCallback("Must be landed to train units.");
247 |                 return;
248 |             }
249 |             if (this.buildQueue.length >= 5) {
250 |                 statusCallback("Build queue is full.");
251 |                 return;
252 |             }
253 |             if (gameState.minerals < command.cost.minerals) {
254 |                 statusCallback("Not enough minerals.");
255 |                 return;
256 |             }
257 |             if (command.cost.vespene && gameState.vespene < command.cost.vespene) {
258 |                 statusCallback("Not enough vespene.");
259 |                 return;
260 |             }
261 |             if (gameState.supplyUsed + command.cost.supply > gameState.supplyCap) {
262 |                 statusCallback("Additional supply required.");
263 |                 return;
264 |             }
265 | 
266 |             gameState.minerals -= command.cost.minerals;
267 |             if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
268 |             
269 |             let unitType = '';
270 |             switch(commandName) {
271 |                 case 'train_marine': unitType = 'Marine'; break;
272 |                 case 'train_firebat': unitType = 'Firebat'; break;
273 |                 case 'train_medic': unitType = 'Medic'; break;
274 |                 case 'train_ghost': unitType = 'Ghost'; break;
275 |             }
276 |             
277 |             this.buildQueue.push({
278 |                 type: unitType,
279 |                 progress: 0,
280 |                 buildTime: command.buildTime,
281 |                 originalCommand: commandName,
282 |             });
283 |             statusCallback(`${unitType} training...`);
284 |             return;
285 |         }
286 | 
287 |         switch(commandName) {
288 |             case 'lift_off':
289 |                  if (this.flyingBehavior.liftOff()) {
290 |                      statusCallback("Lift-off sequence initiated.");
291 |                  } else {
292 |                      if (this.state !== 'grounded') statusCallback("Already airborne.");
293 |                  }
294 |                  break;
295 |         }
296 |     }
297 | 
298 |     update(delta, gameState, spawnUnitCallback) {
299 |         this.flyingBehavior.update(delta);
300 | 
301 |         if (this.isUnderConstruction) {
302 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
303 |             this.mesh.scale.y = buildProgress;
304 |             return;
305 |         }
306 | 
307 |         this.updateCommands(gameState);
308 | 
309 |         if (this.buildQueue.length > 0) {
310 |             const trainingUnit = this.buildQueue[0];
311 |             trainingUnit.progress += delta;
312 | 
313 |             if (trainingUnit.progress >= trainingUnit.buildTime) {
314 |                 const finishedUnit = this.buildQueue.shift();
315 |                 spawnUnitCallback(finishedUnit.type, this.rallyPoint.clone());
316 |             }
317 |         }
318 |     }
319 | }


--------------------------------------------------------------------------------
/src/buildings/bunker.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class Bunker {
  4 |     constructor(position, { isUnderConstruction = false, buildTime = 18.9 } = {}) {
  5 |         // UI and game properties
  6 |         this.name = 'Bunker';
  7 |         this.portraitUrl = 'assets/images/bunker_portrait.png';
  8 |         this.maxHealth = 400;
  9 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 10 |         this.selected = false;
 11 |         this.isUnderConstruction = isUnderConstruction;
 12 |         this.buildTime = buildTime;
 13 |         
 14 |         // Garrison properties
 15 |         this.garrisonedUnits = [];
 16 |         this.capacity = 4;
 17 | 
 18 |         this.mesh = this.createMesh();
 19 |         this.mesh.position.copy(position);
 20 | 
 21 |         this.mesh.traverse((child) => {
 22 |             if (child instanceof THREE.Mesh) {
 23 |                 child.castShadow = true;
 24 |                 child.receiveShadow = true;
 25 |                 child.userData.owner = this; // Link mesh to this instance
 26 |             }
 27 |         });
 28 | 
 29 |         if (this.isUnderConstruction) {
 30 |             this.mesh.scale.y = 0.01;
 31 |             this.mesh.traverse(child => {
 32 |                 if (child.isMesh) {
 33 |                     child.material = child.material.clone();
 34 |                     child.material.transparent = true;
 35 |                     child.material.opacity = 0.5;
 36 |                 }
 37 |             });
 38 |         }
 39 | 
 40 |         // The selection indicator on the ground
 41 |         const selectionGeometry = new THREE.RingGeometry(2.5, 2.7, 64);
 42 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 43 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 44 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 45 |         this.selectionIndicator.position.y = 0.01;
 46 |         this.selectionIndicator.visible = false;
 47 |         this.mesh.add(this.selectionIndicator);
 48 |         
 49 |         // Manually define collider box
 50 |         const buildingWidth = 4;
 51 |         const buildingDepth = 4;
 52 |         const buildingHeight = 3;
 53 |         this.collider = new THREE.Box3(
 54 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 55 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 56 |         );
 57 |         this.collider.translate(this.mesh.position);
 58 |     }
 59 |     
 60 |     get commands() {
 61 |         const commandList = new Array(12).fill(null);
 62 |         if (this.garrisonedUnits.length > 0) {
 63 |             commandList[0] = { 
 64 |                 command: 'unload_all', 
 65 |                 hotkey: 'U', 
 66 |                 icon: 'assets/images/unload_all_icon.png', 
 67 |                 name: 'Unload All'
 68 |             };
 69 |         }
 70 |         return commandList;
 71 |     }
 72 | 
 73 |     createMesh() {
 74 |         const group = new THREE.Group();
 75 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 76 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 77 | 
 78 |         const baseGeo = new THREE.BoxGeometry(4, 2.5, 4);
 79 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 80 |         base.position.y = 1.25;
 81 |         group.add(base);
 82 | 
 83 |         const topGeo = new THREE.BoxGeometry(3, 0.5, 3);
 84 |         const top = new THREE.Mesh(topGeo, accentMaterial);
 85 |         top.position.y = 2.75;
 86 |         group.add(top);
 87 | 
 88 |         const slitGeo = new THREE.BoxGeometry(3.2, 0.2, 0.2);
 89 |         const slitMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
 90 |         const frontSlit = new THREE.Mesh(slitGeo, slitMaterial);
 91 |         frontSlit.position.set(0, 1.5, 1.9);
 92 |         group.add(frontSlit);
 93 |         
 94 |         const backSlit = frontSlit.clone();
 95 |         backSlit.position.z = -1.9;
 96 |         group.add(backSlit);
 97 |         
 98 |         const leftSlit = frontSlit.clone();
 99 |         leftSlit.rotation.y = Math.PI / 2;
100 |         leftSlit.position.set(-1.9, 1.5, 0);
101 |         group.add(leftSlit);
102 |         
103 |         const rightSlit = leftSlit.clone();
104 |         rightSlit.position.x = 1.9;
105 |         group.add(rightSlit);
106 | 
107 |         return group;
108 |     }
109 | 
110 |     onConstructionComplete(gameState) {
111 |         this.isUnderConstruction = false;
112 |         this.currentHealth = this.maxHealth;
113 |         this.mesh.scale.y = 1.0;
114 |         
115 |         this.mesh.traverse(child => {
116 |             if (child.isMesh && child.material.transparent === true) {
117 |                 child.material.opacity = 1.0;
118 |                 child.material.transparent = false;
119 |             }
120 |         });
121 |     }
122 | 
123 |     getCollider() { return this.collider; }
124 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
125 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
126 |     
127 |     executeCommand(commandName, gameState, statusCallback) {
128 |         switch (commandName) {
129 |             case 'unload_all':
130 |                 this.unloadAll();
131 |                 statusCallback("Units unloaded.");
132 |                 break;
133 |         }
134 |     }
135 | 
136 |     addUnit(unit) {
137 |         if (this.garrisonedUnits.length >= this.capacity) {
138 |             return false; // Bunker is full
139 |         }
140 |         this.garrisonedUnits.push(unit);
141 |         unit.isGarrisoned = true;
142 |         unit.mesh.visible = false;
143 |         unit.deselect(); // Cannot have a selected unit that is garrisoned
144 |         return true;
145 |     }
146 | 
147 |     getSpawnPoints() {
148 |         const points = [];
149 |         const radius = 3; // How far from the center units spawn
150 |         const count = this.garrisonedUnits.length > 0 ? this.garrisonedUnits.length : 1;
151 |         for (let i = 0; i < this.garrisonedUnits.length; i++) {
152 |             const angle = (i / count) * Math.PI * 2;
153 |             points.push(
154 |                 this.mesh.position.clone().add(new THREE.Vector3(radius * Math.cos(angle), 0, radius * Math.sin(angle)))
155 |             );
156 |         }
157 |         return points;
158 |     }
159 | 
160 |     unloadAll() {
161 |         const spawnPoints = this.getSpawnPoints();
162 |         if (spawnPoints.length === 0) return;
163 | 
164 |         this.garrisonedUnits.forEach((unit, i) => {
165 |             const spawnPoint = spawnPoints[i % spawnPoints.length];
166 |             unit.mesh.position.copy(spawnPoint);
167 |             unit.isGarrisoned = false;
168 |             unit.mesh.visible = true;
169 |             unit.path = [];
170 |             unit.state = 'idle';
171 |         });
172 | 
173 |         this.garrisonedUnits = [];
174 |     }
175 | 
176 |     update(delta, gameState) {
177 |         if (this.isUnderConstruction) {
178 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
179 |             this.mesh.scale.y = buildProgress;
180 |         }
181 |     }
182 | }


--------------------------------------------------------------------------------
/src/buildings/command-center.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { FlyingBuildingBehavior } from './flying-building-behavior.js';
  4 | import { AddonBehavior } from './addon-behavior.js';
  5 | 
  6 | export class CommandCenter {
  7 |     constructor(position, { isUnderConstruction = false, buildTime = 75, onStateChange = () => {} } = {}) {
  8 |         // UI and game properties
  9 |         this.name = 'Command Center';
 10 |         this.portraitUrl = 'assets/images/command_center_portrait.png';
 11 |         this.maxHealth = 1500;
 12 |         this.currentHealth = isUnderConstruction ? 1 : 1500;
 13 |         this.selected = false;
 14 |         this.isUnderConstruction = isUnderConstruction;
 15 |         this.buildTime = buildTime;
 16 |         this.onStateChange = onStateChange;
 17 | 
 18 |         // Behaviors
 19 |         this.flyingBehavior = new FlyingBuildingBehavior(this, {
 20 |             onStateChange: this.onStateChange,
 21 |             hoverHeight: 5,
 22 |             animationDuration: 3.0,
 23 |             speed: 10
 24 |         });
 25 | 
 26 |         this.addonBehavior = new AddonBehavior(this);
 27 | 
 28 |         // Command Card is now a getter
 29 |         this._commands = [];
 30 |         this.buildQueue = [];
 31 |         this.rallyPoint = new THREE.Vector3(position.x - 8, 0, position.z); // Default rally point
 32 | 
 33 |         this.mesh = this.createMesh();
 34 |         this.mesh.position.copy(position);
 35 |         // Scale the entire structure down to half size
 36 |         this.mesh.scale.set(0.5, 0.5, 0.5);
 37 | 
 38 |         this.mesh.traverse((child) => {
 39 |             if (child instanceof THREE.Mesh) {
 40 |                 child.castShadow = true;
 41 |                 child.receiveShadow = true;
 42 |                 child.userData.owner = this; // Link mesh to this instance
 43 |             }
 44 |         });
 45 | 
 46 |         if (this.isUnderConstruction) {
 47 |             this.mesh.scale.y *= 0.01;
 48 |             this.mesh.traverse(child => {
 49 |                 if (child.isMesh) {
 50 |                     child.material = child.material.clone();
 51 |                     child.material.transparent = true;
 52 |                     child.material.opacity = 0.5;
 53 |                 }
 54 |             });
 55 |         }
 56 | 
 57 |         // The selection indicator on the ground
 58 |         const selectionGeometry = new THREE.RingGeometry(6, 6.5, 64);
 59 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 60 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 61 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 62 |         this.selectionIndicator.position.y = 0.01;
 63 |         this.selectionIndicator.visible = false;
 64 |         this.mesh.add(this.selectionIndicator);
 65 |         
 66 |         // Manually define collider box for simplicity and accuracy
 67 |         const buildingWidth = 6.5;
 68 |         const buildingDepth = 4;
 69 |         const buildingHeight = 5;
 70 |         this.groundCollider = new THREE.Box3(
 71 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 72 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 73 |         );
 74 |         this.groundCollider.translate(this.mesh.position);
 75 | 
 76 |         // Training progress visuals
 77 |         const barGeom = new THREE.PlaneGeometry(4, 0.4);
 78 |         const bgMat = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, depthTest: false });
 79 |         const fgMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, depthTest: false });
 80 |         this.progressBg = new THREE.Mesh(barGeom, bgMat);
 81 |         this.progressFg = new THREE.Mesh(barGeom, fgMat);
 82 |         this.progressFg.scale.x = 0;
 83 |         this.progressFg.position.z = 0.01;
 84 |         this.progressGroup = new THREE.Group();
 85 |         this.progressGroup.add(this.progressBg);
 86 |         this.progressGroup.add(this.progressFg);
 87 |         this.progressGroup.position.set(0, 8.5, 0);
 88 |         this.progressGroup.visible = false;
 89 |         this.mesh.add(this.progressGroup);
 90 | 
 91 |         // Queue count sprite
 92 |         const canvas = document.createElement('canvas');
 93 |         canvas.width = 64;
 94 |         canvas.height = 32;
 95 |         const ctx = canvas.getContext('2d');
 96 |         ctx.font = '28px Arial';
 97 |         ctx.fillStyle = '#ffffff';
 98 |         ctx.textAlign = 'center';
 99 |         ctx.textBaseline = 'middle';
100 |         ctx.clearRect(0, 0, canvas.width, canvas.height);
101 |         this.queueCtx = ctx;
102 |         this.queueCanvas = canvas;
103 |         this.queueTexture = new THREE.CanvasTexture(canvas);
104 |         const spriteMat = new THREE.SpriteMaterial({ map: this.queueTexture, transparent: true });
105 |         this.queueSprite = new THREE.Sprite(spriteMat);
106 |         this.queueSprite.scale.set(2, 1, 1);
107 |         this.queueSprite.position.set(0, 9.2, 0);
108 |         this.queueSprite.visible = false;
109 |         this.mesh.add(this.queueSprite);
110 |     }
111 | 
112 |     get state() {
113 |         return this.flyingBehavior.state;
114 |     }
115 |     set state(newState) {
116 |         this.flyingBehavior.state = newState;
117 |     }
118 | 
119 |     get commands() {
120 |         return this._commands;
121 |     }
122 | 
123 |     updateCommands(gameState) {
124 |         this.addonBehavior.updateCommands(gameState);
125 | 
126 |         const commandList = new Array(12).fill(null);
127 | 
128 |         // Addon behavior might be showing a cancel button or nothing.
129 |         if (this.addonBehavior.isBuilding()) {
130 |             this._commands = this.addonBehavior.getCommands();
131 |             return;
132 |         }
133 | 
134 |         // Base commands
135 |         if (this.state === 'grounded') {
136 |             const scvsInQueue = this.buildQueue.filter(item => item.type === 'SCV').length;
137 |             const scvCountForCost = Math.max(0, gameState.unitCounts.scv + scvsInQueue - 4);
138 |             const scvCost = Math.round(50 * Math.pow(1.4, scvCountForCost));
139 |             commandList[0] = {
140 |                 command: 'train_scv',
141 |                 hotkey: 'F',
142 |                 icon: 'assets/images/build_scv_icon.png',
143 |                 name: 'Build SCV',
144 |                 cost: { minerals: scvCost, supply: 1 },
145 |                 buildTime: 17 // seconds
146 |             };
147 | 
148 |             const scvM2sInQueue = this.buildQueue.filter(item => item.type === 'SCV Mark 2').length;
149 |             const scvM2CountForCost = Math.max(0, gameState.unitCounts.scv_mark_2 + scvM2sInQueue - 4);
150 |             const scvM2Cost = Math.round(75 * Math.pow(1.4, scvM2CountForCost));
151 |             commandList[1] = {
152 |                 command: 'train_scv_mark_2',
153 |                 hotkey: 'G',
154 |                 icon: 'assets/images/build_scv2_icon.png',
155 |                 name: 'Build SCV Mark 2',
156 |                 cost: { minerals: scvM2Cost, supply: 1 },
157 |                 buildTime: 22
158 |             };
159 |         }
160 | 
161 |         if (this.state === 'grounded') {
162 |             commandList[8] = {
163 |                 command: 'lift_off',
164 |                 hotkey: 'L',
165 |                 icon: 'assets/images/lift_off_icon.png',
166 |                 name: 'Lift Off'
167 |             };
168 |         } else if (this.state === 'flying') {
169 |             commandList[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
170 |             commandList[8] = {
171 |                 command: 'land_command_center',
172 |                 hotkey: 'L',
173 |                 icon: 'assets/images/lower_depot_icon.png',
174 |                 name: 'Land',
175 |                 cost: {}, // for placement system
176 |             };
177 |         }
178 | 
179 |         // Merge commands from addon behavior (build options or addon commands)
180 |         const addonCommands = this.addonBehavior.getCommands();
181 |         addonCommands.forEach((cmd, index) => {
182 |             if (cmd) commandList[index] = cmd;
183 |         });
184 |         
185 |         this._commands = commandList;
186 |     }
187 | 
188 |     createMesh() {
189 |         try {
190 |             const asset = assetManager.get('extra_command_center');
191 |             return this.createMeshFromGLB(asset);
192 |         } catch (error) {
193 |             console.warn('Could not load command center model, using procedural fallback.', error);
194 |             return this.createProceduralMesh();
195 |         }
196 |     }
197 | 
198 |     createProceduralMesh() {
199 |         const group = new THREE.Group();
200 | 
201 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x8a9aaa, metalness: 0.7, roughness: 0.6 });
202 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x5a6a7a, metalness: 0.8, roughness: 0.5 });
203 |         const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 1.0 });
204 | 
205 |         // Base structure
206 |         const baseGeo = new THREE.BoxGeometry(10, 2, 8);
207 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
208 |         base.position.y = 1;
209 |         group.add(base);
210 | 
211 |         // Upper structure
212 |         const upperGeo = new THREE.BoxGeometry(7, 2, 6);
213 |         const upper = new THREE.Mesh(upperGeo, mainMaterial);
214 |         upper.position.y = 3;
215 |         group.add(upper);
216 | 
217 |         // Command tower
218 |         const towerGeo = new THREE.CylinderGeometry(1.5, 2, 3, 8);
219 |         const tower = new THREE.Mesh(towerGeo, accentMaterial);
220 |         tower.position.y = 5.5;
221 |         group.add(tower);
222 | 
223 |         // Antenna
224 |         const antennaGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
225 |         const antenna = new THREE.Mesh(antennaGeo, new THREE.MeshStandardMaterial({ color: 0x333333 }));
226 |         antenna.position.y = 8;
227 |         group.add(antenna);
228 | 
229 |         // Side pods
230 |         const podGeo = new THREE.BoxGeometry(2, 1.5, 3);
231 |         const leftPod = new THREE.Mesh(podGeo, accentMaterial);
232 |         leftPod.position.set(-5.5, 0.75, 0);
233 |         leftPod.name = "leftPod";
234 |         group.add(leftPod);
235 |         
236 |         const rightPod = leftPod.clone();
237 |         rightPod.position.x = 5.5;
238 |         rightPod.name = "rightPod";
239 |         group.add(rightPod);
240 | 
241 |         // Small lights
242 |         const lightGeo = new THREE.SphereGeometry(0.2, 8, 8);
243 |         const light1 = new THREE.Mesh(lightGeo, lightMaterial);
244 |         light1.position.set(4.9, 2.2, 3);
245 |         group.add(light1);
246 | 
247 |         const light2 = light1.clone();
248 |         light2.position.set(-4.9, 2.2, 3);
249 |         group.add(light2);
250 |         
251 |         const light3 = light1.clone();
252 |         light3.position.set(4.9, 2.2, -3);
253 |         group.add(light3);
254 | 
255 |         const light4 = light1.clone();
256 |         light4.position.set(-4.9, 2.2, -4);
257 |         group.add(light4);
258 | 
259 |         return group;
260 |     }
261 | 
262 |     createMeshFromGLB(asset) {
263 |         const model = asset.scene.clone();
264 | 
265 |         const box = new THREE.Box3().setFromObject(model);
266 |         const size = box.getSize(new THREE.Vector3());
267 |         const desired = new THREE.Vector3(13, 10, 8);
268 |         const scale = Math.min(
269 |             desired.x / size.x,
270 |             desired.y / size.y,
271 |             desired.z / size.z
272 |         );
273 | 
274 |         if (scale > 0 && Number.isFinite(scale)) {
275 |             model.scale.set(scale, scale, scale);
276 |         }
277 | 
278 |         // Shift the model up so its bottom sits on the ground. Some imported
279 |         // GLB files have their origin at the center which makes them sink half
280 |         // way below y=0. After scaling we translate the model so the bounding
281 |         // box minimum is at 0.
282 |         const adjustedBox = new THREE.Box3().setFromObject(model);
283 |         model.position.y -= adjustedBox.min.y;
284 | 
285 |         const wrapper = new THREE.Group();
286 |         wrapper.add(model);
287 | 
288 |         wrapper.traverse(child => {
289 |             if (child.isMesh) {
290 |                 child.castShadow = true;
291 |                 child.receiveShadow = true;
292 |                 child.userData.owner = this;
293 |             }
294 |         });
295 | 
296 |         return wrapper;
297 |     }
298 | 
299 |     onConstructionComplete(gameState) {
300 |         this.isUnderConstruction = false;
301 |         this.currentHealth = this.maxHealth;
302 |         this.mesh.scale.y = 0.5;
303 |         
304 |         this.mesh.traverse(child => {
305 |             if (child.isMesh && child.material.transparent === true) {
306 |                 child.material.opacity = 1.0;
307 |                 child.material.transparent = false;
308 |             }
309 |         });
310 |         this.updateCommands(gameState);
311 |     }
312 | 
313 |     getCollider() {
314 |         const flyingCollider = this.flyingBehavior.getCollider();
315 |         // If airborne, collider is empty.
316 |         if (flyingCollider.isEmpty()) {
317 |             return flyingCollider;
318 |         }
319 | 
320 |         // Otherwise, on the ground, calculate union of self and addon.
321 |         if (this.addonBehavior.addon) {
322 |             const ccBox = this.groundCollider.clone();
323 |             const addonBox = this.addonBehavior.addon.getCollider();
324 |             return ccBox.union(addonBox);
325 |         }
326 |         return this.groundCollider;
327 |     }
328 | 
329 |     select() {
330 |         this.selected = true;
331 |         this.selectionIndicator.visible = true;
332 |         if (this.addonBehavior.addon) {
333 |             this.addonBehavior.addon.selected = true;
334 |         }
335 |     }
336 | 
337 |     deselect(calledByAddon = false) {
338 |         this.selected = false;
339 |         this.selectionIndicator.visible = false;
340 |         if (this.addonBehavior.addon && !calledByAddon) {
341 |             this.addonBehavior.addon.deselect();
342 |         }
343 |     }
344 | 
345 |     setPath(path) {
346 |         this.flyingBehavior.setPath(path);
347 |     }
348 | 
349 |     executeCommand(commandName, gameState, statusCallback) {
350 |         // First, see if the addon behavior handles this command
351 |         if (this.addonBehavior.executeCommand(commandName, gameState, statusCallback)) {
352 |             return; // Command was handled by addon behavior
353 |         }
354 |         
355 |         // We need to re-fetch the command to get the dynamic cost
356 |         this.updateCommands(gameState); // Explicitly update commands to get latest cost
357 |         const command = this._commands.find(c => c && c.command === commandName);
358 |         if (!command) return;
359 | 
360 |         if (command.prereq && !gameState[command.prereq]) {
361 |             let prereqName = "prerequisites";
362 |             if (command.prereq === 'academyBuilt') prereqName = "Academy";
363 |             else if (command.prereq === 'engineeringBayBuilt') prereqName = "Engineering Bay";
364 |             else if (command.prereq === 'scienceFacilityBuilt') prereqName = "Science Facility";
365 |             statusCallback(`Requires ${prereqName}.`);
366 |             return;
367 |         }
368 | 
369 |         switch(commandName) {
370 |             case 'train_scv':
371 |             case 'train_scv_mark_2':
372 |                 if (this.state !== 'grounded') {
373 |                     statusCallback("Must be landed to train units.");
374 |                     return;
375 |                 }
376 |                 if (this.addonBehavior.isBuilding()) {
377 |                     statusCallback("Cannot train units while building an addon.");
378 |                     return;
379 |                 }
380 |                 if (this.buildQueue.length >= 5) {
381 |                     statusCallback("Build queue is full.");
382 |                     return;
383 |                 }
384 |                 if (gameState.minerals < command.cost.minerals) {
385 |                     statusCallback("Not enough minerals.");
386 |                     return;
387 |                 }
388 |                 if (gameState.supplyUsed + command.cost.supply > gameState.supplyCap) {
389 |                     statusCallback("Additional supply required.");
390 |                     return;
391 |                 }
392 | 
393 |                 gameState.minerals -= command.cost.minerals;
394 |                 // Supply is formally used when unit spawns, not when queued.
395 |                 this.buildQueue.push({
396 |                     type: command.name.replace('Build ', ''),
397 |                     progress: 0,
398 |                     buildTime: command.buildTime,
399 |                     originalCommand: commandName,
400 |                 });
401 |                 statusCallback(`${command.name.replace('Build ', '')} training...`);
402 |                 break;
403 | 
404 |             case 'lift_off':
405 |                  if (this.flyingBehavior.liftOff()) {
406 |                      statusCallback("Lift-off sequence initiated.");
407 |                  } else {
408 |                      if (this.state !== 'grounded') statusCallback("Already airborne.");
409 |                      else if (this.addonBehavior.addon) statusCallback("Cannot lift off with an addon attached.");
410 |                  }
411 |                  break;
412 |             case 'land_command_center':
413 |                  // This is now handled by the placement system via game/index.js
414 |                  // It will call landAt() on this instance.
415 |                  break;
416 |         }
417 |     }
418 | 
419 |     landAt(position, pathfinder) {
420 |         this.flyingBehavior.landAt(position, pathfinder);
421 |     }
422 | 
423 |     update(delta, gameState, spawnUnitCallback, spawnBuildingCallback) {
424 |         if (this.isUnderConstruction) {
425 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
426 |             this.mesh.scale.y = buildProgress * 0.5;
427 |             return;
428 |         }
429 | 
430 |         this.flyingBehavior.update(delta);
431 |         this.addonBehavior.update(delta, gameState);
432 |         this.updateCommands(gameState); // Keep commands fresh
433 | 
434 |         // Unit/Addon Production
435 |         if (this.buildQueue.length > 0) {
436 |             const job = this.buildQueue[0];
437 |             job.progress += delta;
438 | 
439 |             if (job.progress >= job.buildTime) {
440 |                 // Job finished
441 |                 const finishedJob = this.buildQueue.shift();
442 |                 
443 |                 if (finishedJob.isAddon) {
444 |                     this.addonBehavior.completeAddonConstruction(finishedJob, spawnBuildingCallback, gameState);
445 |                 } else {
446 |                     spawnUnitCallback(finishedJob.type, this.rallyPoint.clone());
447 |                 }
448 |             }
449 |         }
450 |     }
451 | }
452 | 


--------------------------------------------------------------------------------
/src/buildings/comsat-station.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { createScannerSweep } from '../game/effects.js';
  3 | import { getGroundMeshes } from '../utils/terrain.js';
  4 | 
  5 | export class ComsatStation {
  6 |     constructor(position, { isUnderConstruction = false, buildTime = 25.2, parent = null } = {}) {
  7 |         this.name = 'Comsat Station';
  8 |         this.portraitUrl = 'assets/images/comsat_station_portrait.png';
  9 |         this.maxHealth = 500;
 10 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 11 |         this.selected = false;
 12 |         this.isUnderConstruction = isUnderConstruction;
 13 |         this.buildTime = buildTime;
 14 |         this.parentBuilding = parent;
 15 | 
 16 |         this.energy = 50;
 17 |         this.maxEnergy = 200;
 18 |         this.isAddon = true;
 19 | 
 20 |         // Commands will be merged by the parent Command Center
 21 |         this.commands = [
 22 |             null, // Placeholder for alignment
 23 |             null,
 24 |             null,
 25 |             {
 26 |                 command: 'scanner_sweep',
 27 |                 hotkey: 'S',
 28 |                 icon: 'assets/images/scanner_sweep_icon.png',
 29 |                 name: 'Scanner Sweep',
 30 |                 cost: { energy: 50 }
 31 |             }
 32 |         ];
 33 | 
 34 |         this.mesh = this.createMesh();
 35 |         this.mesh.position.copy(position);
 36 | 
 37 |         this.mesh.traverse((child) => {
 38 |             if (child.isMesh) {
 39 |                 child.castShadow = true;
 40 |                 child.receiveShadow = true;
 41 |                 child.userData.owner = this;
 42 |             }
 43 |         });
 44 | 
 45 |         const buildingWidth = 5;
 46 |         const buildingDepth = 5;
 47 |         const buildingHeight = 7;
 48 |         this.collider = new THREE.Box3(
 49 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 50 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 51 |         );
 52 |         this.collider.translate(this.mesh.position);
 53 |     }
 54 | 
 55 |     createMesh() {
 56 |         const group = new THREE.Group();
 57 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 58 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 59 | 
 60 |         const baseGeo = new THREE.BoxGeometry(4, 2, 4);
 61 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 62 |         base.position.y = 1.0;
 63 |         group.add(base);
 64 | 
 65 |         const supportGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.0, 8);
 66 |         const support = new THREE.Mesh(supportGeo, accentMaterial);
 67 |         support.position.y = 2.5;
 68 |         group.add(support);
 69 |         
 70 |         const dishGeo = new THREE.SphereGeometry(2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2.5);
 71 |         this.dish = new THREE.Mesh(dishGeo, mainMaterial);
 72 |         this.dish.position.y = 3.0;
 73 |         this.dish.rotation.x = -Math.PI / 5;
 74 |         group.add(this.dish);
 75 | 
 76 |         return group;
 77 |     }
 78 |     
 79 |     getCollider() { return this.collider; }
 80 |     
 81 |     select() { 
 82 |         this.selected = true; 
 83 |         if(this.parentBuilding && !this.parentBuilding.selected) this.parentBuilding.select();
 84 |     }
 85 |     deselect() { 
 86 |         this.selected = false;
 87 |         if(this.parentBuilding && this.parentBuilding.selected) this.parentBuilding.deselect(true); // pass flag to avoid feedback loop
 88 |     }
 89 |     
 90 |     executeCommand(commandName, gameState, statusCallback) {
 91 |         if (commandName === 'scanner_sweep') {
 92 |             const cost = 50;
 93 |             if (this.energy < cost) {
 94 |                 statusCallback('Not enough energy.');
 95 |                 return true;
 96 |             }
 97 | 
 98 |             const scene = window.gameScene;
 99 |             const camera = window.gameCamera;
100 |             if (!scene || !camera) {
101 |                 statusCallback('Scanner unavailable.');
102 |                 return true;
103 |             }
104 | 
105 |             const groundMeshes = getGroundMeshes(scene);
106 |             const raycaster = new THREE.Raycaster();
107 |             raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
108 |             const intersects = raycaster.intersectObjects(groundMeshes, true);
109 | 
110 |             if (intersects.length > 0) {
111 |                 this.energy -= cost;
112 |                 createScannerSweep(intersects[0].point);
113 |                 statusCallback('Scanner Sweep activated.');
114 |             } else {
115 |                 statusCallback('No valid target.');
116 |             }
117 |             return true;
118 |         }
119 |         return false; // Command was not handled
120 |     }
121 | 
122 |     update(delta) {
123 |         // Regenerate energy
124 |         if (this.energy < this.maxEnergy) {
125 |             this.energy += 0.5625 * delta;
126 |         }
127 |         if (this.energy > this.maxEnergy) {
128 |             this.energy = this.maxEnergy;
129 |         }
130 | 
131 |         if (this.dish) {
132 |             this.dish.rotation.y += delta * 0.4;
133 |         }
134 |     }
135 | }


--------------------------------------------------------------------------------
/src/buildings/control-tower.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class ControlTower {
  4 |     constructor(position, { isUnderConstruction = false, buildTime = 30, parent = null } = {}) {
  5 |         this.name = 'Control Tower';
  6 |         this.portraitUrl = 'assets/images/control_tower_portrait.png';
  7 |         this.maxHealth = 750;
  8 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
  9 |         this.selected = false;
 10 |         this.isUnderConstruction = isUnderConstruction;
 11 |         this.buildTime = buildTime;
 12 |         this.parentBuilding = parent;
 13 |         this.isAddon = true;
 14 | 
 15 |         this.buildQueue = []; // For research progress
 16 |         this.commands = []; // Research commands will be populated
 17 | 
 18 |         this.mesh = this.createMesh();
 19 |         this.mesh.position.copy(position);
 20 | 
 21 |         this.mesh.traverse((child) => {
 22 |             if (child.isMesh) {
 23 |                 child.castShadow = true;
 24 |                 child.receiveShadow = true;
 25 |                 child.userData.owner = this;
 26 |             }
 27 |         });
 28 |         
 29 |         const buildingWidth = 4;
 30 |         const buildingDepth = 4;
 31 |         const buildingHeight = 8;
 32 |         this.collider = new THREE.Box3(
 33 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 34 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 35 |         );
 36 |         this.collider.translate(this.mesh.position);
 37 |     }
 38 | 
 39 |     createMesh() {
 40 |         const group = new THREE.Group();
 41 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 42 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 43 |         
 44 |         const baseGeo = new THREE.CylinderGeometry(2, 2, 4, 8);
 45 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 46 |         base.position.y = 2;
 47 |         group.add(base);
 48 | 
 49 |         const dishGeo = new THREE.SphereGeometry(2.5, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2.5);
 50 |         this.dish = new THREE.Mesh(dishGeo, accentMaterial);
 51 |         this.dish.position.y = 5;
 52 |         this.dish.rotation.x = -Math.PI / 6;
 53 |         group.add(this.dish);
 54 |         
 55 |         return group;
 56 |     }
 57 | 
 58 |     getCollider() { return this.collider; }
 59 |     
 60 |     select() { 
 61 |         this.selected = true; 
 62 |         if(this.parentBuilding && !this.parentBuilding.selected) this.parentBuilding.select();
 63 |     }
 64 |     deselect(flag) {
 65 |         this.selected = false;
 66 |         if(this.parentBuilding && this.parentBuilding.selected && !flag) this.parentBuilding.deselect(true);
 67 |     }
 68 | 
 69 |     updateCommands(gameState) {
 70 |         if (this.isUnderConstruction || this.buildQueue.length > 0) {
 71 |             this.commands = [];
 72 |             return;
 73 |         }
 74 | 
 75 |         const newCommands = new Array(12).fill(null);
 76 | 
 77 |         if (!gameState.upgrades.wraithCloaking) {
 78 |             newCommands[0] = {
 79 |                 command: 'research_wraith_cloaking',
 80 |                 hotkey: 'C',
 81 |                 icon: 'assets/images/cloak_icon.png',
 82 |                 name: 'Research Wraith Cloaking',
 83 |                 cost: { minerals: 150, vespene: 150 },
 84 |                 researchTime: 80
 85 |             };
 86 |         }
 87 | 
 88 |         if (!gameState.upgrades.dropThrusters) {
 89 |             newCommands[1] = {
 90 |                 command: 'research_drop_thrusters',
 91 |                 hotkey: 'D',
 92 |                 icon: 'assets/images/train_dropship_icon.png',
 93 |                 name: 'Research Drop Thrusters',
 94 |                 cost: { minerals: 100, vespene: 100 },
 95 |                 researchTime: 60
 96 |             };
 97 |         }
 98 | 
 99 |         this.commands = newCommands;
100 |     }
101 |     
102 |     executeCommand(commandName, gameState, statusCallback) {
103 |         const command = this.commands.find(c => c && c.command === commandName);
104 |         if (!command) return;
105 | 
106 |         if (commandName.startsWith('research_')) {
107 |             if (this.buildQueue.length > 0) {
108 |                 statusCallback("Already researching.");
109 |                 return;
110 |             }
111 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
112 |                 statusCallback("Not enough resources.");
113 |                 return;
114 |             }
115 | 
116 |             gameState.minerals -= command.cost.minerals;
117 |             if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
118 | 
119 |             this.buildQueue.push({
120 |                 type: command.name,
121 |                 buildTime: command.researchTime,
122 |                 progress: 0,
123 |                 originalCommand: commandName,
124 |             });
125 | 
126 |             statusCallback(`Researching ${command.name}...`);
127 |         }
128 |     }
129 | 
130 |     update(delta, gameState) {
131 |         if (this.buildQueue.length > 0) {
132 |             const research = this.buildQueue[0];
133 |             research.progress += delta;
134 | 
135 |             if (research.progress >= research.buildTime) {
136 |                 const finished = this.buildQueue.shift();
137 |                 if (finished.originalCommand.includes('wraith_cloaking')) {
138 |                     gameState.upgrades.wraithCloaking = true;
139 |                 } else if (finished.originalCommand.includes('drop_thrusters')) {
140 |                     gameState.upgrades.dropThrusters = true;
141 |                 }
142 |                 this.updateCommands(gameState);
143 |             }
144 |         }
145 | 
146 |         if (this.buildQueue.length === 0) {
147 |             this.updateCommands(gameState);
148 |         }
149 | 
150 |         if(this.dish) {
151 |             this.dish.rotation.y += delta * 0.4;
152 |         }
153 |     }
154 | }
155 | 
156 | 


--------------------------------------------------------------------------------
/src/buildings/engineering-bay.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { FlyingBuildingBehavior } from './flying-building-behavior.js';
  3 | 
  4 | /** @tweakable Hotkeys for Engineering Bay upgrades */
  5 | const engineeringBayHotkeys = {
  6 |     upgradeWeapons: 'E',
  7 |     upgradeArmor: 'R',
  8 | };
  9 | 
 10 | export class EngineeringBay {
 11 |     constructor(position, { isUnderConstruction = false, buildTime = 37.8, onStateChange = () => {} } = {}) {
 12 |         this.name = 'Engineering Bay';
 13 |         this.portraitUrl = 'assets/images/engineering_bay_portrait.png';
 14 |         this.maxHealth = 850;
 15 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 16 |         this.selected = false;
 17 |         this.isUnderConstruction = isUnderConstruction;
 18 |         this.buildTime = buildTime;
 19 |         this.onStateChange = onStateChange;
 20 | 
 21 |         // Behaviors
 22 |         this.flyingBehavior = new FlyingBuildingBehavior(this, {
 23 |             onStateChange: this.onStateChange,
 24 |         });
 25 | 
 26 |         this._commands = [];
 27 |         this.buildQueue = []; // Used for research progress
 28 | 
 29 |         this.mesh = this.createMesh();
 30 |         this.mesh.position.copy(position);
 31 | 
 32 |         this.mesh.traverse((child) => {
 33 |             if (child.isMesh) {
 34 |                 child.castShadow = true;
 35 |                 child.receiveShadow = true;
 36 |                 child.userData.owner = this;
 37 |             }
 38 |         });
 39 | 
 40 |         if (this.isUnderConstruction) {
 41 |             this.mesh.scale.y = 0.01;
 42 |             this.mesh.traverse(child => {
 43 |                 if (child.isMesh) {
 44 |                     child.material = child.material.clone();
 45 |                     child.material.transparent = true;
 46 |                     child.material.opacity = 0.5;
 47 |                 }
 48 |             });
 49 |         }
 50 | 
 51 |         const selectionGeometry = new THREE.RingGeometry(3.5, 3.7, 64);
 52 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 53 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 54 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 55 |         this.selectionIndicator.position.y = 0.01;
 56 |         this.selectionIndicator.visible = false;
 57 |         this.mesh.add(this.selectionIndicator);
 58 |         
 59 |         const buildingWidth = 6;
 60 |         const buildingDepth = 6;
 61 |         const buildingHeight = 5;
 62 |         this.groundCollider = new THREE.Box3(
 63 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 64 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 65 |         );
 66 |         this.groundCollider.translate(this.mesh.position);
 67 |     }
 68 |     
 69 |     get state() {
 70 |         return this.flyingBehavior.state;
 71 |     }
 72 |     set state(newState) {
 73 |         this.flyingBehavior.state = newState;
 74 |     }
 75 | 
 76 |     get commands() {
 77 |         return this._commands;
 78 |     }
 79 |     set commands(newCommands) {
 80 |         this._commands = newCommands;
 81 |     }
 82 | 
 83 |     createMesh() {
 84 |         const group = new THREE.Group();
 85 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 86 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 87 | 
 88 |         const baseGeo = new THREE.BoxGeometry(6, 2, 6);
 89 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 90 |         base.position.y = 1;
 91 |         group.add(base);
 92 | 
 93 |         const supportGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
 94 |         const support = new THREE.Mesh(supportGeo, accentMaterial);
 95 |         support.position.y = 2.5;
 96 |         group.add(support);
 97 |         
 98 |         const dishGeo = new THREE.SphereGeometry(2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
 99 |         const dish = new THREE.Mesh(dishGeo, mainMaterial);
100 |         dish.position.y = 3;
101 |         dish.rotation.x = -Math.PI / 4;
102 |         group.add(dish);
103 | 
104 |         return group;
105 |     }
106 |     
107 |     updateCommands(gameState) {
108 |         if (this.isUnderConstruction || this.buildQueue.length > 0) {
109 |             return;
110 |         }
111 | 
112 |         const newCommands = new Array(12).fill(null);
113 |         const weaponLevel = gameState.upgrades.infantryWeapons;
114 |         const armorLevel = gameState.upgrades.infantryArmor;
115 | 
116 |         if (this.state === 'grounded') {
117 |             if (weaponLevel < 3) {
118 |                 newCommands[0] = {
119 |                     command: `research_infantry_weapons_${weaponLevel + 1}`,
120 |                     hotkey: engineeringBayHotkeys.upgradeWeapons,
121 |                     icon: 'assets/images/upgrade_infantry_weapons_icon.png',
122 |                     name: `Upgrade Infantry Weapons (Lvl ${weaponLevel + 1})`,
123 |                     cost: { minerals: 100 * (weaponLevel + 1), vespene: 100 * (weaponLevel + 1) },
124 |                     researchTime: 167
125 |                 };
126 |             }
127 |             
128 |             if (armorLevel < 3) {
129 |                 newCommands[1] = {
130 |                     command: `research_infantry_armor_${armorLevel + 1}`,
131 |                     hotkey: engineeringBayHotkeys.upgradeArmor,
132 |                     icon: 'assets/images/upgrade_infantry_armor_icon.png',
133 |                     name: `Upgrade Infantry Armor (Lvl ${armorLevel + 1})`,
134 |                     cost: { minerals: 100 * (armorLevel + 1), vespene: 100 * (armorLevel + 1) },
135 |                     researchTime: 167
136 |                 };
137 |             }
138 | 
139 |             newCommands[8] = {
140 |                 command: 'lift_off',
141 |                 hotkey: 'L',
142 |                 icon: 'assets/images/lift_off_icon.png',
143 |                 name: 'Lift Off'
144 |             };
145 |         } else if (this.state === 'flying') {
146 |             newCommands[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
147 |             newCommands[8] = {
148 |                 command: 'land_engineering_bay',
149 |                 hotkey: 'L',
150 |                 icon: 'assets/images/lower_depot_icon.png',
151 |                 name: 'Land',
152 |                 cost: {}, // for placement system
153 |             };
154 |         }
155 | 
156 |         this.commands = newCommands;
157 |     }
158 | 
159 |     onConstructionComplete(gameState) {
160 |         this.isUnderConstruction = false;
161 |         this.currentHealth = this.maxHealth;
162 |         this.mesh.scale.y = 1.0;
163 |         
164 |         this.mesh.traverse(child => {
165 |             if (child.isMesh && child.material.transparent === true) {
166 |                 child.material.opacity = 1.0;
167 |                 child.material.transparent = false;
168 |             }
169 |         });
170 |         
171 |         gameState.engineeringBayBuilt = true;
172 |         this.updateCommands(gameState);
173 |     }
174 | 
175 |     getCollider() {
176 |         const flyingCollider = this.flyingBehavior.getCollider();
177 |         if (flyingCollider.isEmpty()) {
178 |             return flyingCollider;
179 |         }
180 |         return this.groundCollider;
181 |     }
182 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
183 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
184 |     
185 |     setPath(path) {
186 |         this.flyingBehavior.setPath(path);
187 |     }
188 | 
189 |     landAt(position, pathfinder) {
190 |         this.flyingBehavior.landAt(position, pathfinder);
191 |     }
192 | 
193 |     executeCommand(commandName, gameState, statusCallback) {
194 |         const command = this.commands.find(c => c && c.command === commandName);
195 |         if (!command) return;
196 | 
197 |         if (commandName.startsWith('research_')) {
198 |             if (this.buildQueue.length > 0) {
199 |                 statusCallback("Already researching an upgrade.");
200 |                 return;
201 |             }
202 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
203 |                 statusCallback("Not enough resources.");
204 |                 return;
205 |             }
206 | 
207 |             gameState.minerals -= command.cost.minerals;
208 |             if(command.cost.vespene) gameState.vespene -= command.cost.vespene;
209 | 
210 |             this.buildQueue.push({
211 |                 type: command.name,
212 |                 buildTime: command.researchTime,
213 |                 progress: 0,
214 |                 originalCommand: commandName,
215 |             });
216 | 
217 |             statusCallback(`Researching ${command.name}...`);
218 |         } else if (commandName === 'lift_off') {
219 |              if (this.flyingBehavior.liftOff()) {
220 |                  statusCallback("Lift-off sequence initiated.");
221 |              } else {
222 |                  if (this.state !== 'grounded') statusCallback("Already airborne.");
223 |              }
224 |         }
225 |     }
226 |     
227 |     update(delta, gameState) {
228 |         this.flyingBehavior.update(delta);
229 | 
230 |         if (this.isUnderConstruction) {
231 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
232 |             this.mesh.scale.y = buildProgress;
233 |             return;
234 |         }
235 | 
236 |         if (this.buildQueue.length > 0) {
237 |             const research = this.buildQueue[0];
238 |             research.progress += delta;
239 | 
240 |             if (research.progress >= research.buildTime) {
241 |                 const finished = this.buildQueue.shift();
242 |                 if (finished.originalCommand.includes('weapons')) {
243 |                     gameState.upgrades.infantryWeapons++;
244 |                 } else if (finished.originalCommand.includes('armor')) {
245 |                     gameState.upgrades.infantryArmor++;
246 |                 }
247 |             }
248 |         }
249 | 
250 |         this.updateCommands(gameState);
251 |     }
252 | }


--------------------------------------------------------------------------------
/src/buildings/factory.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { FlyingBuildingBehavior } from './flying-building-behavior.js';
  3 | 
  4 | /** @tweakable Hotkeys for Factory commands */
  5 | const factoryHotkeys = {
  6 |     trainVulture: 'V',
  7 |     trainSiegeTank: 'T',
  8 |     trainGoliath: 'G',
  9 |     researchSiegeMode: 'E',
 10 | };
 11 | 
 12 | export class Factory {
 13 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4, onStateChange = () => {} } = {}) {
 14 |         this.name = 'Factory';
 15 |         this.portraitUrl = 'assets/images/factory_portrait.png';
 16 |         this.maxHealth = 1250;
 17 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 18 |         this.selected = false;
 19 |         this.isUnderConstruction = isUnderConstruction;
 20 |         this.buildTime = buildTime;
 21 |         this.onStateChange = onStateChange;
 22 | 
 23 |         // Behaviors
 24 |         this.flyingBehavior = new FlyingBuildingBehavior(this, {
 25 |             onStateChange: this.onStateChange,
 26 |         });
 27 | 
 28 |         this._commands = [];
 29 |         this.buildQueue = [];
 30 |         this.rallyPoint = new THREE.Vector3(position.x - 6, 0, position.z);
 31 |         this.hasArmory = undefined;
 32 | 
 33 |         this.mesh = this.createMesh();
 34 |         this.mesh.position.copy(position);
 35 | 
 36 |         this.mesh.traverse((child) => {
 37 |             if (child.isMesh) {
 38 |                 child.castShadow = true;
 39 |                 child.receiveShadow = true;
 40 |                 child.userData.owner = this;
 41 |             }
 42 |         });
 43 | 
 44 |         if (this.isUnderConstruction) {
 45 |             this.mesh.scale.y = 0.01;
 46 |             this.mesh.traverse(child => {
 47 |                 if (child.isMesh) {
 48 |                     child.material = child.material.clone();
 49 |                     child.material.transparent = true;
 50 |                     child.material.opacity = 0.5;
 51 |                 }
 52 |             });
 53 |         }
 54 | 
 55 |         const selectionGeometry = new THREE.RingGeometry(4.5, 4.7, 64);
 56 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 57 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 58 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 59 |         this.selectionIndicator.position.y = 0.01;
 60 |         this.selectionIndicator.visible = false;
 61 |         this.mesh.add(this.selectionIndicator);
 62 | 
 63 |         const buildingWidth = 8;
 64 |         const buildingDepth = 6;
 65 |         const buildingHeight = 6;
 66 |         this.groundCollider = new THREE.Box3(
 67 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 68 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 69 |         );
 70 |         this.groundCollider.translate(this.mesh.position);
 71 |     }
 72 | 
 73 |     get state() {
 74 |         return this.flyingBehavior.state;
 75 |     }
 76 |     set state(newState) {
 77 |         this.flyingBehavior.state = newState;
 78 |     }
 79 | 
 80 |     get commands() {
 81 |         return this._commands;
 82 |     }
 83 |     set commands(newCommands) {
 84 |         this._commands = newCommands;
 85 |     }
 86 | 
 87 |     createMesh() {
 88 |         const group = new THREE.Group();
 89 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 90 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 91 |         const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
 92 | 
 93 |         const baseGeo = new THREE.BoxGeometry(8, 4, 6);
 94 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 95 |         base.position.y = 2;
 96 |         group.add(base);
 97 | 
 98 |         const doorGeo = new THREE.BoxGeometry(4, 3, 0.2);
 99 |         const door = new THREE.Mesh(doorGeo, doorMaterial);
100 |         door.position.set(0, 1.5, 3.05);
101 |         group.add(door);
102 | 
103 |         const smokestackGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
104 |         const smokestack1 = new THREE.Mesh(smokestackGeo, accentMaterial);
105 |         smokestack1.position.set(-3, 5, -2);
106 |         group.add(smokestack1);
107 | 
108 |         const smokestack2 = smokestack1.clone();
109 |         smokestack2.position.set(-3, 5, 2);
110 |         group.add(smokestack2);
111 | 
112 |         return group;
113 |     }
114 | 
115 |     updateCommands(gameState) {
116 |         if (this.isUnderConstruction) {
117 |             this.commands = [];
118 |             return;
119 |         }
120 | 
121 |         const newCommands = new Array(12).fill(null);
122 | 
123 |         if (this.state === 'grounded') {
124 |             newCommands[0] = {
125 |                 command: 'train_vulture',
126 |                 hotkey: factoryHotkeys.trainVulture,
127 |                 icon: 'assets/images/train_vulture_icon.png',
128 |                 name: 'Build Vulture',
129 |                 cost: { minerals: 75, supply: 2 },
130 |                 buildTime: 25.2
131 |             };
132 |             newCommands[1] = {
133 |                 command: 'train_siege_tank',
134 |                 hotkey: factoryHotkeys.trainSiegeTank,
135 |                 icon: 'assets/images/train_siege_tank_icon.png',
136 |                 name: 'Build Siege Tank',
137 |                 cost: { minerals: 150, vespene: 100, supply: 2 },
138 |                 buildTime: 50
139 |             };
140 |             if (gameState.armoryBuilt) {
141 |                 newCommands[2] = {
142 |                     command: 'train_goliath',
143 |                     hotkey: factoryHotkeys.trainGoliath,
144 |                     icon: 'assets/images/train_goliath_icon.png',
145 |                     name: 'Build Goliath',
146 |                     cost: { minerals: 100, vespene: 50, supply: 2 },
147 |                     buildTime: 40
148 |                 };
149 |             }
150 |             
151 |             if (!gameState.upgrades.siegeModeResearched) {
152 |                 newCommands[5] = {
153 |                     command: 'research_siege_mode',
154 |                     hotkey: factoryHotkeys.researchSiegeMode,
155 |                     icon: 'assets/images/research_siege_mode_icon.png',
156 |                     name: 'Research Siege Mode',
157 |                     cost: { minerals: 150, vespene: 150 },
158 |                     researchTime: 80,
159 |                 };
160 |             }
161 |             
162 |             newCommands[8] = {
163 |                 command: 'lift_off',
164 |                 hotkey: 'L',
165 |                 icon: 'assets/images/lift_off_icon.png',
166 |                 name: 'Lift Off'
167 |             };
168 |         } else if (this.state === 'flying') {
169 |             newCommands[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
170 |             newCommands[8] = {
171 |                 command: 'land_factory',
172 |                 hotkey: 'L',
173 |                 icon: 'assets/images/lower_depot_icon.png',
174 |                 name: 'Land',
175 |                 cost: {}, // for placement system
176 |             };
177 |         }
178 | 
179 |         this.commands = newCommands;
180 |     }
181 | 
182 |     onConstructionComplete(gameState) {
183 |         this.isUnderConstruction = false;
184 |         this.currentHealth = this.maxHealth;
185 |         gameState.factoryBuilt = true;
186 |         if (typeof gameState.onFactoryBuilt === 'function') {
187 |             gameState.onFactoryBuilt();
188 |         }
189 | 
190 |         this.mesh.scale.y = 1.0;
191 |         this.mesh.traverse(child => {
192 |             if (child.isMesh && child.material.transparent === true) {
193 |                 child.material.opacity = 1.0;
194 |                 child.material.transparent = false;
195 |             }
196 |         });
197 |         this.updateCommands(gameState);
198 |     }
199 | 
200 |     getCollider() {
201 |         const flyingCollider = this.flyingBehavior.getCollider();
202 |         if (flyingCollider.isEmpty()) {
203 |             return flyingCollider;
204 |         }
205 |         return this.groundCollider;
206 |     }
207 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
208 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
209 | 
210 |     setPath(path) {
211 |         this.flyingBehavior.setPath(path);
212 |     }
213 | 
214 |     landAt(position, pathfinder) {
215 |         this.flyingBehavior.landAt(position, pathfinder);
216 |     }
217 | 
218 |     executeCommand(commandName, gameState, statusCallback) {
219 |         const command = this.commands.find(c => c && c.command === commandName);
220 |         if (!command) return;
221 | 
222 |         if (commandName.startsWith('train_')) {
223 |             if (this.state !== 'grounded') {
224 |                 statusCallback("Must be landed to train units.");
225 |                 return;
226 |             }
227 |             if (this.buildQueue.length >= 5) {
228 |                 statusCallback("Build queue is full.");
229 |                 return;
230 |             }
231 |             if (gameState.minerals < command.cost.minerals) {
232 |                 statusCallback("Not enough minerals.");
233 |                 return;
234 |             }
235 |             if (command.cost.vespene && gameState.vespene < command.cost.vespene) {
236 |                 statusCallback("Not enough vespene.");
237 |                 return;
238 |             }
239 |             if (gameState.supplyUsed + command.cost.supply > gameState.supplyCap) {
240 |                 statusCallback("Additional supply required.");
241 |                 return;
242 |             }
243 |             
244 |             gameState.minerals -= command.cost.minerals;
245 |             if(command.cost.vespene) gameState.vespene -= command.cost.vespene;
246 | 
247 |             let unitType = '';
248 |             switch(commandName) {
249 |                 case 'train_vulture': unitType = 'Vulture'; break;
250 |                 case 'train_siege_tank': unitType = 'Siege Tank'; break;
251 |                 case 'train_goliath': unitType = 'Goliath'; break;
252 |             }
253 | 
254 |             this.buildQueue.push({
255 |                 type: unitType,
256 |                 progress: 0,
257 |                 buildTime: command.buildTime,
258 |                 originalCommand: commandName,
259 |             });
260 |             statusCallback(`${unitType} training...`);
261 |             return;
262 |         }
263 | 
264 |         switch (commandName) {
265 |             case 'research_siege_mode':
266 |                 if (this.state !== 'grounded') {
267 |                     statusCallback("Must be landed to research.");
268 |                     return;
269 |                 }
270 |                 if (this.buildQueue.length > 0) {
271 |                     statusCallback("Already building or researching.");
272 |                     return;
273 |                 }
274 |                 if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
275 |                     statusCallback("Not enough resources.");
276 |                     return;
277 |                 }
278 | 
279 |                 gameState.minerals -= command.cost.minerals;
280 |                 gameState.vespene -= command.cost.vespene;
281 |                 this.buildQueue.push({
282 |                     type: 'Research',
283 |                     progress: 0,
284 |                     buildTime: command.buildTime,
285 |                     originalCommand: commandName,
286 |                 });
287 |                 statusCallback("Researching Siege Mode...");
288 |                 break;
289 |             case 'lift_off':
290 |                  if (this.flyingBehavior.liftOff()) {
291 |                      statusCallback("Lift-off sequence initiated.");
292 |                  } else {
293 |                      if (this.state !== 'grounded') statusCallback("Already airborne.");
294 |                  }
295 |                 break;
296 |         }
297 |     }
298 | 
299 |     update(delta, gameState, spawnUnitCallback) {
300 |         this.flyingBehavior.update(delta);
301 | 
302 |         if (this.isUnderConstruction) {
303 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
304 |             this.mesh.scale.y = buildProgress;
305 |             return;
306 |         }
307 | 
308 |         this.updateCommands(gameState);
309 | 
310 |         if (this.buildQueue.length > 0) {
311 |             const trainingUnit = this.buildQueue[0];
312 |             trainingUnit.progress += delta;
313 |             if (trainingUnit.progress >= trainingUnit.buildTime) {
314 |                 const finishedUnit = this.buildQueue.shift();
315 |                 if (finishedUnit.type === 'Research') {
316 |                     if (finishedUnit.originalCommand === 'research_siege_mode') {
317 |                         gameState.upgrades.siegeModeResearched = true;
318 |                     }
319 |                 } else {
320 |                     spawnUnitCallback(finishedUnit.type, this.rallyPoint.clone());
321 |                 }
322 |             }
323 |         }
324 |     }
325 | }


--------------------------------------------------------------------------------
/src/buildings/flying-building-behavior.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class FlyingBuildingBehavior {
  4 |     constructor(building, { onStateChange, hoverHeight = 5, animationDuration = 3.0, speed = 10 }) {
  5 |         this.building = building;
  6 |         this.onStateChange = onStateChange;
  7 | 
  8 |         // Flying properties
  9 |         this.state = 'grounded'; // grounded, lifting, flying, landing, movingToLand
 10 |         this.animationProgress = 0;
 11 |         this.animationDuration = animationDuration;
 12 |         this.hoverHeight = hoverHeight;
 13 |         this.path = [];
 14 |         this.currentWaypointIndex = 0;
 15 |         this.speed = speed;
 16 |         this.targetLandPosition = null;
 17 |     }
 18 | 
 19 |     liftOff() {
 20 |         if (this.state !== 'grounded') return false;
 21 |         // Cannot lift with addon
 22 |         if (this.building.addonBehavior && this.building.addonBehavior.addon) return false; 
 23 |         if (this.building.addon) return false;
 24 | 
 25 |         this.state = 'lifting';
 26 |         this.animationProgress = 0;
 27 |         this.onStateChange();
 28 |         return true;
 29 |     }
 30 | 
 31 |     landAt(position, pathfinder) {
 32 |         if (this.state !== 'flying') return;
 33 |         this.targetLandPosition = position.clone();
 34 |         this.targetLandPosition.y = this.hoverHeight;
 35 |         
 36 |         const path = pathfinder.findPath(this.building.mesh.position, this.targetLandPosition);
 37 |         this.setPath(path ? path.map(p => new THREE.Vector3(p.x, this.hoverHeight, p.z)) : [this.targetLandPosition]);
 38 | 
 39 |         this.state = 'movingToLand';
 40 |     }
 41 | 
 42 |     setPath(path) {
 43 |         if (this.state !== 'flying' && this.state !== 'movingToLand') return;
 44 |         if (path && path.length > 0) {
 45 |             this.path = path;
 46 |             this.currentWaypointIndex = 0;
 47 |         } else {
 48 |             this.path = [];
 49 |         }
 50 |     }
 51 | 
 52 |     getCollider() {
 53 |         if (this.state === 'flying' || this.state === 'lifting' || this.state === 'landing') {
 54 |             return new THREE.Box3(); // No collision when airborne
 55 |         }
 56 |         // The building itself will provide its ground collider.
 57 |         return this.building.groundCollider;
 58 |     }
 59 | 
 60 |     update(delta) {
 61 |         const leftPod = this.building.mesh.getObjectByName("leftPod");
 62 |         const rightPod = this.building.mesh.getObjectByName("rightPod");
 63 | 
 64 |         if (this.state === 'lifting') {
 65 |             this.animationProgress += delta / this.animationDuration;
 66 |             const t = Math.min(this.animationProgress, 1.0);
 67 | 
 68 |             // Animate pods retracting
 69 |             if (leftPod) leftPod.position.x = THREE.MathUtils.lerp(-5.5, -3.5, t);
 70 |             if (rightPod) rightPod.position.x = THREE.MathUtils.lerp(5.5, 3.5, t);
 71 | 
 72 |             // Animate lifting
 73 |             this.building.mesh.position.y = THREE.MathUtils.lerp(0, this.hoverHeight, t);
 74 | 
 75 |             if (this.animationProgress >= 1) {
 76 |                 this.state = 'flying';
 77 |                 this.animationProgress = 0;
 78 |                 this.onStateChange();
 79 |             }
 80 |         } else if (this.state === 'landing') {
 81 |             this.animationProgress += delta / this.animationDuration;
 82 |             const t = Math.min(this.animationProgress, 1.0);
 83 |             
 84 |             // Animate landing
 85 |             this.building.mesh.position.y = THREE.MathUtils.lerp(this.hoverHeight, 0, t);
 86 |             
 87 |             // Animate pods extending
 88 |             if (leftPod) leftPod.position.x = THREE.MathUtils.lerp(-3.5, -5.5, t);
 89 |             if (rightPod) rightPod.position.x = THREE.MathUtils.lerp(3.5, 5.5, t);
 90 | 
 91 |             if (this.animationProgress >= 1) {
 92 |                 this.state = 'grounded';
 93 |                 this.animationProgress = 0;
 94 |                 this.building.mesh.position.y = 0;
 95 |                 this.targetLandPosition = null;
 96 |                 this.onStateChange(); // Re-enable pathfinding collision
 97 |             }
 98 |         } else if (this.state === 'flying') {
 99 |             // Bobbing animation
100 |             this.animationProgress += delta * 2; // Some arbitrary speed
101 |             this.building.mesh.position.y = this.hoverHeight + Math.sin(this.animationProgress) * 0.25;
102 | 
103 |             // Movement logic
104 |             if (this.path && this.path.length > 0 && this.currentWaypointIndex < this.path.length) {
105 |                 const targetPosition = this.path[this.currentWaypointIndex];
106 |                 const distance = this.building.mesh.position.distanceTo(targetPosition);
107 | 
108 |                 if (distance < 0.5) {
109 |                     this.currentWaypointIndex++;
110 |                 } else {
111 |                     const direction = targetPosition.clone().sub(this.building.mesh.position).normalize();
112 |                     this.building.mesh.position.add(direction.multiplyScalar(this.speed * delta));
113 |                 }
114 |             }
115 |         } else if (this.state === 'movingToLand') {
116 |             // Bobbing animation
117 |             this.animationProgress += delta * 2; // Some arbitrary speed
118 |             this.building.mesh.position.y = this.hoverHeight + Math.sin(this.animationProgress) * 0.25;
119 | 
120 |             // Movement logic
121 |             if (this.path && this.path.length > 0) {
122 |                 const targetPosition = this.path[0]; // always moving to the single landing spot
123 |                 const distanceSq = this.building.mesh.position.distanceToSquared(targetPosition);
124 | 
125 |                 if (distanceSq < 0.25) { // Arrived at landing spot
126 |                     this.path = [];
127 |                     this.state = 'landing';
128 |                     this.animationProgress = 0;
129 |                 } else {
130 |                     const direction = targetPosition.clone().sub(this.building.mesh.position).normalize();
131 |                     this.building.mesh.position.add(direction.multiplyScalar(this.speed * delta));
132 |                 }
133 |             }
134 |         }
135 |     }
136 | }


--------------------------------------------------------------------------------
/src/buildings/missile-turret.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class MissileTurret {
  4 |     constructor(position, { isUnderConstruction = false, buildTime = 18.9 } = {}) {
  5 |         this.name = 'Missile Turret';
  6 |         this.portraitUrl = 'assets/images/missile_turret_portrait.png';
  7 |         this.maxHealth = 200;
  8 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
  9 |         this.selected = false;
 10 |         this.isUnderConstruction = isUnderConstruction;
 11 |         this.buildTime = buildTime;
 12 | 
 13 |         this.commands = []; // No commands
 14 | 
 15 |         this.mesh = this.createMesh();
 16 |         this.mesh.position.copy(position);
 17 | 
 18 |         this.mesh.traverse((child) => {
 19 |             if (child instanceof THREE.Mesh) {
 20 |                 child.castShadow = true;
 21 |                 child.receiveShadow = true;
 22 |                 child.userData.owner = this;
 23 |             }
 24 |         });
 25 | 
 26 |         if (this.isUnderConstruction) {
 27 |             this.mesh.scale.y = 0.01;
 28 |             this.mesh.traverse(child => {
 29 |                 if (child.isMesh) {
 30 |                     child.material = child.material.clone();
 31 |                     child.material.transparent = true;
 32 |                     child.material.opacity = 0.5;
 33 |                 }
 34 |             });
 35 |         }
 36 | 
 37 |         const selectionGeometry = new THREE.RingGeometry(1.8, 2.0, 32);
 38 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 39 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 40 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 41 |         this.selectionIndicator.position.y = 0.01;
 42 |         this.selectionIndicator.visible = false;
 43 |         this.mesh.add(this.selectionIndicator);
 44 |         
 45 |         const buildingWidth = 3;
 46 |         const buildingDepth = 3;
 47 |         const buildingHeight = 5;
 48 |         this.collider = new THREE.Box3(
 49 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 50 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 51 |         );
 52 |         this.collider.translate(this.mesh.position);
 53 |     }
 54 | 
 55 |     createMesh() {
 56 |         const group = new THREE.Group();
 57 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 58 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 59 |         
 60 |         // Base structure
 61 |         const baseGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 8);
 62 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 63 |         base.position.y = 0.25;
 64 |         group.add(base);
 65 | 
 66 |         // Tower part
 67 |         const towerGeo = new THREE.CylinderGeometry(0.8, 1, 3, 8);
 68 |         const tower = new THREE.Mesh(towerGeo, mainMaterial);
 69 |         tower.position.y = 2;
 70 |         group.add(tower);
 71 | 
 72 |         // Rotating head
 73 |         this.head = new THREE.Group();
 74 |         const headBaseGeo = new THREE.SphereGeometry(0.7, 8, 6);
 75 |         const headBase = new THREE.Mesh(headBaseGeo, accentMaterial);
 76 |         this.head.add(headBase);
 77 |         this.head.position.y = 3.5;
 78 |         group.add(this.head);
 79 | 
 80 |         // Missile Pods
 81 |         const podGeo = new THREE.BoxGeometry(0.5, 1.5, 0.5);
 82 |         const leftPod = new THREE.Mesh(podGeo, accentMaterial);
 83 |         leftPod.position.set(-0.5, 0.5, 0);
 84 |         leftPod.rotation.z = -Math.PI / 12;
 85 |         this.head.add(leftPod);
 86 | 
 87 |         const rightPod = leftPod.clone();
 88 |         rightPod.position.x = 0.5;
 89 |         rightPod.rotation.z = Math.PI / 12;
 90 |         this.head.add(rightPod);
 91 | 
 92 |         return group;
 93 |     }
 94 | 
 95 |     onConstructionComplete(gameState) {
 96 |         this.isUnderConstruction = false;
 97 |         this.currentHealth = this.maxHealth;
 98 |         this.mesh.scale.y = 1.0;
 99 |         
100 |         this.mesh.traverse(child => {
101 |             if (child.isMesh && child.material.transparent === true) {
102 |                 child.material.opacity = 1.0;
103 |                 child.material.transparent = false;
104 |             }
105 |         });
106 |     }
107 | 
108 |     getCollider() { return this.collider; }
109 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
110 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
111 |     
112 |     update(delta, gameState) {
113 |         if (this.isUnderConstruction) {
114 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
115 |             this.mesh.scale.y = buildProgress;
116 |         } else {
117 |             // Simple rotation to show it's active
118 |             if(this.head) {
119 |                 this.head.rotation.y += delta * 0.5;
120 |             }
121 |         }
122 |     }
123 | }


--------------------------------------------------------------------------------
/src/buildings/nuclear-silo.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class NuclearSilo {
  4 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4, parent = null } = {}) {
  5 |         this.name = 'Nuclear Silo';
  6 |         this.portraitUrl = 'assets/images/nuclear_silo_portrait.png';
  7 |         this.maxHealth = 1000;
  8 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
  9 |         this.selected = false;
 10 |         this.isUnderConstruction = isUnderConstruction;
 11 |         this.buildTime = buildTime;
 12 |         this.parentBuilding = parent;
 13 |         this.isAddon = true;
 14 | 
 15 |         this.hasNuke = false;
 16 |         this.isArming = false;
 17 |         this.armingProgress = 0;
 18 |         this.armingTime = 60;
 19 | 
 20 |         this.commands = [
 21 |             null, // Placeholder for alignment
 22 |             null,
 23 |             null,
 24 |             {
 25 |                 command: 'arm_nuke',
 26 |                 hotkey: 'N',
 27 |                 icon: 'assets/images/arm_nuke_icon.png',
 28 |                 name: 'Arm Nuke',
 29 |                 cost: { minerals: 200, vespene: 200, supply: 8 },
 30 |                 buildTime: this.armingTime
 31 |             }
 32 |         ];
 33 | 
 34 |         this.mesh = this.createMesh();
 35 |         this.mesh.position.copy(position);
 36 | 
 37 |         this.mesh.traverse((child) => {
 38 |             if (child.isMesh) {
 39 |                 child.castShadow = true;
 40 |                 child.receiveShadow = true;
 41 |                 child.userData.owner = this;
 42 |             }
 43 |         });
 44 |         
 45 |         const buildingWidth = 5;
 46 |         const buildingDepth = 5;
 47 |         const buildingHeight = 8;
 48 |         this.collider = new THREE.Box3(
 49 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 50 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 51 |         );
 52 |         this.collider.translate(this.mesh.position);
 53 |     }
 54 | 
 55 |     createMesh() {
 56 |         const group = new THREE.Group();
 57 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 58 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x3a4a5a, metalness: 0.8, roughness: 0.5 });
 59 |         
 60 |         const baseGeo = new THREE.BoxGeometry(5, 7, 5);
 61 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 62 |         base.position.y = 3.5;
 63 |         group.add(base);
 64 | 
 65 |         const hatchGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 16);
 66 |         const hatch = new THREE.Mesh(hatchGeo, darkMaterial);
 67 |         hatch.position.y = 7.25;
 68 |         group.add(hatch);
 69 |         
 70 |         return group;
 71 |     }
 72 | 
 73 |     getCollider() { return this.collider; }
 74 |     
 75 |     select() { 
 76 |         this.selected = true; 
 77 |         if(this.parentBuilding && !this.parentBuilding.selected) this.parentBuilding.select();
 78 |     }
 79 |     deselect(flag) { 
 80 |         this.selected = false;
 81 |         if(this.parentBuilding && this.parentBuilding.selected && !flag) this.parentBuilding.deselect(true); // pass flag to avoid feedback loop
 82 |     }
 83 |     
 84 |     executeCommand(commandName, gameState, statusCallback) {
 85 |         if (commandName === 'arm_nuke') {
 86 |             const command = this.commands.find(c => c && c.command === 'arm_nuke');
 87 |             if (this.hasNuke) {
 88 |                 statusCallback('Silo already loaded.');
 89 |                 return;
 90 |             }
 91 |             if (this.isArming) {
 92 |                 statusCallback('Nuke is already being armed.');
 93 |                 return;
 94 |             }
 95 |             if (gameState.minerals < command.cost.minerals) {
 96 |                 statusCallback('Not enough minerals.');
 97 |                 return;
 98 |             }
 99 |             if (gameState.vespene < command.cost.vespene) {
100 |                 statusCallback('Not enough vespene.');
101 |                 return;
102 |             }
103 |             if (gameState.supplyUsed + command.cost.supply > gameState.supplyCap) {
104 |                 statusCallback('Additional supply required.');
105 |                 return;
106 |             }
107 | 
108 |             gameState.minerals -= command.cost.minerals;
109 |             gameState.vespene -= command.cost.vespene;
110 |             this.isArming = true;
111 |             this.armingProgress = 0;
112 |             this.pendingSupplyCost = command.cost.supply;
113 |             statusCallback('Arming nuclear missile...');
114 |         }
115 |     }
116 | 
117 |     update(delta, gameState) {
118 |         if (this.isUnderConstruction) {
119 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
120 |             this.mesh.scale.y = buildProgress;
121 |             return;
122 |         }
123 | 
124 |         if (this.isArming) {
125 |             this.armingProgress += delta;
126 |             if (this.armingProgress >= this.armingTime) {
127 |                 this.isArming = false;
128 |                 this.hasNuke = true;
129 |                 this.armingProgress = 0;
130 |                 if (gameState && typeof this.pendingSupplyCost === 'number') {
131 |                     gameState.supplyUsed += this.pendingSupplyCost;
132 |                     this.pendingSupplyCost = 0;
133 |                 }
134 |             }
135 |         }
136 |     }
137 | }


--------------------------------------------------------------------------------
/src/buildings/physics-lab.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class PhysicsLab {
  4 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4, parent = null } = {}) {
  5 |         this.name = 'Physics Lab';
  6 |         this.portraitUrl = 'assets/images/physics_lab_portrait.png';
  7 |         this.maxHealth = 600;
  8 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
  9 |         this.selected = false;
 10 |         this.isUnderConstruction = isUnderConstruction;
 11 |         this.buildTime = buildTime;
 12 |         this.parentBuilding = parent;
 13 |         this.isAddon = true;
 14 | 
 15 |         this.buildQueue = []; // For research progress
 16 |         this.commands = []; // Research commands will be populated
 17 | 
 18 |         this.mesh = this.createMesh();
 19 |         this.mesh.position.copy(position);
 20 | 
 21 |         this.mesh.traverse((child) => {
 22 |             if (child.isMesh) {
 23 |                 child.castShadow = true;
 24 |                 child.receiveShadow = true;
 25 |                 child.userData.owner = this;
 26 |             }
 27 |         });
 28 |         
 29 |         const buildingWidth = 4;
 30 |         const buildingDepth = 4;
 31 |         const buildingHeight = 6;
 32 |         this.collider = new THREE.Box3(
 33 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 34 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 35 |         );
 36 |         this.collider.translate(this.mesh.position);
 37 |     }
 38 | 
 39 |     createMesh() {
 40 |         const group = new THREE.Group();
 41 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.6 });
 42 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.8, roughness: 0.5 });
 43 |         const glowMaterial = new THREE.MeshStandardMaterial({ color: 0x00a1ff, emissive: 0x00a1ff, emissiveIntensity: 0.7 });
 44 | 
 45 |         const baseGeo = new THREE.BoxGeometry(4, 5, 4);
 46 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
 47 |         base.position.y = 2.5;
 48 |         group.add(base);
 49 | 
 50 |         const windowGeo = new THREE.BoxGeometry(3, 2, 0.2);
 51 |         const frontWindow = new THREE.Mesh(windowGeo, glowMaterial);
 52 |         frontWindow.position.set(0, 3, 2.05);
 53 |         group.add(frontWindow);
 54 | 
 55 |         const atomCoreGeo = new THREE.SphereGeometry(0.5, 8, 8);
 56 |         this.atomCore = new THREE.Mesh(atomCoreGeo, glowMaterial);
 57 |         this.atomCore.position.y = 5.5;
 58 |         group.add(this.atomCore);
 59 |         
 60 |         this.electronPaths = new THREE.Group();
 61 |         const pathGeo = new THREE.TorusGeometry(1, 0.05, 8, 32);
 62 |         
 63 |         const path1 = new THREE.Mesh(pathGeo, accentMaterial);
 64 |         path1.rotation.x = Math.PI / 2;
 65 |         
 66 |         const path2 = path1.clone();
 67 |         path2.rotation.y = Math.PI / 2;
 68 |         
 69 |         this.electronPaths.add(path1);
 70 |         this.electronPaths.add(path2);
 71 |         this.electronPaths.position.y = 5.5;
 72 |         group.add(this.electronPaths);
 73 | 
 74 |         return group;
 75 |     }
 76 | 
 77 |     getCollider() { return this.collider; }
 78 |     
 79 |     select() { 
 80 |         this.selected = true; 
 81 |         if(this.parentBuilding && !this.parentBuilding.selected) this.parentBuilding.select();
 82 |     }
 83 |     deselect(flag) {
 84 |         this.selected = false;
 85 |         if(this.parentBuilding && this.parentBuilding.selected && !flag) this.parentBuilding.deselect(true);
 86 |     }
 87 | 
 88 |     updateCommands(gameState) {
 89 |         if (this.isUnderConstruction || this.buildQueue.length > 0) {
 90 |             this.commands = [];
 91 |             return;
 92 |         }
 93 | 
 94 |         const newCommands = new Array(12).fill(null);
 95 | 
 96 |         if (!gameState.upgrades.yamatoGun) {
 97 |             newCommands[0] = {
 98 |                 command: 'research_yamato_gun',
 99 |                 hotkey: 'Y',
100 |                 icon: 'assets/images/yamato_cannon_icon.png',
101 |                 name: 'Research Yamato Gun',
102 |                 cost: { minerals: 100, vespene: 100 },
103 |                 researchTime: 80,
104 |             };
105 |         }
106 | 
107 |         if (!gameState.upgrades.behemothReactor) {
108 |             newCommands[1] = {
109 |                 command: 'research_behemoth_reactor',
110 |                 hotkey: 'B',
111 |                 icon: 'assets/images/train_battlecruiser_icon.png',
112 |                 name: 'Research Behemoth Reactor',
113 |                 cost: { minerals: 150, vespene: 150 },
114 |                 researchTime: 80,
115 |             };
116 |         }
117 | 
118 |         this.commands = newCommands;
119 |     }
120 | 
121 |     executeCommand(commandName, gameState, statusCallback) {
122 |         const command = this.commands.find(c => c && c.command === commandName);
123 |         if (!command) return;
124 | 
125 |         if (commandName.startsWith('research_')) {
126 |             if (this.buildQueue.length > 0) {
127 |                 statusCallback('Already researching an upgrade.');
128 |                 return true;
129 |             }
130 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
131 |                 statusCallback('Not enough resources.');
132 |                 return true;
133 |             }
134 | 
135 |             gameState.minerals -= command.cost.minerals;
136 |             if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
137 | 
138 |             this.buildQueue.push({
139 |                 type: command.name,
140 |                 buildTime: command.researchTime,
141 |                 progress: 0,
142 |                 originalCommand: commandName,
143 |             });
144 | 
145 |             statusCallback(`Researching ${command.name}...`);
146 |             this.updateCommands(gameState);
147 |             return true;
148 |         }
149 |     }
150 | 
151 |     update(delta, gameState) {
152 |         if(this.electronPaths) {
153 |             this.electronPaths.rotation.y += delta * 0.5;
154 |             this.electronPaths.rotation.x += delta * 0.2;
155 |         }
156 | 
157 |         if (this.buildQueue.length > 0) {
158 |             const research = this.buildQueue[0];
159 |             research.progress += delta;
160 | 
161 |             if (research.progress >= research.buildTime) {
162 |                 const finished = this.buildQueue.shift();
163 |                 if (finished.originalCommand.includes('yamato_gun')) {
164 |                     gameState.upgrades.yamatoGun = true;
165 |                 } else if (finished.originalCommand.includes('behemoth_reactor')) {
166 |                     gameState.upgrades.behemothReactor = true;
167 |                 }
168 |                 this.updateCommands(gameState);
169 |             }
170 |         }
171 | 
172 |         if (this.buildQueue.length === 0) {
173 |             this.updateCommands(gameState);
174 |         }
175 |     }
176 | }
177 | 
178 | 


--------------------------------------------------------------------------------
/src/buildings/refinery.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class Refinery {
  4 |     constructor(position, geyser, { isUnderConstruction = false, buildTime = 25.2 } = {}) {
  5 |         this.name = 'Refinery';
  6 |         this.portraitUrl = 'assets/images/refinery_portrait.png';
  7 |         this.maxHealth = 750;
  8 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
  9 |         this.selected = false;
 10 |         this.isUnderConstruction = isUnderConstruction;
 11 |         this.buildTime = buildTime;
 12 |         
 13 |         this.geyser = geyser; // The geyser it's built on
 14 |         this.geyser.hasRefinery = true; // Mark the geyser so we don't build another one on it
 15 |         
 16 |         // Hide the original geyser visuals that would clip with the refinery
 17 |         this.geyser.gasParticles.forEach(p => p.visible = false);
 18 |         const rim = this.geyser.mesh.getObjectByName('geyser_rim');
 19 |         if (rim) {
 20 |             rim.visible = false;
 21 |         }
 22 | 
 23 |         this.commands = [];
 24 |         this.resourceType = 'vespene';
 25 | 
 26 |         this.mesh = this.createMesh();
 27 |         this.mesh.position.copy(position); // It's built ON the geyser, so same position.
 28 |         
 29 |         this.mesh.traverse((child) => {
 30 |             if (child.isMesh) {
 31 |                 child.castShadow = true;
 32 |                 child.receiveShadow = true;
 33 |                 child.userData.owner = this;
 34 |             }
 35 |         });
 36 | 
 37 |         if (this.isUnderConstruction) {
 38 |             this.mesh.scale.y = 0.01;
 39 |             this.mesh.traverse(child => {
 40 |                 if (child.isMesh) {
 41 |                     child.material = child.material.clone();
 42 |                     child.material.transparent = true;
 43 |                     child.material.opacity = 0.5;
 44 |                 }
 45 |             });
 46 |         }
 47 | 
 48 |         const selectionGeometry = new THREE.RingGeometry(2.4, 2.5, 32);
 49 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 50 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 51 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 52 |         this.selectionIndicator.position.y = 0.01;
 53 |         this.selectionIndicator.visible = false;
 54 |         this.mesh.add(this.selectionIndicator);
 55 | 
 56 |         this.collider = this.geyser.getCollider(); // Use geyser's collider
 57 |     }
 58 |     
 59 |     createMesh() {
 60 |         const group = new THREE.Group();
 61 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x8a9aaa, metalness: 0.7, roughness: 0.6 });
 62 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5 });
 63 | 
 64 |         // Main cylindrical structure
 65 |         const buildingGeo = new THREE.CylinderGeometry(2.2, 2.2, 2, 12);
 66 |         const building = new THREE.Mesh(buildingGeo, mainMaterial);
 67 |         building.position.y = 1;
 68 |         group.add(building);
 69 | 
 70 |         // Top part
 71 |         const topGeo = new THREE.CylinderGeometry(1.8, 2, 0.5, 12);
 72 |         const topPart = new THREE.Mesh(topGeo, darkMaterial);
 73 |         topPart.position.y = 2.25;
 74 |         group.add(topPart);
 75 | 
 76 |         // Central pipe going 'down'
 77 |         const pipeGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
 78 |         const pipe = new THREE.Mesh(pipeGeo, darkMaterial);
 79 |         pipe.position.y = 0.25; // Sits on top of the geyser mound
 80 |         group.add(pipe);
 81 | 
 82 |         group.traverse(child => {
 83 |             if (child.isMesh) {
 84 |                 child.castShadow = true;
 85 |                 child.receiveShadow = true;
 86 |             }
 87 |         });
 88 | 
 89 |         return group;
 90 |     }
 91 | 
 92 |     onConstructionComplete(gameState) {
 93 |         this.isUnderConstruction = false;
 94 |         this.currentHealth = this.maxHealth;
 95 |         this.mesh.scale.y = 1.0;
 96 | 
 97 |         this.mesh.traverse(child => {
 98 |             if (child.isMesh && child.material.transparent === true) {
 99 |                 child.material.opacity = 1.0;
100 |                 child.material.transparent = false;
101 |             }
102 |         });
103 |     }
104 |     
105 |     extract(amount) {
106 |         return this.geyser.extract(amount);
107 |     }
108 |     
109 |     getCollider() { return this.collider; }
110 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
111 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
112 |     
113 |     update(delta, gameState) {
114 |         if (this.isUnderConstruction) {
115 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
116 |             this.mesh.scale.y = buildProgress;
117 |         }
118 |     }
119 | 
120 |     get isDepleted() {
121 |         return this.geyser.isDepleted;
122 |     }
123 | }


--------------------------------------------------------------------------------
/src/buildings/science-facility.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { AddonBehavior } from './addon-behavior.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | /** @tweakable Hotkeys for Science Facility research commands */
  6 | const scienceFacilityHotkeys = {
  7 |     researchEmpShockwave: 'E',
  8 | };
  9 | 
 10 | export class ScienceFacility {
 11 |     constructor(position, { isUnderConstruction = false, buildTime = 60, onStateChange = () => {} } = {}) {
 12 |         this.name = 'Science Facility';
 13 |         this.portraitUrl = 'assets/images/science_facility_portrait.png';
 14 |         this.maxHealth = 850;
 15 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 16 |         this.selected = false;
 17 |         this.isUnderConstruction = isUnderConstruction;
 18 |         this.buildTime = buildTime;
 19 |         this.state = 'grounded';
 20 |         this.onStateChange = onStateChange;
 21 | 
 22 |         this.addonBehavior = new AddonBehavior(this);
 23 |         this.buildQueue = []; // For research
 24 | 
 25 |         this.mesh = this.createMesh();
 26 |         this.mesh.position.copy(position);
 27 | 
 28 |         this.mesh.traverse((child) => {
 29 |             if (child.isMesh) {
 30 |                 child.castShadow = true;
 31 |                 child.receiveShadow = true;
 32 |                 child.userData.owner = this;
 33 |             }
 34 |         });
 35 | 
 36 |         if (this.isUnderConstruction) {
 37 |             this.mesh.scale.y = 0.01;
 38 |             this.mesh.traverse(child => {
 39 |                 if (child.isMesh) {
 40 |                     child.material = child.material.clone();
 41 |                     child.material.transparent = true;
 42 |                     child.material.opacity = 0.5;
 43 |                 }
 44 |             });
 45 |         }
 46 | 
 47 |         const selectionGeometry = new THREE.RingGeometry(4.5, 4.7, 64);
 48 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 49 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 50 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 51 |         this.selectionIndicator.position.y = 0.01;
 52 |         this.selectionIndicator.visible = false;
 53 |         this.mesh.add(this.selectionIndicator);
 54 |         
 55 |         const buildingWidth = 8;
 56 |         const buildingDepth = 8;
 57 |         const buildingHeight = 6;
 58 |         this.groundCollider = new THREE.Box3(
 59 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 60 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 61 |         );
 62 |         this.groundCollider.translate(this.mesh.position);
 63 |     }
 64 | 
 65 |     get commands() {
 66 |         if (this.isUnderConstruction || this.buildQueue.length > 0) return [];
 67 |         
 68 |         const commandList = new Array(12).fill(null);
 69 |         
 70 |         // Add own research commands
 71 |         if (!this.addonBehavior.addon) {
 72 |              // Example research, can be expanded
 73 |              commandList[0] = {
 74 |                  command: 'research_emp_shockwave',
 75 |                  hotkey: scienceFacilityHotkeys.researchEmpShockwave,
 76 |                  icon: 'assets/images/emp_shockwave_icon.png',
 77 |                  name: 'Research EMP Shockwave',
 78 |                  cost: { minerals: 150, vespene: 150 },
 79 |                  researchTime: 80,
 80 |                  prereq: 'scienceFacilityBuilt' // Itself
 81 |              };
 82 |         }
 83 |         
 84 |         // Merge commands from addon behavior
 85 |         const addonCommands = this.addonBehavior.getCommands();
 86 |         addonCommands.forEach((cmd, index) => {
 87 |             if (cmd) commandList[index] = cmd;
 88 |         });
 89 | 
 90 |         return commandList;
 91 |     }
 92 | 
 93 |     createMesh() {
 94 |         try {
 95 |             const asset = assetManager.get('extra_science_facility');
 96 |             return this.createMeshFromGLB(asset);
 97 |         } catch (error) {
 98 |             const group = new THREE.Group();
 99 |             const mainMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.6 });
100 |             const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.8, roughness: 0.5 });
101 | 
102 |             const baseGeo = new THREE.BoxGeometry(8, 2, 8);
103 |             const base = new THREE.Mesh(baseGeo, accentMaterial);
104 |             base.position.y = 1;
105 |             group.add(base);
106 | 
107 |             const mainDomeGeo = new THREE.SphereGeometry(3, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
108 |             const mainDome = new THREE.Mesh(mainDomeGeo, mainMaterial);
109 |             mainDome.position.y = 2;
110 |             group.add(mainDome);
111 | 
112 |             return group;
113 |         }
114 |     }
115 | 
116 |     createMeshFromGLB(asset) {
117 |         const model = asset.scene.clone();
118 | 
119 |         const box = new THREE.Box3().setFromObject(model);
120 |         const size = box.getSize(new THREE.Vector3());
121 |         const desired = new THREE.Vector3(8, 6, 8);
122 |         const scale = Math.min(
123 |             desired.x / size.x,
124 |             desired.y / size.y,
125 |             desired.z / size.z
126 |         );
127 | 
128 |         if (scale > 0 && Number.isFinite(scale)) {
129 |             model.scale.set(scale, scale, scale);
130 |         }
131 | 
132 |         /** @tweakable additional vertical offset for the science facility model */
133 |         const modelYOffset = 0;
134 | 
135 |         // Shift the model so its lowest point aligns with the ground. Without
136 |         // this, models whose pivot is centered appear half buried.
137 |         const adjustedBox = new THREE.Box3().setFromObject(model);
138 |         model.position.y -= adjustedBox.min.y;
139 |         model.position.y += modelYOffset;
140 | 
141 |         model.traverse(child => {
142 |             if (child.isMesh) {
143 |                 child.castShadow = true;
144 |                 child.receiveShadow = true;
145 |                 child.userData.owner = this;
146 |             }
147 |         });
148 | 
149 |         return model;
150 |     }
151 | 
152 |     onConstructionComplete(gameState) {
153 |         this.isUnderConstruction = false;
154 |         this.currentHealth = this.maxHealth;
155 |         gameState.scienceFacilityBuilt = true;
156 | 
157 |         this.mesh.scale.y = 1.0;
158 |         
159 |         this.mesh.traverse(child => {
160 |             if (child.isMesh && child.material.transparent === true) {
161 |                 child.material.opacity = 1.0;
162 |                 child.material.transparent = false;
163 |             }
164 |         });
165 |         this.addonBehavior.updateCommands(gameState);
166 |     }
167 | 
168 |     getCollider() {
169 |         if (this.addonBehavior.addon) {
170 |             const facilityBox = this.groundCollider.clone();
171 |             const addonBox = this.addonBehavior.addon.getCollider();
172 |             return facilityBox.union(addonBox);
173 |         }
174 |         return this.groundCollider;
175 |     }
176 |     
177 |     select() { 
178 |         this.selected = true; 
179 |         this.selectionIndicator.visible = true;
180 |         if (this.addonBehavior.addon) {
181 |             this.addonBehavior.addon.selected = true;
182 |         }
183 |     }
184 |     
185 |     deselect(calledByAddon = false) { 
186 |         this.selected = false; 
187 |         this.selectionIndicator.visible = false;
188 |         if (this.addonBehavior.addon && !calledByAddon) {
189 |             this.addonBehavior.addon.deselect();
190 |         }
191 |     }
192 |     
193 |     executeCommand(commandName, gameState, statusCallback) {
194 |         if (this.addonBehavior.executeCommand(commandName, gameState, statusCallback)) {
195 |             return;
196 |         }
197 |         
198 |         const command = this.commands.find(c => c && c.command === commandName);
199 |         if (!command) return;
200 | 
201 |         if (commandName.startsWith('research_')) {
202 |             if (this.buildQueue.length > 0) {
203 |                 statusCallback("Already researching or building an addon.");
204 |                 return;
205 |             }
206 |             if (gameState.minerals < command.cost.minerals || (command.cost.vespene && gameState.vespene < command.cost.vespene)) {
207 |                 statusCallback("Not enough resources.");
208 |                 return;
209 |             }
210 |             gameState.minerals -= command.cost.minerals;
211 |             if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
212 | 
213 |             this.buildQueue.push({
214 |                 type: command.name,
215 |                 buildTime: command.researchTime,
216 |                 progress: 0,
217 |                 originalCommand: commandName,
218 |             });
219 |             statusCallback(`Researching ${command.name}...`);
220 |         }
221 |     }
222 |     
223 |     update(delta, gameState, spawnUnit, spawnBuilding) {
224 |         if (this.isUnderConstruction) {
225 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
226 |             this.mesh.scale.y = buildProgress;
227 |             return;
228 |         }
229 | 
230 |         this.addonBehavior.update(delta, gameState);
231 | 
232 |         if (this.buildQueue.length > 0) {
233 |             const job = this.buildQueue[0];
234 |             job.progress += delta;
235 |             if (job.progress >= job.buildTime) {
236 |                 const finishedJob = this.buildQueue.shift();
237 | 
238 |                 if (finishedJob.isAddon) {
239 |                     this.addonBehavior.completeAddonConstruction(finishedJob, spawnBuilding, gameState);
240 |                 } else { // It's a research
241 |                     if (finishedJob.originalCommand.includes('emp_shockwave')) {
242 |                         gameState.upgrades.empShockwave = true;
243 |                     }
244 |                 }
245 |             }
246 |         }
247 | 
248 |         // Update commands if state changes
249 |         const addonChanged = this.addonBehavior.addon?.name !== this._lastAddonName;
250 |         if(addonChanged || this.buildQueue.length === 0) {
251 |             this.addonBehavior.updateCommands(gameState);
252 |             this._lastAddonName = this.addonBehavior.addon?.name;
253 |         }
254 |     }
255 | }


--------------------------------------------------------------------------------
/src/buildings/starport.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { FlyingBuildingBehavior } from './flying-building-behavior.js';
  3 | import { AddonBehavior } from './addon-behavior.js';
  4 | 
  5 | /** @tweakable Hotkeys for Starport unit training commands */
  6 | const starportHotkeys = {
  7 |     trainWraith: 'R',
  8 |     trainDropship: 'T',
  9 |     trainScienceVessel: 'V',
 10 |     trainValkyrie: 'Y',
 11 |     trainBattlecruiser: 'B',
 12 | };
 13 | 
 14 | export class Starport {
 15 |     constructor(position, { isUnderConstruction = false, buildTime = 50.4, onStateChange = () => {} } = {}) {
 16 |         this.name = 'Starport';
 17 |         this.portraitUrl = 'assets/images/starport_portrait.png';
 18 |         this.maxHealth = 1300;
 19 |         this.currentHealth = isUnderConstruction ? 1 : this.maxHealth;
 20 |         this.selected = false;
 21 |         this.isUnderConstruction = isUnderConstruction;
 22 |         this.buildTime = buildTime;
 23 |         this.onStateChange = onStateChange;
 24 | 
 25 |         // Behaviors
 26 |         this.flyingBehavior = new FlyingBuildingBehavior(this, {
 27 |             onStateChange: this.onStateChange,
 28 |         });
 29 |         this.addonBehavior = new AddonBehavior(this);
 30 | 
 31 |         this._commands = [];
 32 |         this.buildQueue = [];
 33 |         this.rallyPoint = new THREE.Vector3(position.x - 7, 0, position.z);
 34 |         this.addon = null;
 35 |         this.addonToBuild = null;
 36 |         this.addonBuildProgress = 0;
 37 | 
 38 |         this.mesh = this.createMesh();
 39 |         this.mesh.position.copy(position);
 40 | 
 41 |         this.mesh.traverse((child) => {
 42 |             if (child.isMesh) {
 43 |                 child.castShadow = true;
 44 |                 child.receiveShadow = true;
 45 |                 child.userData.owner = this;
 46 |             }
 47 |         });
 48 | 
 49 |         if (this.isUnderConstruction) {
 50 |             this.mesh.scale.y = 0.01;
 51 |             this.mesh.traverse(child => {
 52 |                 if (child.isMesh) {
 53 |                     child.material = child.material.clone();
 54 |                     child.material.transparent = true;
 55 |                     child.material.opacity = 0.5;
 56 |                 }
 57 |             });
 58 |         }
 59 | 
 60 |         const selectionGeometry = new THREE.RingGeometry(5.5, 5.7, 64);
 61 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 62 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 63 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 64 |         this.selectionIndicator.position.y = 0.01;
 65 |         this.selectionIndicator.visible = false;
 66 |         this.mesh.add(this.selectionIndicator);
 67 | 
 68 |         const buildingWidth = 9;
 69 |         const buildingDepth = 9;
 70 |         const buildingHeight = 7;
 71 |         this.groundCollider = new THREE.Box3(
 72 |             new THREE.Vector3(-buildingWidth / 2, 0, -buildingDepth / 2),
 73 |             new THREE.Vector3(buildingWidth / 2, buildingHeight, buildingDepth / 2)
 74 |         );
 75 |         this.groundCollider.translate(this.mesh.position);
 76 |     }
 77 | 
 78 |     get state() {
 79 |         return this.flyingBehavior.state;
 80 |     }
 81 |     set state(newState) {
 82 |         this.flyingBehavior.state = newState;
 83 |     }
 84 | 
 85 |     get commands() {
 86 |         return this._commands;
 87 |     }
 88 |     set commands(newCommands) {
 89 |         this._commands = newCommands;
 90 |     }
 91 | 
 92 |     createMesh() {
 93 |         const group = new THREE.Group();
 94 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.7, roughness: 0.6 });
 95 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5a6a, metalness: 0.8, roughness: 0.5 });
 96 |         const padMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9, roughness: 0.4 });
 97 | 
 98 |         const baseGeo = new THREE.CylinderGeometry(4.5, 4.5, 1, 8);
 99 |         const base = new THREE.Mesh(baseGeo, mainMaterial);
100 |         base.position.y = 0.5;
101 |         group.add(base);
102 |         
103 |         const towerGeo = new THREE.BoxGeometry(3, 6, 3);
104 |         const tower = new THREE.Mesh(towerGeo, mainMaterial);
105 |         tower.position.set(-3, 3, 0);
106 |         group.add(tower);
107 | 
108 |         const landingPadGeo = new THREE.BoxGeometry(6, 0.5, 8);
109 |         const landingPad = new THREE.Mesh(landingPadGeo, padMaterial);
110 |         landingPad.position.set(2, 1.25, 0);
111 |         group.add(landingPad);
112 |         
113 |         const controlTowerTopGeo = new THREE.BoxGeometry(3.5, 1, 3.5);
114 |         const controlTowerTop = new THREE.Mesh(controlTowerTopGeo, accentMaterial);
115 |         controlTowerTop.position.set(-3, 6.5, 0);
116 |         group.add(controlTowerTop);
117 | 
118 |         return group;
119 |     }
120 | 
121 |     updateCommands(gameState) {
122 |         if (this.isUnderConstruction) {
123 |             this.commands = [];
124 |             return;
125 |         }
126 | 
127 |         const newCommands = new Array(12).fill(null);
128 | 
129 |         if (this.state === 'grounded') {
130 |             newCommands[0] = {
131 |                 command: 'train_wraith',
132 |                 hotkey: starportHotkeys.trainWraith,
133 |                 icon: 'assets/images/train_wraith_icon.png',
134 |                 name: 'Build Wraith',
135 |                 cost: { minerals: 150, vespene: 100, supply: 2 },
136 |                 buildTime: 40
137 |             };
138 |             newCommands[1] = {
139 |                 command: 'train_dropship',
140 |                 hotkey: starportHotkeys.trainDropship,
141 |                 icon: 'assets/images/train_dropship_icon.png',
142 |                 name: 'Build Dropship',
143 |                 cost: { minerals: 100, vespene: 100, supply: 2 },
144 |                 buildTime: 40
145 |             };
146 |             
147 |             if (this.addonBehavior.addon?.name === 'Control Tower') {
148 |                 newCommands[2] = {
149 |                     command: 'train_science_vessel',
150 |                     hotkey: starportHotkeys.trainScienceVessel,
151 |                     icon: 'assets/images/train_science_vessel_icon.png',
152 |                     name: 'Build Science Vessel',
153 |                     cost: { minerals: 100, vespene: 225, supply: 2 },
154 |                     buildTime: 80,
155 |                     prereq: 'scienceFacilityBuilt',
156 |                 };
157 |             }
158 |             if (this.addonBehavior.addon?.name === 'Control Tower') {
159 |                 newCommands[3] = {
160 |                     command: 'train_valkyrie',
161 |                     hotkey: starportHotkeys.trainValkyrie,
162 |                     icon: 'assets/images/train_valkyrie_icon.png',
163 |                     name: 'Build Valkyrie',
164 |                     cost: { minerals: 250, vespene: 125, supply: 3 },
165 |                     buildTime: 60
166 |                 };
167 |             }
168 | 
169 |             if (this.addonBehavior.addon?.name === 'Control Tower' && gameState.physicsLabBuilt) {
170 |                 newCommands[4] = {
171 |                     command: 'train_battlecruiser',
172 |                     hotkey: starportHotkeys.trainBattlecruiser,
173 |                     icon: 'assets/images/train_battlecruiser_icon.png',
174 |                     name: 'Build Battlecruiser',
175 |                     cost: { minerals: 400, vespene: 300, supply: 6 },
176 |                     buildTime: 133
177 |                 };
178 |             }
179 |             
180 |             const addonCommands = this.addonBehavior.getCommands();
181 |             addonCommands.forEach((cmd, index) => {
182 |                 if (cmd) newCommands[index] = cmd;
183 |             });
184 | 
185 |             newCommands[8] = {
186 |                 command: 'lift_off',
187 |                 hotkey: 'L',
188 |                 icon: 'assets/images/lift_off_icon.png',
189 |                 name: 'Lift Off'
190 |             };
191 |         } else if (this.state === 'flying') {
192 |             newCommands[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
193 |             newCommands[8] = {
194 |                 command: 'land_starport',
195 |                 hotkey: 'L',
196 |                 icon: 'assets/images/lower_depot_icon.png',
197 |                 name: 'Land',
198 |                 cost: {}, // for placement system
199 |             };
200 |         }
201 | 
202 |         this.commands = newCommands;
203 |     }
204 | 
205 |     onConstructionComplete(gameState) {
206 |         this.isUnderConstruction = false;
207 |         this.currentHealth = this.maxHealth;
208 |         gameState.starportBuilt = true;
209 | 
210 |         this.mesh.scale.y = 1.0;
211 |         this.mesh.traverse(child => {
212 |             if (child.isMesh && child.material.transparent === true) {
213 |                 child.material.opacity = 1.0;
214 |                 child.material.transparent = false;
215 |             }
216 |         });
217 |         this.addonBehavior.updateCommands(gameState);
218 |         this.updateCommands(gameState);
219 |     }
220 | 
221 |     getCollider() {
222 |         const flyingCollider = this.flyingBehavior.getCollider();
223 |         if (flyingCollider.isEmpty()) {
224 |             return flyingCollider;
225 |         }
226 |         if (this.addonBehavior.addon) {
227 |             const starportBox = this.groundCollider.clone();
228 |             const addonBox = this.addonBehavior.addon.getCollider();
229 |             return starportBox.union(addonBox);
230 |         }
231 |         return this.groundCollider;
232 |     }
233 |     select() {
234 |         this.selected = true;
235 |         this.selectionIndicator.visible = true;
236 |         if (this.addonBehavior.addon) {
237 |             this.addonBehavior.addon.selected = true;
238 |         }
239 |     }
240 |     deselect(calledByAddon = false) {
241 |         this.selected = false;
242 |         this.selectionIndicator.visible = false;
243 |         if (this.addonBehavior.addon && !calledByAddon) {
244 |             this.addonBehavior.addon.deselect();
245 |         }
246 |     }
247 | 
248 |     setPath(path) {
249 |         this.flyingBehavior.setPath(path);
250 |     }
251 | 
252 |     landAt(position, pathfinder) {
253 |         this.flyingBehavior.landAt(position, pathfinder);
254 |     }
255 | 
256 |     executeCommand(commandName, gameState, statusCallback) {
257 |         if (this.addonBehavior.executeCommand(commandName, gameState, statusCallback)) {
258 |             return;
259 |         }
260 | 
261 |         const command = this.commands.find(c => c && c.command === commandName);
262 |         if (!command) return;
263 | 
264 |         if (commandName.startsWith('train_')) {
265 |             if (this.state !== 'grounded') {
266 |                 statusCallback("Must be landed to train units.");
267 |                 return;
268 |             }
269 |             if (this.addonBehavior.isBuilding()) {
270 |                 statusCallback("Cannot train units while building an addon.");
271 |                 return;
272 |             }
273 |             if (command.prereq && !gameState[command.prereq]) {
274 |                 let prereqName = 'prerequisites';
275 |                 if (command.prereq === 'scienceFacilityBuilt') prereqName = 'Science Facility';
276 |                 else if (command.prereq === 'physicsLabBuilt') prereqName = 'Physics Lab';
277 |                 statusCallback(`Requires ${prereqName}.`);
278 |                 return;
279 |             }
280 |             if (commandName === 'train_battlecruiser' && (!this.addonBehavior.addon || this.addonBehavior.addon.name !== 'Control Tower' || !gameState.physicsLabBuilt)) {
281 |                 statusCallback("Requires Control Tower and Physics Lab.");
282 |                 return;
283 |             }
284 |             if (commandName === 'train_valkyrie' && this.addonBehavior.addon?.name !== 'Control Tower') {
285 |                 statusCallback("Requires Control Tower.");
286 |                 return;
287 |             }
288 |             if (commandName === 'train_science_vessel' && (!this.addonBehavior.addon || this.addonBehavior.addon.name !== 'Control Tower' || !gameState.scienceFacilityBuilt)) {
289 |                 statusCallback("Requires Control Tower and Science Facility.");
290 |                 return;
291 |             }
292 |             if (this.buildQueue.length >= 5) {
293 |                 statusCallback("Build queue is full.");
294 |                 return;
295 |             }
296 |             if (gameState.minerals < command.cost.minerals) {
297 |                 statusCallback("Not enough minerals.");
298 |                 return;
299 |             }
300 |             if (command.cost.vespene && gameState.vespene < command.cost.vespene) {
301 |                 statusCallback("Not enough vespene.");
302 |                 return;
303 |             }
304 |             if (gameState.supplyUsed + command.cost.supply > gameState.supplyCap) {
305 |                 statusCallback("Additional supply required.");
306 |                 return;
307 |             }
308 | 
309 |             gameState.minerals -= command.cost.minerals;
310 |             if (command.cost.vespene) gameState.vespene -= command.cost.vespene;
311 | 
312 |             const unitTypeMap = {
313 |                 'train_wraith': 'Wraith',
314 |                 'train_dropship': 'Dropship',
315 |                 'train_science_vessel': 'Science Vessel',
316 |                 'train_valkyrie': 'Valkyrie',
317 |                 'train_battlecruiser': 'Battlecruiser',
318 |             };
319 |             const unitType = unitTypeMap[commandName];
320 | 
321 |             this.buildQueue.push({
322 |                 type: unitType,
323 |                 progress: 0,
324 |                 buildTime: command.buildTime,
325 |                 originalCommand: commandName,
326 |             });
327 |             statusCallback(`${unitType} training...`);
328 |             return;
329 |         }
330 | 
331 |         switch (commandName) {
332 |             case 'lift_off':
333 |                  if (this.flyingBehavior.liftOff()) {
334 |                      statusCallback("Lift-off sequence initiated.");
335 |                  } else {
336 |                      if (this.state !== 'grounded') statusCallback("Already airborne.");
337 |                      else if (this.addonBehavior.addon) statusCallback("Cannot lift off with an addon attached.");
338 |                  }
339 |                 break;
340 |         }
341 |     }
342 | 
343 |     update(delta, gameState, spawnUnitCallback, spawnBuildingCallback) {
344 |         this.flyingBehavior.update(delta);
345 | 
346 |         if (this.isUnderConstruction) {
347 |             const buildProgress = Math.max(0.01, this.currentHealth / this.maxHealth);
348 |             this.mesh.scale.y = buildProgress;
349 |             return;
350 |         }
351 | 
352 |         this.addonBehavior.update(delta, gameState);
353 |         
354 |         // Less aggressive command updates.
355 |         const shouldUpdateCmds = !this.isUnderConstruction && 
356 |                                (this.addonBehavior.addon?.name !== this._lastAddonName || 
357 |                                 gameState.physicsLabBuilt !== this._lastPhysicsLabState ||
358 |                                 gameState.controlTowerBuilt !== this._lastControlTowerState ||
359 |                                 // Force update if build queue becomes empty
360 |                                 (this.buildQueue.length === 0 && this._lastQueueLength > 0)
361 |                                );
362 |         
363 |         if (shouldUpdateCmds) {
364 |             this.addonBehavior.updateCommands(gameState);
365 |             this.updateCommands(gameState);
366 |             this._lastAddonName = this.addonBehavior.addon?.name;
367 |             this._lastPhysicsLabState = gameState.physicsLabBuilt;
368 |             this._lastControlTowerState = gameState.controlTowerBuilt;
369 |         }
370 |         this._lastQueueLength = this.buildQueue.length;
371 | 
372 |         if (this.buildQueue.length > 0) {
373 |             const job = this.buildQueue[0];
374 |             job.progress += delta;
375 | 
376 |             if (job.progress >= job.buildTime) {
377 |                 const finishedJob = this.buildQueue.shift();
378 |                 
379 |                 if (finishedJob.isAddon) {
380 |                     this.addonBehavior.completeAddonConstruction(finishedJob, spawnBuildingCallback, gameState);
381 |                 } else {
382 |                     spawnUnitCallback(finishedJob.type, this.rallyPoint.clone());
383 |                 }
384 |             }
385 |         }
386 |     }
387 | }


--------------------------------------------------------------------------------
/src/buildings/supply-depot.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | 
  4 | export class SupplyDepot {
  5 |     constructor(position, onStateChangeCallback, { isUnderConstruction = false, buildTime = 30 } = {}) {
  6 |         this.name = 'Supply Depot';
  7 |         this.portraitUrl = 'assets/images/supply_depot_portrait.png';
  8 |         this.maxHealth = 500;
  9 |         this.currentHealth = isUnderConstruction ? 1 : 500;
 10 |         this.selected = false;
 11 |         this.isUnderConstruction = isUnderConstruction;
 12 |         this.buildTime = buildTime;
 13 | 
 14 |         // State: 'raised', 'lowered', 'animating_up', 'animating_down'
 15 |         this.state = 'raised'; 
 16 |         this.animationProgress = 0;
 17 |         /* @tweakable The time in seconds it takes for the depot to raise or lower */
 18 |         this.animationDuration = 1.0; // 1 second to raise/lower
 19 | 
 20 |         this.onStateChange = onStateChangeCallback;
 21 |         this.unitsOnTop = [];
 22 | 
 23 |         this.mesh = this.createMesh();
 24 |         this.mesh.position.copy(position);
 25 | 
 26 |         this.mesh.traverse((child) => {
 27 |             if (child.isMesh) {
 28 |                 child.castShadow = true;
 29 |                 child.receiveShadow = true;
 30 |                 child.userData.owner = this;
 31 |             }
 32 |         });
 33 | 
 34 |         if (this.isUnderConstruction) {
 35 |             this.mesh.scale.y = 0.01;
 36 |         }
 37 | 
 38 |         // Selection indicator
 39 |         const selectionGeometry = new THREE.RingGeometry(2.5, 2.7, 32);
 40 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 41 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 42 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 43 |         this.selectionIndicator.position.y = 0.01;
 44 |         this.selectionIndicator.visible = false;
 45 |         this.mesh.add(this.selectionIndicator);
 46 | 
 47 |         this.raisedCollider = new THREE.Box3(
 48 |             new THREE.Vector3(-2, 0, -2),
 49 |             new THREE.Vector3(2, 2.3, 2)
 50 |         );
 51 |     }
 52 | 
 53 |     get commands() {
 54 |         if (this.state === 'raised') {
 55 |             return [{ command: 'lower_depot', hotkey: 'L', icon: 'assets/images/lower_depot_icon.png', name: 'Lower Depot' }];
 56 |         } else if (this.state === 'lowered') {
 57 |             return [{ command: 'raise_depot', hotkey: 'R', icon: 'assets/images/raise_depot_icon.png', name: 'Raise Depot' }];
 58 |         }
 59 |         return []; // No commands while animating
 60 |     }
 61 | 
 62 |     createMesh() {
 63 |         try {
 64 |             const asset = assetManager.get('extra_supply_depot');
 65 |             return this.createMeshFromGLB(asset);
 66 |         } catch (error) {
 67 |             console.warn('Could not load supply depot model, using procedural fallback.', error);
 68 |             return this.createProceduralMesh();
 69 |         }
 70 |     }
 71 | 
 72 |     createProceduralMesh() {
 73 |         const group = new THREE.Group();
 74 |         const depotMaterial = new THREE.MeshStandardMaterial({ color: 0x7a8a9a, metalness: 0.8, roughness: 0.5 });
 75 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
 76 | 
 77 |         // Base that stays on the ground
 78 |         const baseGeo = new THREE.BoxGeometry(4, 0.1, 4);
 79 |         const base = new THREE.Mesh(baseGeo, darkMaterial);
 80 |         base.position.y = 0.05;
 81 |         group.add(base);
 82 | 
 83 |         // The part that moves
 84 |         this.movablePart = new THREE.Group();
 85 |         const wallGeo = new THREE.BoxGeometry(3.8, 2, 3.8);
 86 |         const wall = new THREE.Mesh(wallGeo, depotMaterial);
 87 |         this.movablePart.add(wall);
 88 | 
 89 |         // Add some greebles
 90 |         const greebleGeo = new THREE.BoxGeometry(0.5, 2.2, 0.5);
 91 |         const greeble1 = new THREE.Mesh(greebleGeo, darkMaterial);
 92 |         greeble1.position.set(1.6, 0, 1.6);
 93 |         this.movablePart.add(greeble1);
 94 | 
 95 |         const greeble2 = greeble1.clone();
 96 |         greeble2.position.set(-1.6, 0, 1.6);
 97 |         this.movablePart.add(greeble2);
 98 | 
 99 |         const greeble3 = greeble1.clone();
100 |         greeble3.position.set(1.6, 0, -1.6);
101 |         this.movablePart.add(greeble3);
102 | 
103 |         const greeble4 = greeble1.clone();
104 |         greeble4.position.set(-1.6, 0, -1.6);
105 |         this.movablePart.add(greeble4);
106 |         
107 |         this.movablePart.position.y = 1.2; // Raised position
108 |         group.add(this.movablePart);
109 | 
110 |         if (this.isUnderConstruction) {
111 |             group.traverse(child => {
112 |                 if (child.isMesh) {
113 |                     child.material = child.material.clone();
114 |                     child.material.transparent = true;
115 |                     child.material.opacity = 0.5;
116 |                 }
117 |             });
118 |         }
119 | 
120 |         return group;
121 |     }
122 | 
123 |     createMeshFromGLB(asset) {
124 |         const model = asset.scene.clone();
125 | 
126 |         const box = new THREE.Box3().setFromObject(model);
127 |         const size = box.getSize(new THREE.Vector3());
128 |         const desired = new THREE.Vector3(4, 2.3, 4);
129 |         const scale = Math.min(
130 |             desired.x / size.x,
131 |             desired.y / size.y,
132 |             desired.z / size.z
133 |         );
134 | 
135 |         if (scale > 0 && Number.isFinite(scale)) {
136 |             model.scale.set(scale, scale, scale);
137 |         }
138 | 
139 |         // Shift model so its base rests on the ground. Imported models may have
140 |         // an origin at the center causing them to appear half buried. Offset
141 |         // by the bounding box minimum after scaling.
142 |         const adjustedBox = new THREE.Box3().setFromObject(model);
143 |         model.position.y -= adjustedBox.min.y;
144 | 
145 |         const wrapper = new THREE.Group();
146 |         this.movablePart = wrapper; // entire model moves when raising/lowering
147 |         wrapper.add(model);
148 |         this.movablePart.position.y = 1.2; // Raised position like procedural version
149 | 
150 |         wrapper.traverse(child => {
151 |             if (child.isMesh) {
152 |                 child.castShadow = true;
153 |                 child.receiveShadow = true;
154 |                 child.userData.owner = this;
155 |             }
156 |         });
157 | 
158 |         return wrapper;
159 |     }
160 | 
161 |     getCollider() {
162 |         // When lowered or lowering, the depot has no collision for pathfinding.
163 |         if (this.state === 'lowered' || this.state === 'animating_down') {
164 |             // Return an empty box that won't register as an obstacle.
165 |             return new THREE.Box3();
166 |         }
167 |         // Raised or raising depots are full obstacles.
168 |         return this.raisedCollider.clone().translate(this.mesh.position);
169 |     }
170 | 
171 |     onConstructionComplete(gameState) {
172 |         this.isUnderConstruction = false;
173 |         this.currentHealth = this.maxHealth;
174 |         this.mesh.scale.y = 1.0;
175 | 
176 |         this.mesh.traverse(child => {
177 |             if (child.isMesh && child.material.transparent === true) {
178 |                 child.material.opacity = 1.0;
179 |                 child.material.transparent = false;
180 |             }
181 |         });
182 |         
183 |         // This is the original logic for when a depot is finished being built
184 |         gameState.supplyCap += 8;
185 |         if (this.onStateChange) {
186 |             this.onStateChange();
187 |         }
188 |     }
189 | 
190 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
191 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
192 | 
193 |     executeCommand(commandName, gameState, statusCallback) {
194 |         if (commandName === 'lower_depot' && this.state === 'raised') {
195 |             this.state = 'animating_down';
196 |             this.animationProgress = 0;
197 |             this.onStateChange(); // Update pathfinding grid immediately
198 | 
199 |         } else if (commandName === 'raise_depot' && this.state === 'lowered') {
200 |             this.state = 'animating_up';
201 |             this.animationProgress = 0;
202 |             this.onStateChange(); // Make it an obstacle immediately
203 | 
204 |             // Find and capture units on top
205 |             const footprint = new THREE.Box3().setFromCenterAndSize(this.mesh.position, new THREE.Vector3(4, 10, 4));
206 |             gameState.units.forEach(unit => {
207 |                 if (!unit.isGarrisoned && footprint.containsPoint(unit.mesh.position)) {
208 |                     unit.isStuckOnDepot = true;
209 |                     unit.stuckOnDepotInstance = this;
210 |                     this.unitsOnTop.push(unit);
211 |                 }
212 |             });
213 |         }
214 |     }
215 | 
216 |     update(delta, gameState) {
217 |         if (this.isUnderConstruction) {
218 |             const buildProgress = this.currentHealth / this.maxHealth;
219 |             this.mesh.scale.y = Math.max(0.01, buildProgress);
220 |             return; // Don't run other update logic while constructing
221 |         }
222 | 
223 |         const raisedY = 1.2;
224 |         // When the depot lowers it should only move about one unit down from its
225 |         // fully raised position. The previous value made it sink much deeper
226 |         // because the GLB's origin is centered vertically. Moving just a single
227 |         // unit keeps the top near ground level.
228 |         const loweredY = raisedY - 1.0;
229 |         const platformTopOffset = 1.1; // Top of the movable part's wall
230 | 
231 |         const updateUnitsOnTop = () => {
232 |             this.unitsOnTop.forEach(unit => {
233 |                 if (unit.isStuckOnDepot && unit.stuckOnDepotInstance === this) {
234 |                     unit.mesh.position.y = this.movablePart.position.y + platformTopOffset;
235 |                 }
236 |             });
237 |         };
238 | 
239 |         if (this.state === 'animating_down') {
240 |             this.animationProgress += delta / this.animationDuration;
241 |             this.movablePart.position.y = THREE.MathUtils.lerp(raisedY, loweredY, this.animationProgress);
242 |             updateUnitsOnTop();
243 | 
244 |             if (this.animationProgress >= 1) {
245 |                 this.movablePart.position.y = loweredY;
246 |                 this.state = 'lowered';
247 |                 this.animationProgress = 0;
248 | 
249 |                 // Release any units that were on top
250 |                 this.unitsOnTop.forEach(unit => {
251 |                     if (unit.isStuckOnDepot && unit.stuckOnDepotInstance === this) {
252 |                         unit.isStuckOnDepot = false;
253 |                         unit.stuckOnDepotInstance = null;
254 |                     }
255 |                 });
256 |                 this.unitsOnTop = [];
257 |             }
258 |         } else if (this.state === 'animating_up') {
259 |             this.animationProgress += delta / this.animationDuration;
260 |             this.movablePart.position.y = THREE.MathUtils.lerp(loweredY, raisedY, this.animationProgress);
261 |             updateUnitsOnTop();
262 |             if (this.animationProgress >= 1) {
263 |                 this.movablePart.position.y = raisedY;
264 |                 this.state = 'raised';
265 |                 this.animationProgress = 0;
266 |                 this.onStateChange(); // Update pathfinding grid after it's fully raised
267 |             }
268 |         }
269 |     }
270 | 
271 |     onBuildComplete(gameState) {
272 |         gameState.supplyCap += 8;
273 |     }
274 | }


--------------------------------------------------------------------------------
/src/game/cameraController.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | 
 3 | let camera, controls, keyState;
 4 | 
 5 | export function initCameraController(deps) {
 6 |     camera = deps.camera;
 7 |     controls = deps.controls;
 8 |     keyState = deps.keyState;
 9 | }
10 | 
11 | export function updateCamera(delta) {
12 |     const panSpeed = 25 * delta;
13 |     const rotationSpeed = 1.0 * delta; // Radians
14 | 
15 |     const forward = new THREE.Vector3();
16 |     camera.getWorldDirection(forward);
17 |     forward.y = 0;
18 |     forward.normalize();
19 | 
20 |     const right = new THREE.Vector3().crossVectors(forward, camera.up);
21 | 
22 |     const moveVector = new THREE.Vector3(0, 0, 0);
23 |     let cameraTransformed = false;
24 | 
25 |     if (keyState['KeyW'] || keyState['ArrowUp']) {
26 |         moveVector.add(forward);
27 |     }
28 |     if (keyState['KeyS'] || keyState['ArrowDown']) {
29 |         moveVector.sub(forward);
30 |     }
31 |     if (keyState['KeyA'] || keyState['ArrowLeft']) {
32 |         moveVector.sub(right);
33 |     }
34 |     if (keyState['KeyD'] || keyState['ArrowRight']) {
35 |         moveVector.add(right);
36 |     }
37 | 
38 |     if (moveVector.lengthSq() > 0) {
39 |         moveVector.normalize().multiplyScalar(panSpeed);
40 |         camera.position.add(moveVector);
41 |         controls.target.add(moveVector);
42 |         cameraTransformed = true;
43 |     }
44 | 
45 |     let rotationDirection = 0;
46 |     if (keyState['KeyQ']) {
47 |         rotationDirection += 1;
48 |     }
49 |     if (keyState['KeyE']) {
50 |         rotationDirection -= 1;
51 |     }
52 |     
53 |     if (rotationDirection !== 0) {
54 |         const angle = rotationDirection * rotationSpeed;
55 |         const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
56 |         offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
57 |         camera.position.copy(controls.target).add(offset);
58 |         cameraTransformed = true;
59 |     }
60 |     
61 |     if(cameraTransformed) {
62 |         controls.update();
63 |     }
64 | }


--------------------------------------------------------------------------------
/src/game/commandExecutor.js:
--------------------------------------------------------------------------------
  1 | import { CommandCenter } from '../buildings/command-center.js';
  2 | import { Barracks } from '../buildings/barracks.js';
  3 | import { Factory } from '../buildings/factory.js';
  4 | import { Starport } from '../buildings/starport.js';
  5 | import { EngineeringBay } from '../buildings/engineering-bay.js';
  6 | import { devLogger } from '../utils/dev-logger.js';
  7 | 
  8 | let getSelectedObjects, gameState, units, setPlacementMode, updateStatusText;
  9 | 
 10 | export function initCommandExecutor(deps) {
 11 |     getSelectedObjects = deps.getSelectedObjects;
 12 |     gameState = deps.gameState;
 13 |     units = deps.units;
 14 |     setPlacementMode = deps.setPlacementMode;
 15 |     updateStatusText = deps.updateStatusText;
 16 |     
 17 |     return executeCommand;
 18 | }
 19 | 
 20 | function executeCommand(commandName) {
 21 |     const selected = getSelectedObjects();
 22 |     if (selected.length === 0) return;
 23 |     
 24 |     devLogger.log('CommandExecutor', `Executing command: '${commandName}' for ${selected.length} object(s).`);
 25 | 
 26 |     // Use a representative object for command validation (important for mixed selections)
 27 |     const representativeObject = selected[0];
 28 |     const command = representativeObject.commands.find(c => c && c.command === commandName);
 29 | 
 30 |     if (!command) return;
 31 | 
 32 |     if (commandName.startsWith('land_')) {
 33 |         let flyingBuilding;
 34 |         if (commandName === 'land_command_center') {
 35 |             flyingBuilding = selected.find(obj => obj instanceof CommandCenter && obj.state === 'flying');
 36 |         } else if (commandName === 'land_barracks') {
 37 |             flyingBuilding = selected.find(obj => obj instanceof Barracks && obj.state === 'flying');
 38 |         } else if (commandName === 'land_factory') {
 39 |             flyingBuilding = selected.find(obj => obj instanceof Factory && obj.state === 'flying');
 40 |         } else if (commandName === 'land_starport') {
 41 |             flyingBuilding = selected.find(obj => obj instanceof Starport && obj.state === 'flying');
 42 |         } else if (commandName === 'land_engineering_bay') {
 43 |             flyingBuilding = selected.find(obj => obj instanceof EngineeringBay && obj.state === 'flying');
 44 |         }
 45 |         
 46 |         if (flyingBuilding) {
 47 |             setPlacementMode({ type: 'land', building: flyingBuilding, command });
 48 |         }
 49 |         return;
 50 |     }
 51 | 
 52 |     if (commandName.startsWith('build_')) {
 53 |         if (command.isAddon) {
 54 |             // This is an addon build, not a placement build.
 55 |             // Let the building handle it directly.
 56 |             const commandGameState = { ...gameState, units };
 57 |             selected.forEach(s => s.executeCommand(commandName, commandGameState, updateStatusText));
 58 |             return;
 59 |         }
 60 | 
 61 |         if (command.prereq && !gameState[command.prereq]) {
 62 |             let prereqName = 'prerequisites';
 63 |             if (command.prereq === 'academyBuilt') prereqName = 'Academy';
 64 |             else if (command.prereq === 'engineeringBayBuilt') prereqName = 'Engineering Bay';
 65 |             else if (command.prereq === 'barracksBuilt') prereqName = 'Barracks';
 66 |             else if (command.prereq === 'factoryBuilt') prereqName = 'Factory';
 67 |             else if (command.prereq === 'starportBuilt') prereqName = 'Starport';
 68 |             else if (command.prereq === 'scienceFacilityBuilt') prereqName = 'Science Facility';
 69 |             else if (command.prereq === 'physicsLabBuilt') prereqName = 'Physics Lab';
 70 |             else if (command.prereq === 'covertOpsBuilt') prereqName = 'Covert Ops';
 71 |             updateStatusText(`Requires ${prereqName}.`);
 72 |             return;
 73 |         }
 74 |         if (gameState.minerals < command.cost.minerals) {
 75 |             updateStatusText('Not enough minerals.');
 76 |             return;
 77 |         }
 78 |         if (command.cost.vespene && gameState.vespene < command.cost.vespene) {
 79 |             updateStatusText('Not enough vespene.');
 80 |             return;
 81 |         }
 82 |         setPlacementMode({ type: 'build', builder: representativeObject, command });
 83 |         return; // Explicitly return to avoid falling through
 84 |     }
 85 | 
 86 |     if (commandName === 'open_build_menu') {
 87 |         selected.forEach(u => { if (u.commandMode !== undefined) { u.commandMode = 'build'; } });
 88 |         return;
 89 |     }
 90 | 
 91 |     if (commandName === 'open_advanced_build_menu') {
 92 |         selected.forEach(u => { if (u.commandMode !== undefined) { u.commandMode = 'build_advanced'; } });
 93 |         return;
 94 |     }
 95 | 
 96 |     if (commandName === 'cancel_build_menu') {
 97 |         selected.forEach(u => { if (u.commandMode !== undefined) { u.commandMode = 'basic'; } });
 98 |         return;
 99 |     }
100 | 
101 |     if (typeof representativeObject.executeCommand === 'function') {
102 |         // Pass the list of all units to the command executor for potential interaction checks
103 |         const commandGameState = { ...gameState, units };
104 |         selected.forEach(s => s.executeCommand(commandName, commandGameState, updateStatusText));
105 |     }
106 | }


--------------------------------------------------------------------------------
/src/game/controls.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { getPlacementMode, attemptPlacement, cancelPlacementMode, updateGhostBuilding } from './placement.js';
  3 | import { handleSingleSelection, handleBoxSelection, getSelectedObjects, initSelection } from './selection.js';
  4 | import { handleRightClick, initRightClickHandler } from './rightClickHandler.js';
  5 | import { audioManager } from '../utils/audio.js';
  6 | 
  7 | const mouse = new THREE.Vector2();
  8 | 
  9 | let camera, scene, orbitControls, keyState;
 10 | let rendererDomElement;
 11 | 
 12 | // For drag selection
 13 | const selectionBox = document.getElementById('selection-box');
 14 | const startPoint = new THREE.Vector2();
 15 | let isDragging = false;
 16 | 
 17 | export { getSelectedObjects, handleSingleSelection, handleRightClick };
 18 | 
 19 | export function setupControls(deps) {
 20 |     camera = deps.camera;
 21 |     scene = deps.scene;
 22 |     orbitControls = deps.controls;
 23 |     keyState = deps.keyState;
 24 |     rendererDomElement = deps.renderer.domElement;
 25 |     
 26 |     initSelection({
 27 |         onSelectSound: deps.onSelectSound,
 28 |         allSelectables: deps.selectables,
 29 |         renderer: deps.renderer,
 30 |         camera: deps.camera
 31 |     });
 32 | 
 33 |     initRightClickHandler({
 34 |         camera: deps.camera,
 35 |         scene: deps.scene,
 36 |         selectables: deps.selectables,
 37 |         buildings: deps.buildings,
 38 |         mineralFields: deps.mineralFields,
 39 |         onMoveSound: deps.onMoveSound,
 40 |         createMoveIndicator: deps.createMoveIndicator,
 41 |         pathfinder: deps.pathfinder,
 42 |         updateStatusText: deps.updateStatusText,
 43 |         getSelectedObjects: getSelectedObjects
 44 |     });
 45 | 
 46 |     rendererDomElement.addEventListener('mousedown', onMouseDown);
 47 |     window.addEventListener('mousemove', onMouseMove);
 48 |     rendererDomElement.addEventListener('mouseup', onMouseUp);
 49 |     rendererDomElement.addEventListener('contextmenu', (event) => event.preventDefault());
 50 | }
 51 | 
 52 | function onMouseDown(event) {
 53 |     if (getPlacementMode()) {
 54 |         if (event.button === 0) { // Left-click for placement
 55 |             attemptPlacement(event);
 56 |         } else if (event.button === 2) { // Right-click to cancel placement
 57 |             cancelPlacementMode();
 58 |         }
 59 |         return;
 60 |     }
 61 | 
 62 |     if(event.target !== rendererDomElement) {
 63 |         isDragging = false;
 64 |         if (orbitControls) orbitControls.enabled = true;
 65 |         return;
 66 |     }
 67 | 
 68 |     if (event.button === 0) { // Left-click
 69 |         isDragging = true;
 70 |         selectionBox.style.display = 'block';
 71 |         startPoint.set(event.clientX, event.clientY);
 72 |         selectionBox.style.left = `${event.clientX}px`;
 73 |         selectionBox.style.top = `${event.clientY}px`;
 74 |         selectionBox.style.width = '0px';
 75 |         selectionBox.style.height = '0px';
 76 |         if (orbitControls) orbitControls.enabled = false;
 77 | 
 78 |     } else if (event.button === 2) { // Right-click
 79 |         if (orbitControls) orbitControls.enabled = false;
 80 |         handleRightClick(event);
 81 |     }
 82 | }
 83 | 
 84 | function onMouseMove(event) {
 85 |     if (getPlacementMode()) {
 86 |         updateGhostBuilding(event);
 87 |         return;
 88 |     }
 89 | 
 90 |     if (!isDragging) {
 91 |         return;
 92 |     };
 93 |     const ex = event.clientX;
 94 |     const ey = event.clientY;
 95 |     const x = Math.min(ex, startPoint.x);
 96 |     const y = Math.min(ey, startPoint.y);
 97 |     const width = Math.abs(ex - startPoint.x);
 98 |     const height = Math.abs(ey - startPoint.y);
 99 |     selectionBox.style.left = `${x}px`;
100 |     selectionBox.style.top = `${y}px`;
101 |     selectionBox.style.width = `${width}px`;
102 |     selectionBox.style.height = `${height}px`;
103 | }
104 | 
105 | function onMouseUp(event) {
106 |     if (isDragging) {
107 |         const dragDistance = startPoint.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
108 |         
109 |         if (dragDistance > 5) { // It was a drag
110 |             handleBoxSelection(selectionBox);
111 |         } else { // It was a click
112 |             handleSingleSelection(event);
113 |         }
114 |         
115 |         isDragging = false;
116 |         selectionBox.style.display = 'none';
117 |     }
118 |     
119 |     if (orbitControls) orbitControls.enabled = true;
120 | }
121 | 
122 | function getMousePosOnCanvas(event) {
123 |     const rect = rendererDomElement.getBoundingClientRect();
124 |     const x = event.clientX - rect.left;
125 |     const y = event.clientY - rect.top;
126 |     return { x, y, width: rect.width, height: rect.height };
127 | }
128 | 
129 | 


--------------------------------------------------------------------------------
/src/game/effects.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | let scene;
  4 | export const activeEffects = [];
  5 | const gatheringBeams = new Map();
  6 | 
  7 | export function initEffects(_scene) {
  8 |     scene = _scene;
  9 | }
 10 | 
 11 | export function createMoveIndicator(position) {
 12 |     const geometry = new THREE.RingGeometry(0.5, 0.6, 32);
 13 |     const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true });
 14 |     const indicator = new THREE.Mesh(geometry, material);
 15 | 
 16 |     indicator.position.copy(position);
 17 |     indicator.position.y += 0.02;
 18 |     indicator.rotation.x = -Math.PI / 2;
 19 | 
 20 |     scene.add(indicator);
 21 | 
 22 |     activeEffects.push({ mesh: indicator, life: 0.75, initialLife: 0.75 });
 23 | }
 24 | 
 25 | export function createScannerSweep(position) {
 26 |     const geometry = new THREE.RingGeometry(4, 4.5, 64);
 27 |     const material = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true });
 28 |     const sweep = new THREE.Mesh(geometry, material);
 29 | 
 30 |     sweep.position.copy(position);
 31 |     sweep.position.y += 0.05;
 32 |     sweep.rotation.x = -Math.PI / 2;
 33 | 
 34 |     scene.add(sweep);
 35 | 
 36 |     activeEffects.push({ mesh: sweep, life: 1.5, initialLife: 1.5 });
 37 | }
 38 | 
 39 | export function createDefensiveMatrix(position) {
 40 |     const geometry = new THREE.RingGeometry(2, 2.4, 32);
 41 |     const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true });
 42 |     const matrix = new THREE.Mesh(geometry, material);
 43 |     matrix.position.copy(position);
 44 |     matrix.position.y += 0.1;
 45 |     matrix.rotation.x = -Math.PI / 2;
 46 |     scene.add(matrix);
 47 |     activeEffects.push({ mesh: matrix, life: 3, initialLife: 3 });
 48 | }
 49 | 
 50 | export function createEMPShockwave(position) {
 51 |     const geometry = new THREE.RingGeometry(3.5, 4, 64);
 52 |     const material = new THREE.MeshBasicMaterial({ color: 0x41aeff, side: THREE.DoubleSide, transparent: true });
 53 |     const emp = new THREE.Mesh(geometry, material);
 54 |     emp.position.copy(position);
 55 |     emp.position.y += 0.05;
 56 |     emp.rotation.x = -Math.PI / 2;
 57 |     scene.add(emp);
 58 |     activeEffects.push({ mesh: emp, life: 1.5, initialLife: 1.5 });
 59 | }
 60 | 
 61 | export function createIrradiate(position) {
 62 |     const geometry = new THREE.RingGeometry(1.5, 1.9, 32);
 63 |     const material = new THREE.MeshBasicMaterial({ color: 0xffa500, side: THREE.DoubleSide, transparent: true });
 64 |     const irradiate = new THREE.Mesh(geometry, material);
 65 |     irradiate.position.copy(position);
 66 |     irradiate.position.y += 0.05;
 67 |     irradiate.rotation.x = -Math.PI / 2;
 68 |     scene.add(irradiate);
 69 |     activeEffects.push({ mesh: irradiate, life: 3, initialLife: 3 });
 70 | }
 71 | 
 72 | export function createYamatoBlast(start, target) {
 73 |     const material = new THREE.LineBasicMaterial({
 74 |         color: 0xff4500,
 75 |         transparent: true,
 76 |         opacity: 0.8,
 77 |         blending: THREE.AdditiveBlending,
 78 |     });
 79 |     const points = [start.clone(), target.clone()];
 80 |     const geometry = new THREE.BufferGeometry().setFromPoints(points);
 81 |     const beam = new THREE.Line(geometry, material);
 82 |     scene.add(beam);
 83 |     activeEffects.push({ mesh: beam, life: 0.5, initialLife: 0.5 });
 84 | }
 85 | 
 86 | export function updateGatheringEffects(units) {
 87 |     const activeUnits = new Set(units);
 88 | 
 89 |     units.forEach(unit => {
 90 |         if (unit.state === 'gathering' && unit.targetResource) {
 91 |             let beam = gatheringBeams.get(unit);
 92 |             if (!beam) {
 93 |                 const isVespene = unit.targetResource.name.includes('Vespene');
 94 |                 const material = new THREE.LineBasicMaterial({
 95 |                     color: isVespene ? 0x00ff00 : 0x41aeff,
 96 |                     transparent: true,
 97 |                     opacity: 0.7,
 98 |                     blending: THREE.AdditiveBlending
 99 |                 });
100 |                 const points = [new THREE.Vector3(), new THREE.Vector3()];
101 |                 const geometry = new THREE.BufferGeometry().setFromPoints(points);
102 |                 beam = new THREE.Line(geometry, material);
103 |                 scene.add(beam);
104 |                 gatheringBeams.set(unit, beam);
105 |             }
106 | 
107 |             const p1 = unit.mesh.position;
108 |             const p2 = unit.targetResource.mesh.position;
109 |             const positions = beam.geometry.attributes.position.array;
110 |             positions[0] = p1.x;
111 |             positions[1] = p1.y + 0.5;
112 |             positions[2] = p1.z;
113 |             positions[3] = p2.x;
114 |             positions[4] = p2.y + 1;
115 |             positions[5] = p2.z;
116 |             beam.geometry.attributes.position.needsUpdate = true;
117 |             beam.visible = true;
118 |         } else if (unit.state === 'building' && unit.buildingTarget) {
119 |             let beam = gatheringBeams.get(unit);
120 |             if (!beam) {
121 |                 const material = new THREE.LineBasicMaterial({
122 |                     color: 0xffa500,
123 |                     transparent: true,
124 |                     opacity: 0.8,
125 |                     blending: THREE.AdditiveBlending
126 |                 });
127 |                 const points = [new THREE.Vector3(), new THREE.Vector3()];
128 |                 const geometry = new THREE.BufferGeometry().setFromPoints(points);
129 |                 beam = new THREE.Line(geometry, material);
130 |                 scene.add(beam);
131 |                 gatheringBeams.set(unit, beam);
132 |             }
133 |             const p1 = unit.mesh.position;
134 |             const p2 = unit.buildingTarget.mesh.position;
135 |             const positions = beam.geometry.attributes.position.array;
136 |             positions[0] = p1.x;
137 |             positions[1] = p1.y + 0.5;
138 |             positions[2] = p1.z;
139 |             positions[3] = p2.x;
140 |             positions[4] = p2.y + unit.buildingTarget.currentHealth / unit.buildingTarget.maxHealth * 2;
141 |             positions[5] = p2.z;
142 |             beam.geometry.attributes.position.needsUpdate = true;
143 |             beam.visible = true;
144 |         } else {
145 |             if (gatheringBeams.has(unit)) {
146 |                 gatheringBeams.get(unit).visible = false;
147 |             }
148 |         }
149 |     });
150 | 
151 |     for (const unit of gatheringBeams.keys()) {
152 |         if (!activeUnits.has(unit)) {
153 |             const beam = gatheringBeams.get(unit);
154 |             scene.remove(beam);
155 |             beam.geometry.dispose();
156 |             beam.material.dispose();
157 |             gatheringBeams.delete(unit);
158 |         }
159 |     }
160 | }
161 | 
162 | export function updateActiveEffects(delta) {
163 |     for (let i = activeEffects.length - 1; i >= 0; i--) {
164 |         const effect = activeEffects[i];
165 |         effect.life -= delta;
166 |         if (effect.life <= 0) {
167 |             scene.remove(effect.mesh);
168 |             effect.mesh.geometry.dispose();
169 |             effect.mesh.material.dispose();
170 |             activeEffects.splice(i, 1);
171 |         } else {
172 |             const initial = effect.initialLife || 0.75;
173 |             effect.mesh.material.opacity = effect.life / initial;
174 |             const scale = 1.0 + (1.0 - (effect.life / initial)) * 1.5;
175 |             effect.mesh.scale.set(scale, scale, scale);
176 |         }
177 |     }
178 | }
179 | 


--------------------------------------------------------------------------------
/src/game/gameState.js:
--------------------------------------------------------------------------------
 1 | export const gameState = {
 2 |     minerals: 500,
 3 |     vespene: 250,
 4 |     supplyUsed: 0,
 5 |     supplyCap: 10,
 6 |     unitCounts: {
 7 |         scv: 0,
 8 |         scv_mark_2: 0,
 9 |     },
10 |     upgrades: {
11 |         infantryWeapons: 0,
12 |         infantryArmor: 0,
13 |         stimpack: false,
14 |         u238shells: false,
15 |         siegeModeResearched: false,
16 |         charonBoosters: false,
17 |         vehicleWeapons: 0,
18 |         vehicleArmor: 0,
19 |         shipWeapons: 0,
20 |         shipArmor: 0,
21 |         empShockwave: false,
22 |         wraithCloaking: false,
23 |         dropThrusters: false,
24 |         yamatoGun: false,
25 |         behemothReactor: false,
26 |     },
27 |     academyBuilt: false,
28 |     engineeringBayBuilt: false,
29 |     armoryBuilt: false,
30 |     barracksBuilt: false,
31 |     factoryBuilt: false,
32 |     starportBuilt: false,
33 |     scienceFacilityBuilt: false,
34 |     physicsLabBuilt: false,
35 |     controlTowerBuilt: false,
36 |     covertOpsBuilt: false,
37 |     comsatStationBuilt: false,
38 |     nuclearSiloBuilt: false,
39 |     onFactoryBuilt: null,
40 |     mapChunksUnlocked: 1,
41 | };


--------------------------------------------------------------------------------
/src/game/index.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { createPlateau } from '../utils/map-utils.js';
  3 | import { setupScene } from './setupScene.js';
  4 | import { initSpawner, spawnUnit, spawnBuilding, setPathfinder as setSpawnerPathfinder } from './spawn.js';
  5 | import { initPlacement, getPlacementMode, setPlacementMode, cancelPlacementMode, updateGhostBuilding, attemptPlacement, setPathfinder as setPlacementPathfinder } from './placement.js';
  6 | import { initEffects, createMoveIndicator } from './effects.js';
  7 | import { initLoop } from './loop.js';
  8 | import { gameState } from './gameState.js';
  9 | import { setupControls, getSelectedObjects } from './controls.js';
 10 | import { audioManager } from '../utils/audio.js';
 11 | import { assetManager } from '../utils/asset-manager.js';
 12 | import { initUI, updateStatusText, updatePlacementText, hideStartScreen, setGameRunning, isPaused } from './ui.js';
 13 | import { init as initMinimap, setMapSize as setMinimapSize } from './minimap.js';
 14 | import { preloadAssets } from './preloader.js';
 15 | import { initCameraController, updateCamera } from './cameraController.js';
 16 | import { initCommandExecutor } from './commandExecutor.js';
 17 | import { initMobileControls } from './mobileControls.js';
 18 | import { devLogger } from '../utils/dev-logger.js';
 19 | import { setupInitialState } from './initial-state.js';
 20 | import { setPathfinder as setRCHPathfinder } from './rightClickHandler.js';
 21 | import { Pathfinder } from '../utils/pathfinding.js';
 22 | 
 23 | let scene, camera, renderer, controls, pathfinder, terrainObstacles, gridHelper;
 24 | let mapWidth, mapHeight;
 25 | let loopDeps;
 26 | let units = [];
 27 | let buildings = [];
 28 | let mineralFields = [];
 29 | let vespeneGeysers = [];
 30 | let selectables = [];
 31 | let collidableObjects = [];
 32 | const keyState = {};
 33 | let gameContainer;
 34 | let devModeActive = false;
 35 | 
 36 | function openMapChunk() {
 37 | 
 38 |     const groundTexture = assetManager.get('ground');
 39 |     groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
 40 |     groundTexture.repeat.set(mapWidth / 4, mapHeight / 4);
 41 |     const material = new THREE.MeshStandardMaterial({
 42 |         map: groundTexture,
 43 |         metalness: 0.1,
 44 |         roughness: 0.9,
 45 |     });
 46 |     const geometry = new THREE.PlaneGeometry(mapWidth, mapHeight);
 47 |     const newGround = new THREE.Mesh(geometry, material);
 48 |     newGround.rotation.x = -Math.PI / 2;
 49 |     newGround.receiveShadow = true;
 50 |     newGround.name = 'ground';
 51 |     const baseX = mapWidth * gameState.mapChunksUnlocked;
 52 |     newGround.position.set(baseX, 0, 0);
 53 |     scene.add(newGround);
 54 | 
 55 |     const borderSize = 10;
 56 |     const plateauHeight = 2;
 57 | 
 58 |     function addBorderPlateau(x, z, sizeX, sizeZ, orientation, withRamp = false, isObstacle = true) {
 59 |         const { meshes, colliders } = createPlateau({
 60 |             x,
 61 |             z,
 62 |             sizeX,
 63 |             sizeZ,
 64 |             height: plateauHeight,
 65 |             orientation,
 66 |             material,
 67 |             withRamp,
 68 |             isObstacle
 69 |         });
 70 |         meshes.forEach(m => scene.add(m));
 71 |         colliders.forEach(collider => {
 72 |             const obstacle = { collider, getCollider() { return this.collider; } };
 73 |             terrainObstacles.push(obstacle);
 74 |             collidableObjects.push(obstacle);
 75 |         });
 76 |     }
 77 | 
 78 |     const northZ = mapHeight / 2 - borderSize / 2;
 79 |     const southZ = -mapHeight / 2 + borderSize / 2;
 80 |     const eastX = baseX + mapWidth / 2 - borderSize / 2;
 81 | 
 82 |     addBorderPlateau(baseX, northZ, mapWidth, borderSize, 'north', true, false);
 83 |     addBorderPlateau(baseX, southZ, mapWidth, borderSize, 'south', true, false);
 84 |     addBorderPlateau(eastX, 0, borderSize, mapHeight - 2 * borderSize, 'east');
 85 | 
 86 |     gameState.mapChunksUnlocked += 1;
 87 | 
 88 |     const newWidth = mapWidth * (gameState.mapChunksUnlocked + 1);
 89 |     pathfinder = new Pathfinder(newWidth, mapHeight, 1);
 90 |     window.pathfinder = pathfinder;
 91 |     setSpawnerPathfinder(pathfinder);
 92 |     setPlacementPathfinder(pathfinder);
 93 |     setRCHPathfinder(pathfinder);
 94 |     if (loopDeps) loopDeps.pathfinder = pathfinder;
 95 |     pathfinder.updateObstacles(collidableObjects);
 96 |     setMinimapSize(newWidth, mapHeight);
 97 | }
 98 | 
 99 | function init() {
100 |     gameContainer = document.getElementById('game-container');
101 |     
102 |     // Key listeners for dev mode and camera controls
103 |     window.addEventListener('keydown', e => {
104 |         keyState[e.code] = true; 
105 |     });
106 |     window.addEventListener('keyup', e => {
107 |         keyState[e.code] = false;
108 |     });
109 | 
110 |     const commandExecutor = initCommandExecutor({
111 |         getSelectedObjects,
112 |         gameState,
113 |         units,
114 |         setPlacementMode,
115 |         updateStatusText,
116 |     });
117 |     
118 |     initUI(commandExecutor, startGame, audioManager, () => gridHelper, () => keyState, () => camera);
119 | }
120 | 
121 | async function startGame() {
122 |     const devModeCheckbox = document.getElementById('enable-dev-mode-checkbox');
123 |     if (devModeCheckbox.checked) {
124 |         devModeActive = true;
125 |         devLogger.activate();
126 |     }
127 | 
128 |     audioManager.resumeContext();
129 | 
130 |     const loadingOverlay = document.getElementById('loading-overlay');
131 |     loadingOverlay.classList.add('visible');
132 | 
133 |     setTimeout(hideStartScreen, 100);
134 |     
135 |     await preloadAssets(audioManager);
136 |     
137 |     const sceneData = setupScene(gameContainer);
138 |     scene = sceneData.scene;
139 |     camera = sceneData.camera;
140 |     window.gameScene = scene;
141 |     window.gameCamera = camera;
142 |     renderer = sceneData.renderer;
143 |     controls = sceneData.controls;
144 |     pathfinder = sceneData.pathfinder;
145 |     window.pathfinder = pathfinder;
146 |     terrainObstacles = sceneData.terrainObstacles;
147 |     gridHelper = sceneData.gridHelper;
148 |     mapWidth = sceneData.mapWidth;
149 |     mapHeight = sceneData.mapHeight;
150 |     gameState.onFactoryBuilt = openMapChunk;
151 | 
152 |     initSpawner({ scene, units, buildings, selectables, collidableObjects, pathfinder, gameState, audioManager });
153 |     initEffects(scene);
154 | 
155 |     terrainObstacles.forEach(ob => collidableObjects.push(ob));
156 | 
157 |     setupInitialState({
158 |         scene, units, buildings, selectables, collidableObjects, mineralFields,
159 |         vespeneGeysers, gameState, pathfinder, spawnBuilding, devModeActive
160 |     });
161 | 
162 |     const commandExecutor = initCommandExecutor({
163 |         getSelectedObjects,
164 |         gameState,
165 |         units,
166 |         setPlacementMode,
167 |         updateStatusText,
168 |     });
169 | 
170 |     setupControls({
171 |         camera,
172 |         scene,
173 |         selectables,
174 |         buildings,
175 |         onSelectSound: () => audioManager.playSound('select'),
176 |         onMoveSound: () => audioManager.playSound('move', 0.7),
177 |         createMoveIndicator,
178 |         controls,
179 |         pathfinder,
180 |         updateStatusText,
181 |         keyState,
182 |         mineralFields,
183 |         renderer,
184 |     });
185 | 
186 |     initMinimap({
187 |         scene,
188 |         camera,
189 |         controls,
190 |         units,
191 |         buildings,
192 |         mineralFields,
193 |         vespeneGeysers,
194 |         mapWidth: sceneData.mapWidth,
195 |         mapHeight: sceneData.mapHeight,
196 |     });
197 |     
198 |     initPlacement({ scene, camera, renderer, vespeneGeysers, collidableObjects, pathfinder, updatePlacementText: updatePlacementText });
199 |     initCameraController({ camera, controls, keyState });
200 |     initMobileControls({ keyState, renderer, camera, scene });
201 |     
202 |     loopDeps = {
203 |         scene, camera, renderer, buildings, units, vespeneGeysers, gameState, pathfinder,
204 |         spawnUnit: spawnUnitCallback,
205 |         spawnBuilding,
206 |         updateCamera,
207 |         isPaused, // Pass the function directly, not a getter
208 |     };
209 | 
210 |     initLoop(loopDeps);
211 | 
212 |     setGameRunning(true);
213 |     audioManager.playBackgroundMusic();
214 | 
215 |     units.forEach(unit => {
216 |         if ((unit.isFlying || unit.name === 'Vulture' || unit.name === 'Probe') && unit.selectionIndicator) {
217 |             scene.add(unit.selectionIndicator);
218 |         }
219 |     });
220 | 
221 |     const mobileControlsCheckbox = document.getElementById('enable-mobile-controls-checkbox');
222 |     if (mobileControlsCheckbox.checked) {
223 |         document.getElementById('mobile-controls').classList.remove('hidden');
224 |         document.getElementById('mobile-cursor').classList.remove('hidden');
225 |         if (window.mobileControls) {
226 |             window.mobileControls.initJoystick();
227 |             window.mobileControls.initTapToSelect();
228 |         }
229 |     }
230 | 
231 |     document.body.removeEventListener('keydown', startGame);
232 | }
233 | 
234 | function spawnUnitCallback(unitType, position) {
235 |     const unit = spawnUnit(unitType, position);
236 |     if (unit && (unit.isFlying || unit.name === 'Vulture' || unit.name === 'Probe') && unit.selectionIndicator) {
237 |         scene.add(unit.selectionIndicator);
238 |     }
239 |     return unit;
240 | }
241 | 
242 | export function getMousePosOnCanvas() {
243 |     const rect = renderer.domElement.getBoundingClientRect();
244 |     const center_x = rect.left + rect.width / 2;
245 |     const center_y = rect.top + rect.height / 2;
246 |     return { x: center_x, y: center_y, width: rect.width, height: rect.height, isMobile: true };
247 | }
248 | 
249 | export { getPlacementMode, attemptPlacement, cancelPlacementMode, updateGhostBuilding } from './placement.js';
250 | 
251 | init();


--------------------------------------------------------------------------------
/src/game/initial-state.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { CommandCenter } from '../buildings/command-center.js';
  3 | import { SupplyDepot } from '../buildings/supply-depot.js';
  4 | import { MineralField } from '../resources/mineral-field.js';
  5 | import { VespeneGeyser } from '../resources/vespene-geyser.js';
  6 | import { SCV } from '../units/scv.js';
  7 | import { SCVMark2 } from '../units/scv-mark-2.js';
  8 | import { Zealot } from '../protoss/zealot.js';
  9 | import { Probe } from '../protoss/probe.js';
 10 | import { Stalker } from '../protoss/stalker.js';
 11 | import { Unit } from '../units/unit.js';
 12 | import { Firebat } from '../units/firebat.js';
 13 | import { Medic } from '../units/medic.js';
 14 | import { Ghost } from '../units/ghost.js';
 15 | import { Vulture } from '../units/vulture.js';
 16 | import { SiegeTank } from '../units/siege-tank.js';
 17 | import { Goliath } from '../units/goliath.js';
 18 | import { Wraith } from '../units/wraith.js';
 19 | import { Dropship } from '../units/dropship.js';
 20 | import { ScienceVessel } from '../units/science-vessel.js';
 21 | import { Valkyrie } from '../units/valkyrie.js';
 22 | import { Battlecruiser } from '../units/battlecruiser.js';
 23 | import { Adept } from '../protoss/adept.js';
 24 | import { Dragoon } from '../protoss/dragoon.js';
 25 | import { DarkTemplar } from '../protoss/darktemplar.js';
 26 | import { HighTemplar } from '../protoss/hightemplar.js';
 27 | 
 28 | /** @tweakable The layout for spawning all dev units on the map. */
 29 | const devUnitSpawnLayout = {
 30 |     // Spawn dev units near the southern plateau, away from lake colliders
 31 |     startPosition: new THREE.Vector3(-15, 0, -10),
 32 |     spacing: 3,
 33 |     unitsPerRow: 5,
 34 | };
 35 | 
 36 | export function setupInitialState({
 37 |     scene,
 38 |     units,
 39 |     buildings,
 40 |     selectables,
 41 |     collidableObjects,
 42 |     mineralFields,
 43 |     vespeneGeysers,
 44 |     gameState,
 45 |     pathfinder,
 46 |     spawnBuilding,
 47 |     devModeActive
 48 | }) {
 49 |     const pathfinderUpdateCallback = () => pathfinder.updateObstacles(collidableObjects);
 50 | 
 51 |     const commandCenter = new CommandCenter(new THREE.Vector3(15, 0, 15), { onStateChange: pathfinderUpdateCallback });
 52 |     scene.add(commandCenter.mesh);
 53 |     buildings.push(commandCenter);
 54 |     collidableObjects.push(commandCenter);
 55 |     selectables.push(commandCenter);
 56 |     commandCenter.addonBehavior.updateCommands(gameState);
 57 | 
 58 |     const supplyDepot = new SupplyDepot(new THREE.Vector3(20, 0, 2), pathfinderUpdateCallback);
 59 |     scene.add(supplyDepot.mesh);
 60 |     buildings.push(supplyDepot);
 61 |     collidableObjects.push(supplyDepot);
 62 |     selectables.push(supplyDepot);
 63 | 
 64 |     const mineralPositions = [
 65 |         new THREE.Vector3(20, 0, 8),
 66 |         new THREE.Vector3(23, 0, 9),
 67 |         new THREE.Vector3(26, 0, 10),
 68 |         new THREE.Vector3(28, 0, 13),
 69 |         new THREE.Vector3(28, 0, 17),
 70 |         new THREE.Vector3(26, 0, 20),
 71 |         new THREE.Vector3(23, 0, 21),
 72 |         new THREE.Vector3(20, 0, 22),
 73 |     ];
 74 | 
 75 |     mineralPositions.forEach(pos => {
 76 |         const mineralField = new MineralField(pos);
 77 |         scene.add(mineralField.mesh);
 78 |         mineralFields.push(mineralField);
 79 |         selectables.push(mineralField);
 80 |         collidableObjects.push(mineralField);
 81 |     });
 82 | 
 83 |     const geyser = new VespeneGeyser(new THREE.Vector3(15, 0, -15));
 84 |     scene.add(geyser.mesh);
 85 |     vespeneGeysers.push(geyser);
 86 |     selectables.push(geyser);
 87 |     collidableObjects.push(geyser);
 88 | 
 89 |     gameState.supplyCap += 12;
 90 | 
 91 |     if (devModeActive) {
 92 |         const barracks = spawnBuilding('build_barracks', new THREE.Vector3(0, 0, 5), { isUnderConstruction: false });
 93 |         barracks.onConstructionComplete(gameState);
 94 | 
 95 |         const academy = spawnBuilding('build_academy', new THREE.Vector3(0, 0, -5), { isUnderConstruction: false });
 96 |         academy.onConstructionComplete(gameState);
 97 |         
 98 |         const factory = spawnBuilding('build_factory', new THREE.Vector3(-10, 0, 5), { isUnderConstruction: false });
 99 |         factory.onConstructionComplete(gameState);
100 | 
101 |         const starport = spawnBuilding('build_starport', new THREE.Vector3(-10, 0, -5), { isUnderConstruction: false });
102 |         starport.onConstructionComplete(gameState);
103 | 
104 |         const devSupplyDepot = spawnBuilding('build_supply_depot', new THREE.Vector3(0, 0, 15), { isUnderConstruction: false });
105 |         devSupplyDepot.onConstructionComplete(gameState);
106 | 
107 |         const scienceFacility = spawnBuilding('build_science_facility', new THREE.Vector3(10, 0, -5), { isUnderConstruction: false });
108 |         scienceFacility.onConstructionComplete(gameState);
109 | 
110 |         const armory = spawnBuilding('build_armory', new THREE.Vector3(10, 0, 5), { isUnderConstruction: false });
111 |         armory.onConstructionComplete(gameState);
112 | 
113 |         const zealot = new Zealot(new THREE.Vector3(-15, 0, -15));
114 |         scene.add(zealot.mesh);
115 |         units.push(zealot);
116 |         selectables.push(zealot);
117 | 
118 |         const probe = new Probe(new THREE.Vector3(-15, 0, -18));
119 |         scene.add(probe.mesh);
120 |         scene.add(probe.selectionIndicator); // Probes hover, so indicator is separate
121 |         units.push(probe);
122 |         selectables.push(probe);
123 | 
124 |         const stalker = new Stalker(new THREE.Vector3(-18, 0, -15));
125 |         scene.add(stalker.mesh);
126 |         units.push(stalker);
127 |         selectables.push(stalker);
128 | 
129 |         const darkTemplar = new DarkTemplar(new THREE.Vector3(-18, 0, -18));
130 |         scene.add(darkTemplar.mesh);
131 |         units.push(darkTemplar);
132 |         selectables.push(darkTemplar);
133 | 
134 |         const dragoon = new Dragoon(new THREE.Vector3(-21, 0, -15));
135 |         scene.add(dragoon.mesh);
136 |         units.push(dragoon);
137 |         selectables.push(dragoon);
138 | 
139 |         const devUnitsToSpawn = [
140 |             Unit, Firebat, Medic, Ghost, Adept, HighTemplar,
141 |             Goliath, SiegeTank, Vulture,
142 |             Wraith, Dropship, ScienceVessel, Valkyrie, Battlecruiser
143 |         ];
144 | 
145 |         let unitIndex = 0;
146 |         devUnitsToSpawn.forEach((UnitClass) => {
147 |             const row = Math.floor(unitIndex / devUnitSpawnLayout.unitsPerRow);
148 |             const col = unitIndex % devUnitSpawnLayout.unitsPerRow;
149 | 
150 |             const pos = new THREE.Vector3(
151 |                 devUnitSpawnLayout.startPosition.x + col * devUnitSpawnLayout.spacing,
152 |                 devUnitSpawnLayout.startPosition.y,
153 |                 devUnitSpawnLayout.startPosition.z + row * devUnitSpawnLayout.spacing
154 |             );
155 | 
156 |             const unit = new UnitClass(pos);
157 |             scene.add(unit.mesh);
158 |             units.push(unit);
159 |             selectables.push(unit);
160 | 
161 |             // For units with separate ground indicators (flying, hovering)
162 |             if ((unit.isFlying || unit.name === 'Vulture') && unit.selectionIndicator) {
163 |                 scene.add(unit.selectionIndicator);
164 |             }
165 | 
166 |             unitIndex++;
167 |         });
168 | 
169 |         gameState.minerals += 1000;
170 |         gameState.vespene += 500;
171 |         
172 |         pathfinder.updateObstacles(collidableObjects);
173 |     }
174 |     
175 |     pathfinder.updateObstacles(collidableObjects);
176 | 
177 |     const scvPositions = [
178 |         new THREE.Vector3(7, 0, 14),
179 |         new THREE.Vector3(7, 0, 16),
180 |         new THREE.Vector3(5.5, 0, 14),
181 |         new THREE.Vector3(5.5, 0, 16)
182 |     ];
183 | 
184 |     scvPositions.forEach(pos => {
185 |         const scv = new SCV(pos);
186 |         scene.add(scv.mesh);
187 |         units.push(scv);
188 |         selectables.push(scv);
189 |     });
190 | 
191 |     const scvM2 = new SCVMark2(new THREE.Vector3(5.5, 0, 18));
192 |     scene.add(scvM2.mesh);
193 |     units.push(scvM2);
194 |     selectables.push(scvM2);
195 | 
196 |     gameState.supplyUsed = units.length;
197 | }


--------------------------------------------------------------------------------
/src/game/loop.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { updateUI } from './ui.js';
 3 | import { getSelectedObjects } from './controls.js';
 4 | import { updateGatheringEffects, updateActiveEffects } from './effects.js';
 5 | import { update as updateMinimap } from './minimap.js';
 6 | import { devLogger } from '../utils/dev-logger.js';
 7 | 
 8 | const clock = new THREE.Clock();
 9 | let deps;
10 | 
11 | /** @tweakable The maximum delta time allowed per frame. Helps prevent physics glitches on lag spikes. */
12 | const maxDeltaTime = 0.05;
13 | 
14 | export function initLoop(_deps) {
15 |     deps = _deps;
16 |     animate();
17 | }
18 | 
19 | function animate() {
20 |     requestAnimationFrame(animate);
21 | 
22 |     const isPaused = deps.isPaused();
23 |     if (isPaused) {
24 |         return; // Skip game logic updates if paused
25 |     }
26 | 
27 |     const delta = Math.min(clock.getDelta(), maxDeltaTime);
28 |     devLogger.log('Loop', `Frame delta: ${delta.toFixed(4)}s`);
29 |     const { scene, camera, renderer, buildings, units, vespeneGeysers, gameState, pathfinder, spawnUnit, spawnBuilding, updateCamera } = deps;
30 | 
31 |     updateCamera(delta);
32 | 
33 |     // Update unit counts in gameState for dynamic costs
34 |     gameState.unitCounts.scv = units.filter(u => u.name === 'SCV').length;
35 |     gameState.unitCounts.scv_mark_2 = units.filter(u => u.name === 'SCV Mark 2').length;
36 | 
37 |     if (buildings.length > 0 && buildings[0].update) {
38 |         buildings[0].update(delta, gameState, spawnUnit, spawnBuilding);
39 |     }
40 |     buildings.forEach(building => {
41 |         if (building.update) {
42 |             building.update(delta, gameState, spawnUnit, spawnBuilding);
43 |         }
44 |     });
45 |     vespeneGeysers.forEach(geyser => {
46 |         if (geyser.update) {
47 |             geyser.update(delta);
48 |         }
49 |     });
50 |     units.forEach(unit => {
51 |         if (!unit.isGarrisoned) {
52 |             unit.update(delta, pathfinder, gameState, buildings, scene);
53 |         }
54 |     });
55 | 
56 |     const selectedObjects = getSelectedObjects();
57 |     updateUI(selectedObjects, gameState);
58 |     updateMinimap(selectedObjects);
59 | 
60 |     updateGatheringEffects(units);
61 |     updateActiveEffects(delta);
62 | 
63 |     renderer.render(scene, camera);
64 | }


--------------------------------------------------------------------------------
/src/game/map.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { createPlateau } from '../utils/map-utils.js';
  4 | 
  5 | export function createMap(width, height) {
  6 |     const group = new THREE.Group();
  7 |     group.name = 'map_geometry';
  8 | 
  9 |     const groundTexture = assetManager.get('ground');
 10 |     groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
 11 |     groundTexture.repeat.set(width / 4, height / 4);
 12 | 
 13 |     const material = new THREE.MeshStandardMaterial({
 14 |         map: groundTexture,
 15 |         metalness: 0.1,
 16 |         roughness: 0.9,
 17 |     });
 18 | 
 19 |     const geometry = new THREE.PlaneGeometry(width, height);
 20 |     const plane = new THREE.Mesh(geometry, material);
 21 |     plane.rotation.x = -Math.PI / 2;
 22 |     plane.name = 'ground'; // For raycasting
 23 |     plane.receiveShadow = true;
 24 |     group.add(plane);
 25 | 
 26 |     const obstacles = [];
 27 | 
 28 |     // Create water material once
 29 |     const waterMaterial = new THREE.MeshStandardMaterial({
 30 |         color: 0x28598a,
 31 |         transparent: true,
 32 |         opacity: 0.85,
 33 |         roughness: 0.1,
 34 |         metalness: 0.2,
 35 |     });
 36 | 
 37 |     function addLake(shape, position, rotationY = 0) {
 38 |         const extrudeSettings = { depth: 0.2, bevelEnabled: false };
 39 |         const lakeGeom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
 40 |         // The geometry is created on XY plane, we want it on XZ
 41 |         lakeGeom.rotateX(-Math.PI / 2);
 42 |         lakeGeom.rotateY(rotationY);
 43 | 
 44 |         const lakeMesh = new THREE.Mesh(lakeGeom, waterMaterial);
 45 |         lakeMesh.position.copy(position);
 46 |         lakeMesh.receiveShadow = true;
 47 |         group.add(lakeMesh);
 48 | 
 49 |         // Create collider for pathfinding
 50 |         const boundingBox = new THREE.Box3().setFromObject(lakeMesh);
 51 |         // Adjust Y of collider to be from ground up, so units don't pathfind under it
 52 |         boundingBox.min.y = 0;
 53 |         boundingBox.max.y = 5; // some arbitrary height
 54 |         obstacles.push({
 55 |             collider: boundingBox,
 56 |             getCollider() { return this.collider; }
 57 |         });
 58 |     }
 59 | 
 60 |     // Define a lake shape
 61 |     const lakeShape = new THREE.Shape();
 62 |     lakeShape.moveTo( -12, -8 );
 63 |     lakeShape.bezierCurveTo( -12, -18, 12, -18, 12, -8 );
 64 |     lakeShape.bezierCurveTo( 12, 8, -12, 8, -12, -8 );
 65 | 
 66 |     // Add some lakes
 67 |     addLake(lakeShape, new THREE.Vector3(-30, -0.1, 0));
 68 |     addLake(lakeShape, new THREE.Vector3(40, -0.1, -25), Math.PI / 4);
 69 | 
 70 |     const borderSize = 10;
 71 |     const plateauHeight = 2;
 72 | 
 73 |     function addBorderPlateau(x, z, sizeX, sizeZ, orientation, withRamp = false, isObstacle = true) {
 74 |         const { meshes, colliders } = createPlateau({
 75 |             x,
 76 |             z,
 77 |             sizeX,
 78 |             sizeZ,
 79 |             height: plateauHeight,
 80 |             orientation,
 81 |             material,
 82 |             withRamp,
 83 |             isObstacle
 84 |         });
 85 |         meshes.forEach(m => group.add(m));
 86 |         colliders.forEach(collider => {
 87 |             obstacles.push({ collider, getCollider() { return this.collider; } });
 88 |         });
 89 |     }
 90 | 
 91 |     const northZ = height / 2 - borderSize / 2;
 92 |     const southZ = -height / 2 + borderSize / 2;
 93 |     const westX = -width / 2 + borderSize / 2;
 94 |     const eastX = width / 2 - borderSize / 2;
 95 | 
 96 |     addBorderPlateau(0, northZ, width, borderSize, 'north', true, false);
 97 |     addBorderPlateau(0, southZ, width, borderSize, 'south', true, false);
 98 |     addBorderPlateau(westX, 0, borderSize, height - 2 * borderSize, 'west');
 99 |     // The eastern edge will be left open for future expansion
100 | 
101 |     return { mesh: group, obstacles };
102 | }


--------------------------------------------------------------------------------
/src/game/minimap.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | let minimapRenderer, minimapCamera, minimapScene;
  4 | let mainCamera, mainControls, mainScene;
  5 | let units, buildings, mineralFields, vespeneGeysers;
  6 | let mapWidth, mapHeight;
  7 | 
  8 | const unitMaterial = new THREE.SpriteMaterial({ color: 0x00ff00 });
  9 | const selectedUnitMaterial = new THREE.SpriteMaterial({ color: 0xffffff });
 10 | const buildingMaterial = new THREE.SpriteMaterial({ color: 0x00ff00 });
 11 | const mineralMaterial = new THREE.SpriteMaterial({ color: 0x41aeff });
 12 | const vespeneMaterial = new THREE.SpriteMaterial({ color: 0x00ff00 });
 13 | 
 14 | const frustumLineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
 15 | let frustumLine;
 16 | 
 17 | const spritePool = [];
 18 | let activeSprites = [];
 19 | 
 20 | export function setMapSize(newWidth, newHeight) {
 21 |     mapWidth = newWidth;
 22 |     mapHeight = newHeight;
 23 |     if (minimapCamera) {
 24 |         minimapCamera.left = -mapWidth / 2;
 25 |         minimapCamera.right = mapWidth / 2;
 26 |         minimapCamera.top = mapHeight / 2;
 27 |         minimapCamera.bottom = -mapHeight / 2;
 28 |         minimapCamera.updateProjectionMatrix();
 29 |     }
 30 | }
 31 | 
 32 | export function init(deps) {
 33 |     mainCamera = deps.camera;
 34 |     mainControls = deps.controls;
 35 |     mainScene = deps.scene;
 36 |     units = deps.units;
 37 |     buildings = deps.buildings;
 38 |     mineralFields = deps.mineralFields;
 39 |     vespeneGeysers = deps.vespeneGeysers;
 40 |     mapWidth = deps.mapWidth;
 41 |     mapHeight = deps.mapHeight;
 42 | 
 43 |     const minimapContainer = document.getElementById('minimap');
 44 |     if (!minimapContainer) {
 45 |         console.error('Minimap container not found!');
 46 |         return;
 47 |     }
 48 | 
 49 |     minimapScene = new THREE.Scene();
 50 | 
 51 |     const mapObject = mainScene.getObjectByName('map_geometry');
 52 |     if (mapObject) {
 53 |         const mapClone = mapObject.clone();
 54 |         minimapScene.add(mapClone);
 55 | 
 56 |         const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
 57 |         minimapScene.add(ambientLight);
 58 |     } else {
 59 |         minimapScene.background = new THREE.Color(0x0a0a14);
 60 |     }
 61 | 
 62 |     minimapCamera = new THREE.OrthographicCamera(
 63 |         -mapWidth / 2, mapWidth / 2,
 64 |         mapHeight / 2, -mapHeight / 2,
 65 |         1, 1000
 66 |     );
 67 |     minimapCamera.position.set(0, 100, 0);
 68 |     minimapCamera.lookAt(0, 0, 0);
 69 | 
 70 |     minimapRenderer = new THREE.WebGLRenderer();
 71 |     minimapRenderer.setSize(minimapContainer.clientWidth, minimapContainer.clientHeight);
 72 |     minimapContainer.appendChild(minimapRenderer.domElement);
 73 | 
 74 |     const frustumGeometry = new THREE.BufferGeometry().setFromPoints([
 75 |         new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()
 76 |     ]);
 77 |     frustumLine = new THREE.Line(frustumGeometry, frustumLineMaterial);
 78 |     frustumLine.position.y = 5; // make it visible above map geometry
 79 |     minimapScene.add(frustumLine);
 80 | 
 81 |     minimapContainer.addEventListener('mousedown', onMinimapClick);
 82 |     minimapContainer.addEventListener('mousemove', (event) => {
 83 |         if (event.buttons === 1) { // if left mouse is down
 84 |             onMinimapClick(event);
 85 |         }
 86 |     });
 87 | }
 88 | 
 89 | function getSprite() {
 90 |     if (spritePool.length > 0) {
 91 |         const sprite = spritePool.pop();
 92 |         sprite.visible = true;
 93 |         return sprite;
 94 |     }
 95 |     const sprite = new THREE.Sprite();
 96 |     minimapScene.add(sprite);
 97 |     return sprite;
 98 | }
 99 | 
100 | function releaseSprite(sprite) {
101 |     sprite.visible = false;
102 |     spritePool.push(sprite);
103 | }
104 | 
105 | export function update(selectedObjects) {
106 |     if (!minimapRenderer) return;
107 | 
108 |     activeSprites.forEach(releaseSprite);
109 |     activeSprites = [];
110 | 
111 |     const drawSprite = (entity, material, scale = 2) => {
112 |         const sprite = getSprite();
113 |         sprite.material = material;
114 |         sprite.position.set(entity.mesh.position.x, 5, entity.mesh.position.z);
115 |         if (typeof scale === 'object') {
116 |             sprite.scale.set(scale.x, scale.z, 1);
117 |         } else {
118 |             sprite.scale.set(scale, scale, 1);
119 |         }
120 |         activeSprites.push(sprite);
121 |     };
122 | 
123 |     const selectedSet = new Set(selectedObjects);
124 | 
125 |     units.forEach(unit => {
126 |         if (!unit.isGarrisoned) {
127 |             drawSprite(unit, selectedSet.has(unit) ? selectedUnitMaterial : unitMaterial);
128 |         }
129 |     });
130 | 
131 |     buildings.forEach(building => {
132 |         const size = building.getCollider().getSize(new THREE.Vector3());
133 |         drawSprite(building, selectedSet.has(building) ? selectedUnitMaterial : buildingMaterial, size);
134 |     });
135 | 
136 |     mineralFields.forEach(field => !field.isDepleted && drawSprite(field, mineralMaterial, 4));
137 |     vespeneGeysers.forEach(geyser => !geyser.isDepleted && drawSprite(geyser, vespeneMaterial, 4));
138 | 
139 |     updateFrustum();
140 |     minimapRenderer.render(minimapScene, minimapCamera);
141 | }
142 | 
143 | const raycaster = new THREE.Raycaster();
144 | const frustumCornersNDC = [
145 |     new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1),
146 |     new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1),
147 | ];
148 | const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
149 | 
150 | function updateFrustum() {
151 |     const points = [];
152 |     frustumCornersNDC.forEach(corner => {
153 |         const vec = corner.clone().unproject(mainCamera);
154 |         raycaster.set(mainCamera.position, vec.sub(mainCamera.position).normalize());
155 |         const intersectionPoint = new THREE.Vector3();
156 |         if (raycaster.ray.intersectPlane(groundPlane, intersectionPoint)) {
157 |             points.push(intersectionPoint);
158 |         }
159 |     });
160 | 
161 |     if (points.length === 4) {
162 |         const pos = frustumLine.geometry.attributes.position.array;
163 |         for(let i=0; i<4; ++i) {
164 |             pos[i*3] = points[i].x;
165 |             pos[i*3 + 1] = 0;
166 |             pos[i*3 + 2] = points[i].z;
167 |         }
168 |         pos[12] = points[0].x;
169 |         pos[13] = 0;
170 |         pos[14] = points[0].z;
171 |         frustumLine.geometry.attributes.position.needsUpdate = true;
172 |     }
173 | }
174 | 
175 | function onMinimapClick(event) {
176 |     const rect = event.target.getBoundingClientRect();
177 |     const u = (event.clientX - rect.left) / rect.width;
178 |     const v = 1.0 - ((event.clientY - rect.top) / rect.height);
179 | 
180 |     const targetX = (u - 0.5) * mapWidth;
181 |     const targetZ = (v - 0.5) * mapHeight;
182 | 
183 |     const cameraOffset = new THREE.Vector3().subVectors(mainCamera.position, mainControls.target);
184 |     mainControls.target.set(targetX, 0, targetZ);
185 |     mainCamera.position.copy(mainControls.target).add(cameraOffset);
186 |     mainControls.update();
187 | }


--------------------------------------------------------------------------------
/src/game/mobileControls.js:
--------------------------------------------------------------------------------
  1 | import { getSelectedObjects, handleSingleSelection } from './selection.js';
  2 | import { handleRightClick } from './rightClickHandler.js';
  3 | import { getPlacementMode } from './placement.js';
  4 | 
  5 | let keyState;
  6 | let isInitialized = false;
  7 | let rendererDomElement, renderer, camera;
  8 | let commandButton;
  9 | let tapStartTime = 0;
 10 | let tapTimeout = null;
 11 | const TAP_THRESHOLD = 200; // ms for a tap
 12 | const HOLD_THRESHOLD = 500; // ms for a hold to become a command
 13 | let lastTapTime = 0;
 14 | const DOUBLE_TAP_THRESHOLD = 300; // ms for double tap
 15 | 
 16 | function initJoystick() {
 17 |     const joystickZone = document.getElementById('joystick-zone');
 18 |     if (!joystickZone) return;
 19 | 
 20 |     const options = {
 21 |         zone: joystickZone,
 22 |         mode: 'static',
 23 |         position: { left: '50%', top: '50%' },
 24 |         color: 'white',
 25 |         size: 100,
 26 |     };
 27 |     const manager = nipplejs.create(options);
 28 | 
 29 |     manager.on('move', (evt, data) => {
 30 |         const angle = data.angle.radian;
 31 |         const force = data.force;
 32 |         const threshold = 0.5;
 33 | 
 34 |         // Reset all directions
 35 |         keyState['KeyW'] = false;
 36 |         keyState['KeyS'] = false;
 37 |         keyState['KeyA'] = false;
 38 |         keyState['KeyD'] = false;
 39 | 
 40 |         if (force < threshold) return;
 41 | 
 42 |         // Determine direction based on angle
 43 |         if (angle >= Math.PI / 4 && angle < 3 * Math.PI / 4) {
 44 |             keyState['KeyW'] = true; // Up
 45 |         } else if (angle >= 3 * Math.PI / 4 && angle < 5 * Math.PI / 4) {
 46 |             keyState['KeyA'] = true; // Left
 47 |         } else if (angle >= 5 * Math.PI / 4 && angle < 7 * Math.PI / 4) {
 48 |             keyState['KeyS'] = true; // Down
 49 |         } else {
 50 |             keyState['KeyD'] = true; // Right
 51 |         }
 52 |     });
 53 | 
 54 |     manager.on('end', () => {
 55 |         // Reset all directions when joystick is released
 56 |         keyState['KeyW'] = false;
 57 |         keyState['KeyS'] = false;
 58 |         keyState['KeyA'] = false;
 59 |         keyState['KeyD'] = false;
 60 |     });
 61 | }
 62 | 
 63 | function initActionButtons() {
 64 |     // The select button is removed in favor of tap-to-select.
 65 |     // The command button is now a general-purpose action button triggered by hold.
 66 |     const selectButton = document.getElementById('select-action-button');
 67 |     if(selectButton) selectButton.remove();
 68 | 
 69 |     commandButton = document.getElementById('command-action-button');
 70 |     if (commandButton) {
 71 |         commandButton.style.display = 'none'; // Initially hidden
 72 |     }
 73 | }
 74 | 
 75 | function handleDoubleTap(event) {
 76 |     if (getSelectedObjects().length === 0) return;
 77 | 
 78 |     const touch = event.changedTouches[0];
 79 |     const rect = renderer.domElement.getBoundingClientRect();
 80 |     const eventData = {
 81 |         x: touch.clientX - rect.left,
 82 |         y: touch.clientY - rect.top,
 83 |         width: rect.width,
 84 |         height: rect.height,
 85 |         isMobile: true,
 86 |     };
 87 | 
 88 |     handleRightClick(eventData);
 89 | }
 90 | 
 91 | function handleTapStart(event) {
 92 |     event.preventDefault();
 93 |     if (event.touches.length > 1) return;
 94 | 
 95 |     tapStartTime = Date.now();
 96 |     const touch = event.touches[0];
 97 | 
 98 |     // Set a timeout for a "hold" action (right-click equivalent)
 99 |     tapTimeout = setTimeout(() => {
100 |         tapTimeout = null; // Clear the timeout ID
101 |         // This is a hold, treat as right-click/command
102 |         const centerCoords = getCenterAsEvent(renderer);
103 |         const placementMode = getPlacementMode();
104 | 
105 |         if (placementMode) {
106 |              if (window.cancelPlacementMode) window.cancelPlacementMode();
107 |         } else if (getSelectedObjects().length > 0) {
108 |             handleRightClick(centerCoords);
109 |         }
110 |     }, HOLD_THRESHOLD);
111 | 
112 |     rendererDomElement.addEventListener('touchend', handleTapEnd, { once: true });
113 |     rendererDomElement.addEventListener('touchmove', handleTouchMove, { once: true });
114 | }
115 | 
116 | function handleTouchMove(event) {
117 |     // If finger moves, it's not a tap, cancel the hold timeout.
118 |     clearTimeout(tapTimeout);
119 |     tapTimeout = null;
120 |     rendererDomElement.removeEventListener('touchend', handleTapEnd);
121 | }
122 | 
123 | function handleTapEnd(event) {
124 |     // If the hold timeout is still scheduled, it means this was a quick tap.
125 |     if (tapTimeout) {
126 |         clearTimeout(tapTimeout);
127 |         tapTimeout = null;
128 |         
129 |         const now = Date.now();
130 |         const touch = event.changedTouches[0];
131 |         const eventData = {
132 |             clientX: touch.clientX,
133 |             clientY: touch.clientY,
134 |             isMobile: true,
135 |         };
136 | 
137 |         if (now - lastTapTime < DOUBLE_TAP_THRESHOLD) {
138 |             // It's a double tap
139 |             handleDoubleTap(event);
140 |             lastTapTime = 0; // Reset to avoid triple-tap issues
141 |             return; // Don't process as a single tap
142 |         }
143 |         
144 |         // It's a single tap
145 |         lastTapTime = now;
146 | 
147 |         const placementMode = getPlacementMode();
148 |         if (placementMode) {
149 |             if (window.attemptPlacement) {
150 |                 window.attemptPlacement(eventData);
151 |             }
152 |         } else {
153 |             handleSingleSelection(eventData);
154 |         }
155 |     }
156 | }
157 | 
158 | function initTapToSelect() {
159 |     if (!rendererDomElement) return;
160 |     rendererDomElement.addEventListener('touchstart', handleTapStart, { passive: false });
161 | }
162 | 
163 | // Helper to get coordinates relative to the canvas for the controls.js handlers
164 | function getCenterAsEvent(renderer) {
165 |     const rect = renderer.domElement.getBoundingClientRect();
166 |     return {
167 |         clientX: rect.left + rect.width / 2,
168 |         clientY: rect.top + rect.height / 2,
169 |         isMobile: true, // Flag for our modified handlers
170 |         x: rect.width / 2,
171 |         y: rect.height / 2,
172 |         width: rect.width,
173 |         height: rect.height
174 |     };
175 | }
176 | 
177 | function getCenterOfCanvas(renderer) {
178 |     const rect = renderer.domElement.getBoundingClientRect();
179 |     return {
180 |         x: rect.left + rect.width / 2,
181 |         y: rect.top + rect.height / 2,
182 |     };
183 | }
184 | 
185 | export function initMobileControls(deps) {
186 |     keyState = deps.keyState;
187 |     renderer = deps.renderer;
188 |     camera = deps.camera;
189 |     rendererDomElement = renderer.domElement;
190 | 
191 |     initActionButtons();
192 | 
193 |     // Expose a function to be called after the start button is clicked
194 |     window.mobileControls = {
195 |         initJoystick: initJoystick,
196 |         initTapToSelect: initTapToSelect,
197 |     };
198 | }


--------------------------------------------------------------------------------
/src/game/placement.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { updateStatusText, updatePlacementText } from './ui.js';
  3 | import { spawnBuilding } from './spawn.js';
  4 | import { gameState } from './gameState.js';
  5 | import { getGroundMeshes } from '../utils/terrain.js';
  6 | 
  7 | let scene, camera, renderer, vespeneGeysers, collidableObjects, pathfinder;
  8 | 
  9 | export function setPathfinder(newPathfinder) {
 10 |     pathfinder = newPathfinder;
 11 | }
 12 | 
 13 | export let placementMode = null;
 14 | let ghostBuilding = null;
 15 | const ghostMaterialValid = new THREE.MeshBasicMaterial({
 16 |     color: 0x00ff00,
 17 |     transparent: true,
 18 |     opacity: 0.5,
 19 |     depthWrite: false,
 20 |     wireframe: true
 21 | });
 22 | const ghostMaterialInvalid = new THREE.MeshBasicMaterial({
 23 |     color: 0xff0000,
 24 |     transparent: true,
 25 |     opacity: 0.5,
 26 |     depthWrite: false,
 27 |     wireframe: true
 28 | });
 29 | 
 30 | export function initPlacement(opts) {
 31 |     scene = opts.scene;
 32 |     camera = opts.camera;
 33 |     renderer = opts.renderer;
 34 |     vespeneGeysers = opts.vespeneGeysers;
 35 |     collidableObjects = opts.collidableObjects;
 36 |     pathfinder = opts.pathfinder;
 37 | 
 38 |     const ghostGeometry = new THREE.BoxGeometry(1, 1, 1);
 39 |     ghostBuilding = new THREE.Mesh(ghostGeometry, ghostMaterialValid);
 40 |     ghostBuilding.visible = false;
 41 |     scene.add(ghostBuilding);
 42 | }
 43 | 
 44 | export function getPlacementMode() {
 45 |     return placementMode;
 46 | }
 47 | 
 48 | export function setPlacementMode(mode) {
 49 |     if (placementMode) {
 50 |         cancelPlacementMode();
 51 |     }
 52 | 
 53 |     placementMode = mode;
 54 |     const commandName = mode.command.command;
 55 | 
 56 |     const sizeData = {
 57 |         'build_command_center': new THREE.Vector3(13, 10, 8),
 58 |         'land_command_center': new THREE.Vector3(13, 10, 8),
 59 |         'build_supply_depot': new THREE.Vector3(4, 2.5, 4),
 60 |         'build_refinery': new THREE.Vector3(4.4, 2.5, 4.4),
 61 |         'build_barracks': new THREE.Vector3(7, 5, 7),
 62 |         'land_barracks': new THREE.Vector3(7, 5, 7),
 63 |         'build_engineering_bay': new THREE.Vector3(6, 5, 6),
 64 |         'land_engineering_bay': new THREE.Vector3(6, 5, 6),
 65 |         'build_bunker': new THREE.Vector3(4, 3, 4),
 66 |         'build_academy': new THREE.Vector3(6, 4, 6),
 67 |         'build_missile_turret': new THREE.Vector3(3, 5, 3),
 68 |         'build_factory': new THREE.Vector3(8, 6, 6),
 69 |         'land_factory': new THREE.Vector3(8, 6, 6),
 70 |         'build_starport': new THREE.Vector3(9, 7, 9),
 71 |         'land_starport': new THREE.Vector3(9, 7, 9),
 72 |         'build_armory': new THREE.Vector3(6, 5, 6),
 73 |         'build_science_facility': new THREE.Vector3(8, 6, 8),
 74 |     };
 75 | 
 76 |     const size = sizeData[commandName];
 77 |     if (!size) {
 78 |         console.warn(`No size defined for placement of ${commandName}`);
 79 |         cancelPlacementMode();
 80 |         return;
 81 |     }
 82 | 
 83 |     ghostBuilding.scale.copy(size);
 84 |     ghostBuilding.visible = true;
 85 | 
 86 |     const actionText = placementMode.type === 'land' ? 'Land' : 'Place';
 87 |     updatePlacementText(`${actionText} ${mode.command.name}. Left-click to confirm, right-click to cancel.`);
 88 | }
 89 | 
 90 | export function cancelPlacementMode() {
 91 |     placementMode = null;
 92 |     ghostBuilding.visible = false;
 93 |     updatePlacementText('');
 94 |     updateStatusText('Cancelled.');
 95 | }
 96 | 
 97 | export function updateGhostBuilding(event) {
 98 |     if (!placementMode) return;
 99 | 
100 |     const mouse = new THREE.Vector2();
101 |     const raycaster = new THREE.Raycaster();
102 |     const rect = renderer.domElement.getBoundingClientRect();
103 |     mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
104 |     mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
105 | 
106 |     raycaster.setFromCamera(mouse, camera);
107 | 
108 |     const groundMeshes = getGroundMeshes(scene);
109 |     if (groundMeshes.length > 0) {
110 |         const intersects = raycaster.intersectObjects(groundMeshes, true);
111 |         if (intersects.length > 0) {
112 |             const hit = intersects[0];
113 |             const point = hit.point;
114 |             const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
115 |             const worldNormal = hit.face.normal.clone().applyMatrix3(normalMatrix).normalize();
116 |             ghostBuilding.position.copy(point);
117 |             const placementCheckResult = checkPlacementValidity(point, placementMode.command.command, worldNormal);
118 |             ghostBuilding.material = placementCheckResult.valid ? ghostMaterialValid : ghostMaterialInvalid;
119 | 
120 |             if (placementCheckResult.valid && placementCheckResult.extraData && placementCheckResult.extraData.position) {
121 |                 ghostBuilding.position.copy(placementCheckResult.extraData.position);
122 |             }
123 |         }
124 |     }
125 | }
126 | 
127 | export function attemptPlacement(event) {
128 |     if (!placementMode) return;
129 | 
130 |     const rect = renderer.domElement.getBoundingClientRect();
131 |     const mouse = new THREE.Vector2(
132 |       ((event.clientX - rect.left) / rect.width) * 2 - 1,
133 |       -((event.clientY - rect.top) / rect.height) * 2 + 1
134 |     );
135 | 
136 |     const raycaster = new THREE.Raycaster();
137 |     raycaster.setFromCamera(mouse, camera);
138 |     const groundMeshes = getGroundMeshes(scene);
139 |     if (groundMeshes.length === 0) return;
140 | 
141 |     const intersects = raycaster.intersectObjects(groundMeshes, true);
142 |     if (intersects.length > 0) {
143 |         const hit = intersects[0];
144 |         const position = hit.point;
145 |         const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
146 |         const worldNormal = hit.face.normal.clone().applyMatrix3(normalMatrix).normalize();
147 | 
148 |         const placementCheckResult = checkPlacementValidity(position, placementMode.command.command, worldNormal);
149 |         if (placementCheckResult.valid) {
150 |             if (placementMode.type === 'land') {
151 |                 const finalPosition = placementCheckResult.extraData?.position || position;
152 |                 placementMode.building.landAt(finalPosition, pathfinder);
153 |                 updateStatusText(`${placementMode.building.name} landing sequence initiated.`);
154 |             } else { // 'build' type
155 |                 const command = placementMode.command;
156 |                 gameState.minerals -= command.cost.minerals;
157 |                 if (command.cost.vespene) {
158 |                     gameState.vespene -= command.cost.vespene;
159 |                 }
160 | 
161 |                 const extraData = placementCheckResult.extraData || {};
162 |                 const newBuilding = spawnBuilding(command.command, extraData.position || position, command.buildTime, extraData);
163 |                 placementMode.builder.build(newBuilding, pathfinder);
164 | 
165 |                 updateStatusText(`${newBuilding.name} construction started.`);
166 |             }
167 |             cancelPlacementMode();
168 |         } else {
169 |             updateStatusText(placementCheckResult.reason || 'Cannot build here.');
170 |         }
171 |     }
172 | }
173 | 
174 | function checkPlacementValidity(position, buildingCommand, normal) {
175 |     const MAX_SLOPE_COS = Math.cos(30 * Math.PI / 180);
176 |     if (normal && normal.y < MAX_SLOPE_COS) {
177 |         return { valid: false, reason: 'Terrain too steep.' };
178 |     }
179 | 
180 |     const commandToSizeMap = {
181 |         'build_command_center': new THREE.Vector3(13, 10, 8),
182 |         'land_command_center': new THREE.Vector3(13, 10, 8),
183 |         'build_supply_depot': new THREE.Vector3(4, 2.5, 4),
184 |         'build_refinery': new THREE.Vector3(4.4, 2.5, 4.4),
185 |         'build_barracks': new THREE.Vector3(7, 5, 7),
186 |         'land_barracks': new THREE.Vector3(7, 5, 7),
187 |         'build_engineering_bay': new THREE.Vector3(6, 5, 6),
188 |         'land_engineering_bay': new THREE.Vector3(6, 5, 6),
189 |         'build_bunker': new THREE.Vector3(4, 3, 4),
190 |         'build_academy': new THREE.Vector3(6, 4, 6),
191 |         'build_missile_turret': new THREE.Vector3(3, 5, 3),
192 |         'build_factory': new THREE.Vector3(8, 6, 6),
193 |         'land_factory': new THREE.Vector3(8, 6, 6),
194 |         'build_starport': new THREE.Vector3(9, 7, 9),
195 |         'land_starport': new THREE.Vector3(9, 7, 9),
196 |         'build_armory': new THREE.Vector3(6, 5, 6),
197 |         'build_science_facility': new THREE.Vector3(8, 6, 8),
198 |     };
199 | 
200 |     if (buildingCommand === 'build_refinery') {
201 |         let targetGeyser = null;
202 |         for (const geyser of vespeneGeysers) {
203 |             if (geyser.getCollider().containsPoint(position) && !geyser.hasRefinery) {
204 |                 targetGeyser = geyser;
205 |                 break;
206 |             }
207 |         }
208 |         if (targetGeyser) {
209 |             return {
210 |                 valid: true,
211 |                 extraData: {
212 |                     geyser: targetGeyser,
213 |                     position: targetGeyser.mesh.position
214 |                 }
215 |             };
216 |         } else {
217 |             return { valid: false, reason: 'Must be built on a Vespene Geyser.' };
218 |         }
219 |     }
220 | 
221 |     const buildingSize = commandToSizeMap[buildingCommand];
222 | 
223 |     if (!buildingSize) {
224 |         return { valid: false, reason: 'Unknown building.' };
225 |     }
226 | 
227 |     const tempBox = new THREE.Box3().setFromCenterAndSize(position, buildingSize);
228 | 
229 |     for (const obj of collidableObjects) {
230 |         // If we are landing a building, don't check for collision with itself.
231 |         if (placementMode && placementMode.type === 'land' && obj === placementMode.building) {
232 |             continue;
233 |         }
234 |         if (tempBox.intersectsBox(obj.getCollider())) {
235 |             return { valid: false, reason: 'Cannot build here.' };
236 |         }
237 |     }
238 |     return { valid: true };
239 | }


--------------------------------------------------------------------------------
/src/game/preloader.js:
--------------------------------------------------------------------------------
  1 | import { assetManager } from '../utils/asset-manager.js';
  2 | import { addExtraPreloadTasks } from './preloader_downloader.js';
  3 | 
  4 | export async function preloadAssets(audioManager) {
  5 |     const loadingOverlay = document.getElementById('loading-overlay');
  6 |     const loadingText = document.getElementById('loading-text');
  7 |     const progressBar = document.getElementById('loading-progress-bar');
  8 |     const tasks = [];
  9 |     tasks.push(() => assetManager.loadTexture('assets/images/starfield_texture.png', 'skybox'));
 10 |     tasks.push(() => assetManager.loadTexture('assets/images/terrain_texture.png', 'ground'));
 11 |     tasks.push(() => assetManager.loadGLB('assets/models/scv.glb', 'scv'));
 12 |     // SCV Mark 2 model is now loaded via extra-assets.json
 13 |     tasks.push(() => assetManager.loadGLB('assets/models/vulture.glb', 'vulture'));
 14 |     tasks.push(() => assetManager.loadGLB('assets/models/goliath.glb', 'goliath'));
 15 |     tasks.push(() => assetManager.loadGLB('assets/models/wraith.glb', 'wraith'));
 16 |     tasks.push(() => assetManager.loadGLB('assets/models/dropship.glb', 'dropship'));
 17 |     tasks.push(() => assetManager.loadGLB('assets/models/science_vessel.glb', 'science_vessel'));
 18 |     tasks.push(() => assetManager.loadGLB('assets/models/valkyrie.glb', 'valkyrie'));
 19 |     tasks.push(() => assetManager.loadGLB('assets/models/battlecruiser.glb', 'battlecruiser'));
 20 |     tasks.push(() => assetManager.loadGLB('assets/models/science_facility.glb', 'science_facility'));
 21 |     tasks.push(() => assetManager.loadGLB('assets/models/control_tower.glb', 'control_tower'));
 22 |     tasks.push(() => assetManager.loadGLB('assets/models/physics_lab.glb', 'physics_lab'));
 23 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/zealot.glb', 'protoss_zealot'));
 24 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/probe.glb', 'protoss_probe'));
 25 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/adept.glb', 'protoss_adept'));
 26 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/stalker.glb', 'protoss_stalker'));
 27 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/dragoon.glb', 'protoss_dragoon'));
 28 |     tasks.push(() => assetManager.loadGLB('assets/models/protoss/darktemplar.glb', 'protoss_darktemplar'));
 29 |     tasks.push(() => assetManager.loadSound('assets/audio/select.mp3', 'select'));
 30 |     tasks.push(() => assetManager.loadSound('assets/audio/move.mp3', 'move'));
 31 | 
 32 |     // Preload unit data files
 33 |     const unitDataPaths = [
 34 |         'assets/data/protoss/zealot.json',
 35 |         'assets/data/protoss/probe.json',
 36 |         'assets/data/protoss/adept.json',
 37 |         'assets/data/protoss/stalker.json',
 38 |         'assets/data/protoss/dragoon.json',
 39 |         'assets/data/protoss/darktemplar.json',
 40 |         'assets/data/protoss/hightemplar.json',
 41 |     ];
 42 |     unitDataPaths.forEach(path => {
 43 |         const name = `unit_${path.split('/').pop().replace('.json', '')}`;
 44 |         tasks.push(() => assetManager.loadJSON(path, name));
 45 |     });
 46 | 
 47 |     // Preload command card icons
 48 |     const iconPaths = [
 49 |         'assets/images/build_command_center_icon.png',
 50 |         'assets/images/build_supply_depot_icon.png',
 51 |         'assets/images/build_refinery_icon.png',
 52 |         'assets/images/build_barracks_icon.png',
 53 |         'assets/images/build_engineering_bay_icon.png',
 54 |         'assets/images/build_academy_icon.png',
 55 |         'assets/images/build_bunker_icon.png',
 56 |         'assets/images/build_missile_turret_icon.png',
 57 |         'assets/images/build_factory_icon.png',
 58 |         'assets/images/build_starport_icon.png',
 59 |         'assets/images/build_armory_icon.png',
 60 |         'assets/images/build_scv_icon.png',
 61 |         'assets/images/build_scv2_icon.png',
 62 |         'assets/images/build_science_facility_icon.png',
 63 |         'assets/images/build_control_tower_icon.png',
 64 |         'assets/images/build_physics_lab_icon.png',
 65 |         'assets/images/build_basic_structures_icon.png',
 66 |         'assets/images/build_advanced_structures_icon.png',
 67 |         'assets/images/build_comsat_station_icon.png',
 68 |         'assets/images/move_icon.png',
 69 |         'assets/images/stop_icon.png',
 70 |         'assets/images/hold_position_icon.png',
 71 |         'assets/images/patrol_icon.png',
 72 |         'assets/images/gather_icon.png',
 73 |         'assets/images/attack_icon.png',
 74 |         'assets/images/heal_icon.png',
 75 |         'assets/images/lift_off_icon.png',
 76 |         'assets/images/lower_depot_icon.png',
 77 |         'assets/images/raise_depot_icon.png',
 78 |         'assets/images/unload_all_icon.png',
 79 |         'assets/images/train_marine_icon.png',
 80 |         'assets/images/train_medic_icon.png',
 81 |         'assets/images/train_firebat_icon.png',
 82 |         'assets/images/train_vulture_icon.png',
 83 |         'assets/images/train_siege_tank_icon.png',
 84 |         'assets/images/train_goliath_icon.png',
 85 |         'assets/images/train_wraith_icon.png',
 86 |         'assets/images/train_dropship_icon.png',
 87 |         'assets/images/train_science_vessel_icon.png',
 88 |         'assets/images/train_valkyrie_icon.png',
 89 |         'assets/images/train_battlecruiser_icon.png',
 90 |         'assets/images/upgrade_infantry_weapons_icon.png',
 91 |         'assets/images/upgrade_infantry_armor_icon.png',
 92 |         'assets/images/stim_pack_icon.png',
 93 |         'assets/images/u238_shells_icon.png',
 94 |         'assets/images/siege_mode_icon.png',
 95 |         'assets/images/tank_mode_icon.png',
 96 |         'assets/images/research_siege_mode_icon.png',
 97 |         'assets/images/charon_boosters_icon.png',
 98 |         'assets/images/scanner_sweep_icon.png',
 99 |         'assets/images/arm_nuke_icon.png',
100 |         'assets/images/yamato_cannon_icon.png',
101 |         'assets/images/defensive_matrix_icon.png',
102 |         'assets/images/emp_shockwave_icon.png',
103 |         'assets/images/irradiate_icon.png',
104 |         'assets/images/cloak_icon.png',
105 |         'assets/images/lockdown_icon.png',
106 |         'assets/images/nuke_strike_icon.png',
107 |         'assets/images/train_ghost_icon.png',
108 |         'assets/images/protoss/train_zealot_icon.png',
109 |         'assets/images/protoss/train_probe_icon.png',
110 |         'assets/images/protoss/train_adept_icon.png',
111 |         'assets/images/protoss/train_stalker_icon.png',
112 |         'assets/images/protoss/train_dragoon_icon.png',
113 |         'assets/images/protoss/train_darktemplar_icon.png',
114 |     ];
115 | 
116 |     iconPaths.forEach(path => {
117 |         const name = path.split('/').pop().replace('.png', '');
118 |         tasks.push(() => assetManager.loadImage(path, name));
119 |     });
120 | 
121 |     // Preload portraits
122 |     const portraitPaths = [
123 |         'assets/images/wraith_portrait.png',
124 |         'assets/images/dropship_portrait.png',
125 |         'assets/images/science_vessel_portrait.png',
126 |         'assets/images/valkyrie_portrait.png',
127 |         'assets/images/battlecruiser_portrait.png',
128 |         'assets/images/science_facility_portrait.png',
129 |         'assets/images/control_tower_portrait.png',
130 |         'assets/images/physics_lab_portrait.png',
131 |         'assets/images/protoss/zealot_portrait.png',
132 |         'assets/images/protoss/probe_portrait.png',
133 |         'assets/images/protoss/adept_portrait.png',
134 |         'assets/images/protoss/stalker_portrait.png',
135 |         'assets/images/protoss/dragoon_portrait.png',
136 |         'assets/images/protoss/darktemplar_portrait.png',
137 |     ];
138 |     portraitPaths.forEach(path => {
139 |         const name = path.split('/').pop().replace('.png', '');
140 |         tasks.push(() => assetManager.loadImage(path, name));
141 |     });
142 | 
143 |     const scvConstructUrls = [
144 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/SCV_Constructed1.mp3',
145 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/SCV_Constructed2.mp3'
146 |     ];
147 |     scvConstructUrls.forEach((url, i) => {
148 |         const name = `scv_constructed_${i}`;
149 |         tasks.push(async () => {
150 |             await assetManager.loadSound(url, name);
151 |             audioManager.scvConstructedSoundNames.push(name);
152 |         });
153 |     });
154 | 
155 |     const firebatSoundUrls = [
156 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/move2.wav',
157 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/move.wav',
158 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/on-click.wav',
159 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/spawn.wav',
160 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Firebat/attack-marshmallows.wav'
161 |     ];
162 |     firebatSoundUrls.forEach((url, i) => {
163 |         const name = `firebat_${i}`;
164 |         tasks.push(async () => {
165 |             await assetManager.loadSound(url, name);
166 |             audioManager.firebatSoundNames.push(name);
167 |         });
168 |     });
169 | 
170 |     const marineSoundUrls = [
171 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Marine/move.wav',
172 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Marine/spawn.wav',
173 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Marine/on-kill.wav',
174 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Marine/idle1.wav'
175 |     ];
176 |     marineSoundUrls.forEach((url, i) => {
177 |         const name = `marine_${i}`;
178 |         tasks.push(async () => {
179 |             await assetManager.loadSound(url, name);
180 |             audioManager.marineSoundNames.push(name);
181 |         });
182 |     });
183 | 
184 |     const medicSoundUrls = [
185 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/ready1.wav',
186 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/ready3.wav',
187 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/ready2.wav',
188 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/move1.wav',
189 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/idle1.wav',
190 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/heal2.wav',
191 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/heal1.wav',
192 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/banter2.wav',
193 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/Medic/banter1.wav'
194 |     ];
195 |     medicSoundUrls.forEach((url, i) => {
196 |         const name = `medic_${i}`;
197 |         tasks.push(async () => {
198 |             await assetManager.loadSound(url, name);
199 |             audioManager.medicSoundNames.push(name);
200 |         });
201 |     });
202 | 
203 |     const warningUrls = {
204 |         minerals: 'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/minerals_warning.wav',
205 |         gas: 'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/gas_warning.wav',
206 |         supply: 'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Units/SCV/supply_warning.wav'
207 |     };
208 |     tasks.push(() => audioManager.loadWarningSounds(warningUrls));
209 | 
210 |     const bgUrls = [
211 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Terran%20BGM.mp3',
212 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/Terran%20BGM2.mp3',
213 |         'https://file.garden/Zy7B0LkdIVpGyzA1/StarCraft/sounds/Terran/terran1.mp3',
214 |     ];
215 |     // This part now uses the AudioManager method
216 |     tasks.push(() => audioManager.loadBackgroundTracks(bgUrls));
217 | 
218 |     // Load any extra assets defined in assets/extra-assets.json
219 |     await addExtraPreloadTasks(tasks);
220 | 
221 |     let loaded = 0;
222 | 
223 |     const updateProgress = () => {
224 |         const pct = Math.round((loaded / tasks.length) * 100);
225 |         if (loadingText) {
226 |             loadingText.textContent = `Loading... ${pct}%`;
227 |         }
228 |         if (progressBar) {
229 |             progressBar.value = pct;
230 |         }
231 |     };
232 | 
233 |     const promises = tasks.map(task =>
234 |         task()
235 |             .catch(e => {
236 |                 console.warn('Asset failed to load', e);
237 |             })
238 |             .finally(() => {
239 |                 loaded++;
240 |                 updateProgress();
241 |             })
242 |     );
243 | 
244 |     updateProgress();
245 |     await Promise.all(promises);
246 | 
247 |     if (loadingOverlay) loadingOverlay.classList.remove('visible');
248 | }


--------------------------------------------------------------------------------
/src/game/preloader_downloader.js:
--------------------------------------------------------------------------------
 1 | import { assetManager } from '../utils/asset-manager.js';
 2 | 
 3 | export async function addExtraPreloadTasks(tasks) {
 4 |     try {
 5 |         const response = await fetch('assets/extra-assets.json');
 6 |         if (!response.ok) {
 7 |             console.warn('extra-assets.json not found');
 8 |             return;
 9 |         }
10 |         const manifest = await response.json();
11 | 
12 |         const pushTask = (urls, loader, ext) => {
13 |             if (!Array.isArray(urls)) return;
14 |             urls.forEach(url => {
15 |                 const base = url.split('/').pop().split('?')[0];
16 |                 let name = `extra_${base.replace('.' + ext, '')}`;
17 |                 if (base === 'scan.mp4') {
18 |                    name = 'ad_video'; // Special case for our ad video
19 |                 }
20 |                 tasks.push(() => loader.call(assetManager, url, name));
21 |             });
22 |         };
23 | 
24 |         pushTask(manifest.glbs, assetManager.loadGLB, 'glb');
25 |         pushTask(manifest.mp3s, assetManager.loadSound, 'mp3');
26 |         pushTask(manifest.wavs, assetManager.loadSound, 'wav');
27 |         pushTask(manifest.mp4s, assetManager.loadVideo, 'mp4');
28 |     } catch (e) {
29 |         console.warn('Failed to load extra asset manifest', e);
30 |     }
31 | }
32 | 
33 | 


--------------------------------------------------------------------------------
/src/game/rightClickHandler.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { MineralField } from '../resources/mineral-field.js';
  3 | import { VespeneGeyser } from '../resources/vespene-geyser.js';
  4 | import { Refinery } from '../buildings/refinery.js';
  5 | import { CommandCenter } from '../buildings/command-center.js';
  6 | import { SCVMark2 } from '../units/scv-mark-2.js';
  7 | import { SCV } from '../units/scv.js';
  8 | import { Bunker } from '../buildings/bunker.js';
  9 | import { Dropship } from '../units/dropship.js';
 10 | import { Infantry } from '../units/infantry.js';
 11 | import { devLogger } from '../utils/dev-logger.js';
 12 | import { getGroundMeshes } from '../utils/terrain.js';
 13 | import { audioManager } from '../utils/audio.js';
 14 | 
 15 | const raycaster = new THREE.Raycaster();
 16 | const mouse = new THREE.Vector2();
 17 | 
 18 | let camera, scene, allSelectables, onMoveSound, createMoveIndicator, pathfinder, updateStatusText;
 19 | 
 20 | export function setPathfinder(newPathfinder) {
 21 |     pathfinder = newPathfinder;
 22 | }
 23 | let allBuildings = [];
 24 | let allMineralFields = [];
 25 | let getSelectedObjects;
 26 | 
 27 | export function initRightClickHandler(deps) {
 28 |     camera = deps.camera;
 29 |     scene = deps.scene;
 30 |     allSelectables = deps.selectables;
 31 |     allBuildings = deps.buildings;
 32 |     allMineralFields = deps.mineralFields;
 33 |     onMoveSound = deps.onMoveSound;
 34 |     createMoveIndicator = deps.createMoveIndicator;
 35 |     pathfinder = deps.pathfinder;
 36 |     updateStatusText = deps.updateStatusText;
 37 |     getSelectedObjects = deps.getSelectedObjects;
 38 | }
 39 | 
 40 | function getMousePosOnCanvas(event) {
 41 |     const rect = document.querySelector('canvas').getBoundingClientRect();
 42 |     const x = event.clientX - rect.left;
 43 |     const y = event.clientY - rect.top;
 44 |     return { x, y, width: rect.width, height: rect.height };
 45 | }
 46 | 
 47 | function assignGatherersToResource(gatherers, resource) {
 48 |     onMoveSound();
 49 |     createMoveIndicator(resource.mesh.position);
 50 |     
 51 |     const resourcePos = resource.mesh.position;
 52 |     const count = gatherers.length;
 53 |     const resourceCollider = resource.getCollider();
 54 |     const resourceSize = resourceCollider.getSize(new THREE.Vector3());
 55 |     const radius = Math.max(resourceSize.x, resourceSize.z) / 2 + 1.5;
 56 | 
 57 |     gatherers.forEach((unit, i) => {
 58 |         const angle = (i / count) * Math.PI * 2;
 59 |         const targetPos = new THREE.Vector3(
 60 |             resourcePos.x + radius * Math.cos(angle),
 61 |             resourcePos.y,
 62 |             resourcePos.z + radius * Math.sin(angle)
 63 |         );
 64 |         unit.gather(resource, allBuildings, targetPos);
 65 |     });
 66 | }
 67 | 
 68 | /** @tweakable The chance (0 to 1) that a unit will play a sound when given a move command. */
 69 | const unitMoveAckProbability = 0.8;
 70 | 
 71 | function handleMoveCommand(unitsToMove, targetPosition) {
 72 |     if (!unitsToMove || unitsToMove.length === 0 || !targetPosition) return;
 73 |     
 74 |     devLogger.log('RightClickHandler', `Issuing move command to ${unitsToMove.length} units to ${targetPosition.x.toFixed(1)}, ${targetPosition.z.toFixed(1)}.`);
 75 |     
 76 |     const playedUnitSound = audioManager.playUnitSound(unitsToMove, 'move', unitMoveAckProbability);
 77 |     if (!playedUnitSound) {
 78 |         onMoveSound();
 79 |     }
 80 |     
 81 |     createMoveIndicator(targetPosition);
 82 |     
 83 |     const count = unitsToMove.length;
 84 |     const gridSize = Math.ceil(Math.sqrt(count));
 85 |     const spacing = 2; 
 86 |     const halfSize = (gridSize - 1) * spacing / 2;
 87 | 
 88 |     unitsToMove.forEach((unit, i) => {
 89 |         if (typeof unit.stopActions === 'function') {
 90 |             unit.stopActions();
 91 |         }
 92 | 
 93 |         const row = Math.floor(i / gridSize);
 94 |         const col = i % gridSize;
 95 |         const offsetX = col * spacing - halfSize;
 96 |         const offsetZ = row * spacing - halfSize;
 97 |         const finalTarget = targetPosition.clone().add(new THREE.Vector3(offsetX, 0, offsetZ));
 98 |         
 99 |         if (unit.isFlying) {
100 |             unit.setPath([finalTarget]);
101 |             return;
102 |         }
103 | 
104 |         let path = pathfinder.findPath(unit.mesh.position, finalTarget);
105 |         if (!path || path.length === 0) {
106 |             path = pathfinder.findPath(unit.mesh.position, targetPosition);
107 |         }
108 | 
109 |         if (path && path.length > 0) {
110 |             unit.setPath(path);
111 |             if (unit.state) {
112 |                 unit.state = 'moving';
113 |             }
114 |         }
115 |     });
116 | }
117 | 
118 | export function handleRightClick(event) {
119 |     const selectedObjects = getSelectedObjects();
120 |     const moveableUnits = selectedObjects.filter(obj => 'setPath' in obj);
121 |     if (moveableUnits.length === 0) {
122 |         const commandCenters = selectedObjects.filter(obj => obj instanceof CommandCenter);
123 |         if (commandCenters.length === 0) return;
124 |     }
125 | 
126 |     const pos = event.isMobile ? event : getMousePosOnCanvas(event);
127 |     mouse.x = (pos.x / pos.width) * 2 - 1;
128 |     mouse.y = -(pos.y / pos.height) * 2 + 1;
129 |     raycaster.setFromCamera(mouse, camera);
130 | 
131 |     const objectMeshes = allSelectables.map(s => s.mesh);
132 |     const objectIntersects = raycaster.intersectObjects(objectMeshes, true);
133 | 
134 |     let clickedObject = objectIntersects.length > 0 ? objectIntersects[0].object.userData.owner : null;
135 |     
136 |     if (clickedObject) {
137 |         devLogger.log('RightClickHandler', `Clicked on object: ${clickedObject.name}`);
138 |     } else {
139 |         devLogger.log('RightClickHandler', `Clicked on ground.`);
140 |     }
141 | 
142 |     if (clickedObject && clickedObject.isAddon) {
143 |         clickedObject = clickedObject.parentBuilding;
144 |     }
145 | 
146 |     if (clickedObject instanceof CommandCenter && clickedObject.state !== 'grounded') {
147 |         // Flying CC move handled by fallback
148 |     } else if (objectIntersects.length > 0) {
149 |         const builders = selectedObjects.filter(obj => obj instanceof SCVMark2 || obj instanceof SCV);
150 |         if (builders.length > 0 && clickedObject?.isUnderConstruction && clickedObject.currentHealth < clickedObject.maxHealth) {
151 |             onMoveSound();
152 |             createMoveIndicator(clickedObject.mesh.position);
153 |             const buildingCollider = clickedObject.getCollider();
154 |             const size = buildingCollider.getSize(new THREE.Vector3());
155 |             const buildPosition = clickedObject.mesh.position;
156 |             const radius = Math.max(size.x, size.z) / 2 + 1.5;
157 | 
158 |             builders.forEach((builder, i) => {
159 |                 const angle = (i / builders.length) * (Math.PI * 2);
160 |                 const targetPos = new THREE.Vector3(
161 |                     buildPosition.x + radius * Math.cos(angle),
162 |                     buildPosition.y,
163 |                     buildPosition.z + radius * Math.sin(angle)
164 |                 );
165 |                 builder.build(clickedObject, pathfinder, targetPos);
166 |             });
167 |             return;
168 |         }
169 | 
170 |         const repairers = selectedObjects.filter(obj => obj instanceof SCVMark2 || obj instanceof SCV);
171 |         const canRepair = repairers.length > 0 &&
172 |             clickedObject?.currentHealth !== undefined &&
173 |             !clickedObject.isUnderConstruction &&
174 |             clickedObject.currentHealth < clickedObject.maxHealth &&
175 |             !(clickedObject instanceof MineralField) &&
176 |             !(clickedObject instanceof VespeneGeyser);
177 |         if (canRepair) {
178 |             onMoveSound();
179 |             createMoveIndicator(clickedObject.mesh.position);
180 |             const collider = clickedObject.getCollider();
181 |             const size = collider.getSize(new THREE.Vector3());
182 |             const pos = clickedObject.mesh.position;
183 |             const radius = Math.max(size.x, size.z) / 2 + 1.5;
184 | 
185 |             repairers.forEach((rep, i) => {
186 |                 const angle = (i / repairers.length) * (Math.PI * 2);
187 |                 const targetPos = new THREE.Vector3(
188 |                     pos.x + radius * Math.cos(angle),
189 |                     pos.y,
190 |                     pos.z + radius * Math.sin(angle)
191 |                 );
192 |                 rep.repair(clickedObject, pathfinder, targetPos);
193 |             });
194 |             return;
195 |         }
196 | 
197 |         const medics = selectedObjects.filter(obj => obj instanceof Infantry && obj.constructor.name === 'Medic');
198 |         if (medics.length > 0 && clickedObject instanceof Infantry && clickedObject.currentHealth < clickedObject.maxHealth) {
199 |             onMoveSound();
200 |             createMoveIndicator(clickedObject.mesh.position);
201 |             const collider = clickedObject.getCollider();
202 |             const size = collider.getSize(new THREE.Vector3());
203 |             const pos = clickedObject.mesh.position;
204 |             const radius = Math.max(size.x, size.z) / 2 + 1.0;
205 | 
206 |             medics.forEach((medic, i) => {
207 |                 const angle = (i / medics.length) * (Math.PI * 2);
208 |                 const targetPos = new THREE.Vector3(
209 |                     pos.x + radius * Math.cos(angle),
210 |                     pos.y,
211 |                     pos.z + radius * Math.sin(angle)
212 |                 );
213 |                 medic.heal(clickedObject, pathfinder, targetPos);
214 |             });
215 |             return;
216 |         }
217 | 
218 |         const garrisonableUnits = selectedObjects.filter(obj => typeof obj.garrison === 'function');
219 |         if (garrisonableUnits.length > 0 && (clickedObject instanceof Bunker || clickedObject instanceof Dropship)) {
220 |             const spaceAvailable = clickedObject.capacity - clickedObject.garrisonedUnits.length;
221 |             if (spaceAvailable <= 0) {
222 |                 updateStatusText(`${clickedObject.name} is full.`);
223 |                 return;
224 |             }
225 |             onMoveSound();
226 |             createMoveIndicator(clickedObject.mesh.position);
227 |             const unitsToGarrison = garrisonableUnits.slice(0, spaceAvailable);
228 |             unitsToGarrison.forEach(unit => unit.garrison(clickedObject));
229 |             handleMoveCommand(unitsToGarrison, clickedObject.mesh.position);
230 |             if (unitsToGarrison.length < garrisonableUnits.length) {
231 |                 updateStatusText(`Not enough space in ${clickedObject.name} for all units.`);
232 |             }
233 |             return;
234 |         }
235 | 
236 |         const gatherers = selectedObjects.filter(obj => typeof obj.gather === 'function');
237 |         if (gatherers.length > 0) {
238 |             let gatherTarget = null;
239 |             if (clickedObject instanceof MineralField) {
240 |                 const availableSlots = Math.max(0, 2 - clickedObject.miners.size);
241 |                 const unitsToAssignToThisField = gatherers.splice(0, availableSlots);
242 |                 if (unitsToAssignToThisField.length > 0) {
243 |                     assignGatherersToResource(unitsToAssignToThisField, clickedObject);
244 |                 }
245 |                 if (gatherers.length > 0) {
246 |                     const otherMineralFields = allMineralFields.filter(mf => mf !== clickedObject && !mf.isDepleted).sort((a, b) => a.mesh.position.distanceToSquared(clickedObject.mesh.position) - b.mesh.position.distanceToSquared(clickedObject.mesh.position));
247 |                     let remainingGatherers = gatherers.slice();
248 |                     for (const field of otherMineralFields) {
249 |                         if (remainingGatherers.length === 0) break;
250 |                         const slots = Math.max(0, 2 - field.miners.size);
251 |                         if (slots > 0) {
252 |                             const unitsForThisField = remainingGatherers.splice(0, slots);
253 |                             assignGatherersToResource(unitsForThisField, field);
254 |                         }
255 |                     }
256 |                     if (remainingGatherers.length > 0) {
257 |                         updateStatusText("Not enough available mineral fields.");
258 |                     }
259 |                 }
260 |                 return;
261 |             }
262 |             
263 |             if (clickedObject instanceof Refinery) {
264 |                 gatherTarget = clickedObject;
265 |             } else if (clickedObject instanceof VespeneGeyser) {
266 |                 if (clickedObject.hasRefinery) {
267 |                     gatherTarget = allBuildings.find(b => b.name === 'Refinery' && b.geyser === clickedObject);
268 |                 } else {
269 |                     updateStatusText("Refinery required to harvest vespene gas.");
270 |                 }
271 |             }
272 | 
273 |             if (gatherTarget && !gatherTarget.isDepleted) {
274 |                 assignGatherersToResource(gatherers, gatherTarget);
275 |                 const nonGatherers = moveableUnits.filter(u => !gatherers.includes(u));
276 |                 if (nonGatherers.length > 0) {
277 |                     handleMoveCommand(nonGatherers, gatherTarget.mesh.position);
278 |                 }
279 |                 return; 
280 |             }
281 |         }
282 |     }
283 |     
284 |     const groundMeshes = getGroundMeshes(scene);
285 |     if (groundMeshes.length === 0) return;
286 | 
287 |     const groundIntersects = raycaster.intersectObjects(groundMeshes, true);
288 | 
289 |     if (groundIntersects.length > 0) {
290 |         const flyingCCs = selectedObjects.filter(obj => obj instanceof CommandCenter && obj.state === 'flying');
291 |         if (flyingCCs.length > 0) {
292 |              onMoveSound();
293 |              createMoveIndicator(groundIntersects[0].point);
294 |              const cc = flyingCCs[0];
295 |              const path = pathfinder.findPath(cc.mesh.position, groundIntersects[0].point);
296 |              if (path) {
297 |                  cc.setPath(path.map(p => new THREE.Vector3(p.x, cc.hoverHeight, p.z)));
298 |              }
299 |              return;
300 |         }
301 | 
302 |         handleMoveCommand(moveableUnits, groundIntersects[0].point);
303 |     }
304 | }


--------------------------------------------------------------------------------
/src/game/selection.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Unit } from '../units/unit.js';
  3 | import { SCV } from '../units/scv.js';
  4 | import { SCVMark2 } from '../units/scv-mark-2.js';
  5 | import { Firebat } from '../units/firebat.js';
  6 | import { Medic } from '../units/medic.js';
  7 | import { Ghost } from '../units/ghost.js';
  8 | import { Vulture } from '../units/vulture.js';
  9 | import { SiegeTank } from '../units/siege-tank.js';
 10 | import { CommandCenter } from '../buildings/command-center.js';
 11 | import { SupplyDepot } from '../buildings/supply-depot.js';
 12 | import { Refinery } from '../buildings/refinery.js';
 13 | import { Barracks } from '../buildings/barracks.js';
 14 | import { EngineeringBay } from '../buildings/engineering-bay.js';
 15 | import { Bunker } from '../buildings/bunker.js';
 16 | import { Academy } from '../buildings/academy.js';
 17 | import { MissileTurret } from '../buildings/missile-turret.js';
 18 | import { Factory } from '../buildings/factory.js';
 19 | import { Starport } from '../buildings/starport.js';
 20 | import { ComsatStation } from '../buildings/comsat-station.js';
 21 | import { NuclearSilo } from '../buildings/nuclear-silo.js';
 22 | import { Goliath } from '../units/goliath.js';
 23 | import { Wraith } from '../units/wraith.js';
 24 | import { Dropship } from '../units/dropship.js';
 25 | import { Armory } from '../buildings/armory.js';
 26 | import { ScienceVessel } from '../units/science-vessel.js';
 27 | import { ScienceFacility } from '../buildings/science-facility.js';
 28 | import { ControlTower } from '../buildings/control-tower.js';
 29 | import { Valkyrie } from '../units/valkyrie.js';
 30 | import { Battlecruiser } from '../units/battlecruiser.js';
 31 | import { PhysicsLab } from '../buildings/physics-lab.js';
 32 | import { Zealot } from '../protoss/zealot.js';
 33 | import { Probe } from '../protoss/probe.js';
 34 | import { Adept } from '../protoss/adept.js';
 35 | import { Stalker } from '../protoss/stalker.js';
 36 | import { Dragoon } from '../protoss/dragoon.js';
 37 | import { DarkTemplar } from '../protoss/darktemplar.js';
 38 | import { HighTemplar } from '../protoss/hightemplar.js';
 39 | import { audioManager } from '../utils/audio.js';
 40 | 
 41 | const raycaster = new THREE.Raycaster();
 42 | const mouse = new THREE.Vector2();
 43 | 
 44 | let selectedObjects = [];
 45 | let onSelectSound;
 46 | let allSelectables = [];
 47 | let rendererDomElement, camera;
 48 | 
 49 | /** @tweakable The chance (0 to 1) that a unit will play a sound when selected. */
 50 | const unitSelectAckProbability = 1.0;
 51 | 
 52 | export function initSelection(deps) {
 53 |     onSelectSound = deps.onSelectSound;
 54 |     allSelectables = deps.allSelectables;
 55 |     rendererDomElement = deps.renderer.domElement;
 56 |     camera = deps.camera;
 57 | }
 58 | 
 59 | export function getSelectedObjects() {
 60 |     return selectedObjects;
 61 | }
 62 | 
 63 | function changeSelection(newSelection) {
 64 |     selectedObjects.forEach(obj => obj.deselect());
 65 |     selectedObjects = newSelection;
 66 |     selectedObjects.forEach(obj => {
 67 |         if (typeof obj.select === 'function') {
 68 |              obj.select();
 69 |         }
 70 |     });
 71 | 
 72 |     if (selectedObjects.length > 0) {
 73 |         const playedUnitSound = audioManager.playUnitSound(selectedObjects, 'select', unitSelectAckProbability);
 74 |         if (!playedUnitSound && onSelectSound) {
 75 |             onSelectSound();
 76 |         }
 77 |     }
 78 | }
 79 | 
 80 | function getMousePosOnCanvas(event) {
 81 |     const rect = rendererDomElement.getBoundingClientRect();
 82 |     const x = event.clientX - rect.left;
 83 |     const y = event.clientY - rect.top;
 84 |     return { x, y, width: rect.width, height: rect.height };
 85 | }
 86 | 
 87 | export function handleSingleSelection(event) {
 88 |     const pos = event.isMobile ? {
 89 |         x: event.clientX - rendererDomElement.getBoundingClientRect().left,
 90 |         y: event.clientY - rendererDomElement.getBoundingClientRect().top,
 91 |         width: rendererDomElement.clientWidth,
 92 |         height: rendererDomElement.clientHeight
 93 |     } : getMousePosOnCanvas(event);
 94 | 
 95 |     mouse.x = (pos.x / pos.width) * 2 - 1;
 96 |     mouse.y = -(pos.y / pos.height) * 2 + 1;
 97 |     raycaster.setFromCamera(mouse, camera);
 98 | 
 99 |     const objectMeshes = allSelectables.map(s => s.mesh);
100 |     const intersects = raycaster.intersectObjects(objectMeshes, true);
101 | 
102 |     if (intersects.length > 0) {
103 |         const clickedObject = intersects[0].object.userData.owner;
104 |         if (clickedObject) {
105 |             changeSelection([clickedObject]);
106 |         } else {
107 |              changeSelection([]);
108 |         }
109 |     } else {
110 |         changeSelection([]);
111 |     }
112 | }
113 | 
114 | export function handleBoxSelection(selectionBox) {
115 |     const boxBounds = selectionBox.getBoundingClientRect();
116 |     const objectsInBox = [];
117 |     const canvasRect = rendererDomElement.getBoundingClientRect();
118 | 
119 |     allSelectables.forEach(selectable => {
120 |         if (!selectable.mesh.position) return;
121 |         const screenPos = selectable.mesh.position.clone().project(camera);
122 |         const x = (screenPos.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
123 |         const y = (-screenPos.y * 0.5 + 0.5) * canvasRect.height + canvasRect.top;
124 | 
125 |         if (x >= boxBounds.left && x <= boxBounds.right && y >= boxBounds.top && y <= boxBounds.bottom) {
126 |             // Only add ownable units to selection
127 |             if (
128 |                 selectable instanceof SCV ||
129 |                 selectable instanceof SCVMark2 ||
130 |                 selectable instanceof Unit ||
131 |                 selectable instanceof Firebat ||
132 |                 selectable instanceof Medic ||
133 |                 selectable instanceof Ghost ||
134 |                 selectable instanceof Vulture ||
135 |                 selectable instanceof SiegeTank ||
136 |                 selectable instanceof Goliath ||
137 |                 selectable instanceof Wraith ||
138 |                 selectable instanceof Dropship ||
139 |                 selectable instanceof ScienceVessel ||
140 |                 selectable instanceof Valkyrie ||
141 |                 selectable instanceof Battlecruiser ||
142 |                 selectable instanceof Zealot ||
143 |                 selectable instanceof Probe ||
144 |                 selectable instanceof Adept ||
145 |                 selectable instanceof Stalker ||
146 |                 selectable instanceof DarkTemplar ||
147 |                 selectable instanceof HighTemplar ||
148 |                 selectable instanceof Dragoon ||
149 |                 selectable instanceof CommandCenter ||
150 |                 selectable instanceof SupplyDepot ||
151 |                 selectable instanceof Refinery ||
152 |                 selectable instanceof Barracks ||
153 |                 selectable instanceof EngineeringBay ||
154 |                 selectable instanceof Bunker ||
155 |                 selectable instanceof Academy ||
156 |                 selectable instanceof MissileTurret ||
157 |                 selectable instanceof Factory ||
158 |                 selectable instanceof Starport ||
159 |                 selectable instanceof Armory ||
160 |                 selectable instanceof ScienceFacility ||
161 |                 selectable instanceof ControlTower ||
162 |                 selectable instanceof PhysicsLab ||
163 |                 selectable instanceof ComsatStation ||
164 |                 selectable instanceof NuclearSilo
165 |             ) {
166 |                 objectsInBox.push(selectable);
167 |             }
168 |         }
169 |     });
170 |     changeSelection(objectsInBox);
171 | }


--------------------------------------------------------------------------------
/src/game/setupScene.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 3 | import { createMap } from './map.js';
 4 | import { Pathfinder } from '../utils/pathfinding.js';
 5 | import { assetManager } from '../utils/asset-manager.js';
 6 | 
 7 | export function setupScene(container) {
 8 |     const scene = new THREE.Scene();
 9 |     scene.background = new THREE.Color(0x10101a);
10 | 
11 |     const skyboxTexture = assetManager.get('skybox');
12 |     skyboxTexture.mapping = THREE.EquirectangularReflectionMapping;
13 |     scene.background = skyboxTexture;
14 | 
15 |     const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
16 |     camera.position.set(25, 20, 25);
17 | 
18 |     const renderer = new THREE.WebGLRenderer({ antialias: true });
19 |     renderer.setSize(container.clientWidth, container.clientHeight);
20 |     renderer.shadowMap.enabled = true;
21 |     container.appendChild(renderer.domElement);
22 | 
23 |     const controls = new OrbitControls(camera, renderer.domElement);
24 |     controls.enablePan = true;
25 |     controls.enableZoom = true;
26 |     controls.target.set(15, 0, 15);
27 |     controls.update();
28 | 
29 |     const mapWidth = 128;
30 |     const mapHeight = 128;
31 |     const { mesh: mapMesh, obstacles: terrainObstacles } = createMap(mapWidth, mapHeight);
32 |     scene.add(mapMesh);
33 | 
34 |     const gridHelper = new THREE.GridHelper(mapWidth, mapWidth, 0xaaaaaa, 0x666666);
35 |     gridHelper.position.y = 0.05;
36 |     gridHelper.visible = false;
37 |     scene.add(gridHelper);
38 | 
39 |     const pathfinder = new Pathfinder(mapWidth, mapHeight, 1);
40 | 
41 |     const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
42 |     scene.add(ambientLight);
43 |     const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
44 |     directionalLight.position.set(-30, 50, 20);
45 |     directionalLight.castShadow = true;
46 |     directionalLight.shadow.camera.top = 35;
47 |     directionalLight.shadow.camera.bottom = -35;
48 |     directionalLight.shadow.camera.left = -35;
49 |     directionalLight.shadow.camera.right = 35;
50 |     directionalLight.shadow.mapSize.width = 2048;
51 |     directionalLight.shadow.mapSize.height = 2048;
52 |     scene.add(directionalLight);
53 | 
54 |     return { scene, camera, renderer, controls, pathfinder, terrainObstacles, mapWidth, mapHeight, gridHelper };
55 | }


--------------------------------------------------------------------------------
/src/game/spawn.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { SCV } from '../units/scv.js';
  3 | import { SCVMark2 } from '../units/scv-mark-2.js';
  4 | import { Unit } from '../units/unit.js';
  5 | import { Firebat } from '../units/firebat.js';
  6 | import { Medic } from '../units/medic.js';
  7 | import { Ghost } from '../units/ghost.js';
  8 | import { CommandCenter } from '../buildings/command-center.js';
  9 | import { SupplyDepot } from '../buildings/supply-depot.js';
 10 | import { Refinery } from '../buildings/refinery.js';
 11 | import { Barracks } from '../buildings/barracks.js';
 12 | import { EngineeringBay } from '../buildings/engineering-bay.js';
 13 | import { Bunker } from '../buildings/bunker.js';
 14 | import { Academy } from '../buildings/academy.js';
 15 | import { MissileTurret } from '../buildings/missile-turret.js';
 16 | import { ComsatStation } from '../buildings/comsat-station.js';
 17 | import { NuclearSilo } from '../buildings/nuclear-silo.js';
 18 | import { Factory } from '../buildings/factory.js';
 19 | import { Starport } from '../buildings/starport.js';
 20 | import { Vulture } from '../units/vulture.js';
 21 | import { SiegeTank } from '../units/siege-tank.js';
 22 | import { Goliath } from '../units/goliath.js';
 23 | import { Wraith } from '../units/wraith.js';
 24 | import { Dropship } from '../units/dropship.js';
 25 | import { ScienceVessel } from '../units/science-vessel.js';
 26 | import { Armory } from '../buildings/armory.js';
 27 | import { ScienceFacility } from '../buildings/science-facility.js';
 28 | import { ControlTower } from '../buildings/control-tower.js';
 29 | import { getTerrainHeight } from '../utils/terrain.js';
 30 | import { Valkyrie } from '../units/valkyrie.js';
 31 | import { Battlecruiser } from '../units/battlecruiser.js';
 32 | import { PhysicsLab } from '../buildings/physics-lab.js';
 33 | import { Zealot } from '../protoss/zealot.js';
 34 | import { Probe } from '../protoss/probe.js';
 35 | import { Adept } from '../protoss/adept.js';
 36 | import { Stalker } from '../protoss/stalker.js';
 37 | import { Dragoon } from '../protoss/dragoon.js';
 38 | import { DarkTemplar } from '../protoss/darktemplar.js';
 39 | import { HighTemplar } from '../protoss/hightemplar.js';
 40 | 
 41 | let deps;
 42 | 
 43 | function findNearestWalkablePos(pos, pathfinder) {
 44 |     const node = pathfinder.getNodeFromWorld(pos);
 45 |     if (node && node.walkable) {
 46 |         return pathfinder.gridToWorld(node.x, node.y);
 47 |     }
 48 |     let nearest = null;
 49 |     let minDist = Infinity;
 50 |     for (let x = 0; x < pathfinder.gridWidth; x++) {
 51 |         for (let y = 0; y < pathfinder.gridHeight; y++) {
 52 |             const n = pathfinder.grid[x][y];
 53 |             if (!n.walkable) continue;
 54 |             const world = pathfinder.gridToWorld(n.x, n.y);
 55 |             const dist = world.distanceToSquared(pos);
 56 |             if (dist < minDist) {
 57 |                 minDist = dist;
 58 |                 nearest = world;
 59 |             }
 60 |         }
 61 |     }
 62 |     return nearest || pos;
 63 | }
 64 | 
 65 | export function setPathfinder(newPathfinder) {
 66 |     if (deps) {
 67 |         deps.pathfinder = newPathfinder;
 68 |     }
 69 | }
 70 | 
 71 | export function initSpawner(_deps) {
 72 |     deps = _deps;
 73 | }
 74 | 
 75 | export function spawnBuilding(type, position, buildTime, extraData = {}) {
 76 |     const { scene, buildings, selectables, collidableObjects, pathfinder } = deps;
 77 |     let building;
 78 |     const options = (typeof buildTime === 'object') ? buildTime : { isUnderConstruction: true, buildTime: buildTime };
 79 |     const pathfinderUpdateCallback = () => pathfinder.updateObstacles(collidableObjects);
 80 | 
 81 |     // Add onStateChange callback to all building options
 82 |     options.onStateChange = pathfinderUpdateCallback;
 83 | 
 84 |     if (type === 'build_command_center') {
 85 |         building = new CommandCenter(position, options);
 86 |     } else if (type === 'build_supply_depot') {
 87 |         building = new SupplyDepot(position, pathfinderUpdateCallback, options);
 88 |     } else if (type === 'build_refinery') {
 89 |         building = new Refinery(position, extraData.geyser, options);
 90 |     } else if (type === 'build_barracks') {
 91 |         building = new Barracks(position, options);
 92 |     } else if (type === 'build_engineering_bay') {
 93 |         building = new EngineeringBay(position, options);
 94 |     } else if (type === 'build_bunker') {
 95 |         building = new Bunker(position, options);
 96 |     } else if (type === 'build_academy') {
 97 |         building = new Academy(position, options);
 98 |     } else if (type === 'build_missile_turret') {
 99 |         building = new MissileTurret(position, options);
100 |     } else if (type === 'build_factory') {
101 |         building = new Factory(position, options);
102 |     } else if (type === 'build_starport') {
103 |         building = new Starport(position, options);
104 |     } else if (type === 'build_armory') {
105 |         building = new Armory(position, options);
106 |     } else if (type === 'build_science_facility') {
107 |         building = new ScienceFacility(position, options);
108 |     } else if (type === 'Comsat Station') {
109 |         building = new ComsatStation(position, { ...options, parent: extraData.parent });
110 |     } else if (type === 'Nuclear Silo') {
111 |         building = new NuclearSilo(position, { ...options, parent: extraData.parent });
112 |     } else if (type === 'Control Tower') {
113 |         building = new ControlTower(position, { ...options, parent: extraData.parent });
114 |     } else if (type === 'Physics Lab') {
115 |         building = new PhysicsLab(position, { ...options, parent: extraData.parent });
116 |     }
117 | 
118 |     if (building) {
119 |         scene.add(building.mesh);
120 |         buildings.push(building);
121 |         selectables.push(building);
122 |         collidableObjects.push(building);
123 |         pathfinder.updateObstacles(collidableObjects);
124 |     }
125 |     return building;
126 | }
127 | 
128 | export function spawnUnit(unitType, position) {
129 |     const { scene, units, selectables, gameState, audioManager, pathfinder } = deps;
130 |     let spawnPos = new THREE.Vector3(position.x, position.y || 0, position.z);
131 |     if (pathfinder) {
132 |         spawnPos = findNearestWalkablePos(spawnPos, pathfinder).clone();
133 |     }
134 |     const terrainY = getTerrainHeight(scene, spawnPos.x, spawnPos.z);
135 |     spawnPos.y = terrainY;
136 |     let unit;
137 |     switch (unitType) {
138 |         case 'SCV':
139 |             unit = new SCV(spawnPos);
140 |             gameState.supplyUsed += 1;
141 |             if (audioManager && audioManager.scvConstructedSoundNames.length) {
142 |                 audioManager.playRandomSound(audioManager.scvConstructedSoundNames);
143 |             }
144 |             break;
145 |         case 'Marine':
146 |             unit = new Unit(spawnPos);
147 |             gameState.supplyUsed += 1;
148 |             break;
149 |         case 'Firebat':
150 |             unit = new Firebat(spawnPos);
151 |             gameState.supplyUsed += 1;
152 |             break;
153 |         case 'Medic':
154 |             unit = new Medic(spawnPos);
155 |             gameState.supplyUsed += 1;
156 |             break;
157 |         case 'Ghost':
158 |             unit = new Ghost(spawnPos);
159 |             gameState.supplyUsed += 1;
160 |             break;
161 |         case 'Zealot':
162 |             unit = new Zealot(spawnPos);
163 |             gameState.supplyUsed += 2;
164 |             break;
165 |         case 'Probe':
166 |             unit = new Probe(spawnPos);
167 |             gameState.supplyUsed += 1;
168 |             break;
169 |         case 'Adept':
170 |             unit = new Adept(spawnPos);
171 |             gameState.supplyUsed += 2;
172 |             break;
173 |         case 'Dark Templar':
174 |             unit = new DarkTemplar(spawnPos);
175 |             gameState.supplyUsed += 2;
176 |             break;
177 |         case 'High Templar':
178 |             unit = new HighTemplar(spawnPos);
179 |             gameState.supplyUsed += 2;
180 |             break;
181 |         case 'Stalker':
182 |             unit = new Stalker(spawnPos);
183 |             gameState.supplyUsed += 2;
184 |             break;
185 |         case 'Dragoon':
186 |             unit = new Dragoon(spawnPos);
187 |             gameState.supplyUsed += 2;
188 |             break;
189 |         case 'Wraith':
190 |             unit = new Wraith(spawnPos);
191 |             gameState.supplyUsed += 2;
192 |             break;
193 |         case 'Dropship':
194 |             unit = new Dropship(spawnPos);
195 |             gameState.supplyUsed += 2;
196 |             break;
197 |         case 'Science Vessel':
198 |             unit = new ScienceVessel(spawnPos);
199 |             gameState.supplyUsed += 2;
200 |             break;
201 |         case 'Valkyrie':
202 |             unit = new Valkyrie(spawnPos);
203 |             gameState.supplyUsed += 3;
204 |             break;
205 |         case 'Battlecruiser':
206 |             unit = new Battlecruiser(spawnPos);
207 |             gameState.supplyUsed += 6;
208 |             break;
209 |         case 'Vulture':
210 |             unit = new Vulture(spawnPos);
211 |             gameState.supplyUsed += 2;
212 |             break;
213 |         case 'Siege Tank':
214 |             unit = new SiegeTank(spawnPos);
215 |             gameState.supplyUsed += 2;
216 |             break;
217 |         case 'Goliath':
218 |             unit = new Goliath(spawnPos);
219 |             gameState.supplyUsed += 2;
220 |             break;
221 |         case 'SCV Mark 2':
222 |             unit = new SCVMark2(spawnPos);
223 |             gameState.supplyUsed += 1;
224 |             if (audioManager && audioManager.scvMark2ConstructedSoundNames.length) {
225 |                 audioManager.playRandomSound(audioManager.scvMark2ConstructedSoundNames);
226 |             }
227 |             break;
228 |     }
229 | 
230 |     if (unit) {
231 |         scene.add(unit.mesh);
232 |         units.push(unit);
233 |         selectables.push(unit);
234 |     }
235 |     return unit;
236 | }


--------------------------------------------------------------------------------
/src/game/ui.js:
--------------------------------------------------------------------------------
  1 | import { ResourceDisplay } from './ui/ResourceDisplay.js';
  2 | import { SelectionInfoDisplay } from './ui/SelectionInfoDisplay.js';
  3 | import { CommandCard } from './ui/CommandCard.js';
  4 | import { MessageDisplay } from './ui/MessageDisplay.js';
  5 | import { Compass } from './ui/Compass.js';
  6 | import { MenuManager } from './ui/MenuManager.js';
  7 | import { ModalManager } from './ui/ModalManager.js';
  8 | 
  9 | // Create instances of the new UI components
 10 | const resourceDisplay = new ResourceDisplay();
 11 | const selectionInfoDisplay = new SelectionInfoDisplay();
 12 | const commandCard = new CommandCard();
 13 | const messageDisplay = new MessageDisplay();
 14 | const compass = new Compass();
 15 | const menuManager = new MenuManager();
 16 | const modalManager = new ModalManager();
 17 | 
 18 | // Callbacks to game logic
 19 | let commandExecutorRef;
 20 | 
 21 | 
 22 | 
 23 | function togglePause() {
 24 |     menuManager.isPaused = !menuManager.isPaused;
 25 |     commandCard.hideTooltip();
 26 |     if (menuManager.isPaused) {
 27 |         menuManager.ingameOptionsOverlay.classList.remove('hidden');
 28 |         // Sync sliders with current volumes
 29 |         menuManager.ingameBgmVolumeSlider.value = audioManager.bgmVolume;
 30 |         menuManager.ingameSfxVolumeSlider.value = audioManager.sfxVolume;
 31 |     } else {
 32 |         menuManager.ingameOptionsOverlay.classList.add('hidden');
 33 |     }
 34 | }
 35 | 
 36 | function toggleGrid() {
 37 |     if (gridHelperRef) {
 38 |         gridHelperRef.visible = !gridHelperRef.visible;
 39 |     }
 40 | }
 41 | 
 42 | 
 43 | 
 44 | export function initUI(commandExecutor, startGameCallback, audioManager, getGridHelper, getKeyState, getCamera) {
 45 |     resourceDisplay.init();
 46 |     selectionInfoDisplay.init();
 47 |     commandCard.init(commandExecutor);
 48 |     messageDisplay.init(audioManager);
 49 |     compass.init(getCamera);
 50 |     menuManager.init({
 51 |         onStartGame: startGameCallback,
 52 |         audioManager: audioManager,
 53 |         getGridHelper: getGridHelper,
 54 |     });
 55 |     modalManager.init(menuManager);
 56 | 
 57 |     // Store references
 58 |     commandExecutorRef = commandExecutor;
 59 | 
 60 |     // --- Global Hotkeys ---
 61 |     window.addEventListener('keydown', (e) => {
 62 |         if (!menuManager.isGameRunning || menuManager.isPaused) return;
 63 | 
 64 |         if (e.key === '/' || e.code === 'Slash') {
 65 |             e.preventDefault();
 66 |             modalManager.togglePromoModal();
 67 |             return;
 68 |         }
 69 | 
 70 |         // Find the command associated with the hotkey for the current selection
 71 |         const firstSelected = commandCard.currentCommandObject;
 72 |         if (firstSelected && firstSelected.commands) {
 73 |             const command = firstSelected.commands.find(cmd => cmd && cmd.hotkey && cmd.hotkey.toUpperCase() === e.key.toUpperCase());
 74 |             if (command) {
 75 |                 e.preventDefault();
 76 |                 commandExecutorRef(command.command);
 77 |                 commandCard.hideTooltip();
 78 |             }
 79 |         }
 80 |     });
 81 | }
 82 | 
 83 | export function hideStartScreen() {
 84 |     menuManager.hideStartScreen();
 85 | }
 86 | 
 87 | export function setGameRunning(running) {
 88 |     menuManager.setGameRunning(running);
 89 |     if (running) {
 90 |         messageDisplay.setupVideoPanel(); // Set up the looping video when the game starts
 91 |     }
 92 | }
 93 | 
 94 | export function updatePlacementText(message) {
 95 |     messageDisplay.updatePlacementText(message);
 96 | }
 97 | 
 98 | export function updateStatusText(message) {
 99 |     messageDisplay.updateStatusText(message);
100 | }
101 | 
102 | export function updateUI(selectedObjects, gameState) {
103 |     resourceDisplay.update(gameState);
104 |     selectionInfoDisplay.update(selectedObjects);
105 | 
106 |     const firstObject = selectedObjects.length > 0 ? selectedObjects[0] : null;
107 |     commandCard.update(firstObject, gameState);
108 |     compass.update();
109 | }
110 | 
111 | // Export state getters from MenuManager for other modules to use
112 | export const isPaused = () => menuManager.isPaused;
113 | export const isGameRunning = () => menuManager.isGameRunning;


--------------------------------------------------------------------------------
/src/game/ui/CommandCard.js:
--------------------------------------------------------------------------------
  1 | import { assetManager } from '../../utils/asset-manager.js';
  2 | 
  3 | let commandGrid, tooltip, buildQueueDisplay, commandCardPanel;
  4 | let executeCommandCallback = null;
  5 | 
  6 | export class CommandCard {
  7 |     constructor() {
  8 |         this.currentCommandObject = null;
  9 |         this.currentCommandSignature = '';
 10 |     }
 11 | 
 12 |     init(callback) {
 13 |         commandCardPanel = document.getElementById('command-card-panel');
 14 |         commandGrid = document.querySelector('#command-card-panel .command-grid');
 15 |         tooltip = document.getElementById('tooltip');
 16 |         buildQueueDisplay = document.getElementById('build-queue-display');
 17 |         executeCommandCallback = callback;
 18 |         commandCardPanel.style.display = 'none'; // Initially hidden
 19 |     }
 20 | 
 21 |     update(object, gameState) {
 22 |         if (!object) {
 23 |             if (commandCardPanel.style.display !== 'none') {
 24 |                 commandCardPanel.style.display = 'none';
 25 |                 this.hideTooltip(); // Hide tooltip when selection is cleared
 26 |             }
 27 |             return;
 28 |         }
 29 | 
 30 |         if (commandCardPanel.style.display !== 'flex') {
 31 |             commandCardPanel.style.display = 'flex';
 32 |         }
 33 | 
 34 |         const newSignature = JSON.stringify(object?.commands); // Use optional chaining for safety
 35 | 
 36 |         if (object !== this.currentCommandObject || newSignature !== this.currentCommandSignature) {
 37 |             this.updateCommandButtons(object, gameState);
 38 |             this.currentCommandObject = object;
 39 |             this.currentCommandSignature = newSignature;
 40 |         }
 41 |         this.updateBuildProgressDisplay(object);
 42 |     }
 43 | 
 44 |     updateCommandButtons(object, gameState) {
 45 |         commandGrid.innerHTML = ''; // Clear existing buttons
 46 |         this.hideTooltip(); // Hide any lingering tooltips
 47 | 
 48 |         const commands = object?.commands ?? [];
 49 |         const totalButtons = 12; // 4x3 grid
 50 |         const isMobile = document.getElementById('enable-mobile-controls-checkbox')?.checked;
 51 |         const isBuildingAddon = object.buildQueue?.some(item => item.isAddon);
 52 | 
 53 |         for (let i = 0; i < totalButtons; i++) {
 54 |             const command = commands[i];
 55 |             const button = document.createElement('div');
 56 |             button.classList.add('command-button');
 57 |             button.dataset.index = i; // For linking to build queue
 58 | 
 59 |             if (command) {
 60 |                 // This check is now simplified because the command list from the object is authoritative.
 61 |                 if (isBuildingAddon && command.command !== object.buildQueue[0].originalCommand) {
 62 |                     commandGrid.appendChild(button); // Append empty button for spacing
 63 |                     continue;
 64 |                 }
 65 | 
 66 |                 button.dataset.command = command.command;
 67 | 
 68 |                 if (command.name) {
 69 |                     let tooltipText = command.name;
 70 |                     if (command.cost) {
 71 |                         let costs = [];
 72 |                         if (command.cost.minerals) costs.push(`${command.cost.minerals} Minerals`);
 73 |                         if (command.cost.vespene) costs.push(`${command.cost.vespene} Vespene`);
 74 |                         if (command.cost.supply) costs.push(`${command.cost.supply} Supply`);
 75 |                         if (costs.length > 0) tooltipText += `\nCost: ${costs.join(', ')}`;
 76 |                     }
 77 |                     if (command.buildTime) {
 78 |                         tooltipText += `\nTime: ${command.buildTime}s`;
 79 |                     }
 80 |                     if (command.researchTime) { // For research commands in Engineering Bay, Academy, Armory
 81 |                         tooltipText += `\nTime: ${command.researchTime}s`;
 82 |                     }
 83 |                     button.dataset.tooltipText = tooltipText;
 84 | 
 85 |                     if (command.prereq && gameState && !gameState[command.prereq]) {
 86 |                         let prereqName = 'Requires: Unknown';
 87 |                         switch (command.prereq) {
 88 |                             case 'academyBuilt': prereqName = "Requires: Academy"; break;
 89 |                             case 'engineeringBayBuilt': prereqName = "Requires: Engineering Bay"; break;
 90 |                             case 'barracksBuilt': prereqName = "Requires: Barracks"; break;
 91 |                             case 'factoryBuilt': prereqName = "Requires: Factory"; break;
 92 |                             case 'starportBuilt': prereqName = "Requires: Starport"; break;
 93 |                             case 'scienceFacilityBuilt': prereqName = "Requires: Science Facility";
 94 |                             case 'physicsLabBuilt': prereqName = "Requires: Physics Lab"; break;
 95 |                             case 'covertOpsBuilt': prereqName = "Requires: Covert Ops"; break;
 96 |                         }
 97 |                         button.dataset.prereqText = prereqName;
 98 |                     }
 99 |                 }
100 |                 if (command.hotkey) {
101 |                     button.dataset.hotkey = command.hotkey;
102 |                 }
103 | 
104 |                 const commandAction = (e) => {
105 |                     if (e) {
106 |                         e.preventDefault();
107 |                         e.stopPropagation();
108 |                     }
109 |                     if (executeCommandCallback) {
110 |                         executeCommandCallback(command.command);
111 |                     }
112 |                     this.hideTooltip(); // Ensure tooltip is hidden after action
113 |                 };
114 | 
115 |                 // Disable button if an addon is currently being built
116 |                 if (isBuildingAddon) {
117 |                     button.style.pointerEvents = 'none';
118 |                     // Apply a grayscale filter to all buttons except the one being built
119 |                     if (command.command === object.buildQueue[0].originalCommand) {
120 |                          button.style.filter = 'none';
121 |                     } else {
122 |                          button.style.filter = 'grayscale(80%)';
123 |                     }
124 |                 } else {
125 |                     if (isMobile) {
126 |                         button.addEventListener('touchend', commandAction);
127 |                     } else {
128 |                         button.addEventListener('click', commandAction);
129 |                         button.addEventListener('mouseenter', this.showTooltip.bind(this));
130 |                         button.addEventListener('mouseleave', this.hideTooltip.bind(this));
131 |                     }
132 |                 }
133 | 
134 |                 if (command.icon) {
135 |                     const iconName = command.icon.split('/').pop().replace('.png', '');
136 |                     try {
137 |                         const preloadedIcon = assetManager.get(iconName);
138 |                         const icon = preloadedIcon.cloneNode(true);
139 |                         icon.classList.add('icon');
140 |                         icon.alt = command.name;
141 |                         button.appendChild(icon);
142 |                     } catch (e) {
143 |                         console.warn(`Icon not preloaded, falling back to src: ${command.icon}`, e);
144 |                         const icon = document.createElement('img');
145 |                         icon.classList.add('icon');
146 |                         icon.src = command.icon;
147 |                         icon.loading = 'lazy';
148 |                         icon.alt = command.name;
149 |                         button.appendChild(icon);
150 |                     }
151 |                 }
152 | 
153 |                 if (command.hotkey) {
154 |                     const hotkey = document.createElement('span');
155 |                     hotkey.classList.add('hotkey');
156 |                     hotkey.textContent = command.hotkey;
157 |                     button.appendChild(hotkey);
158 |                 }
159 | 
160 |                 const progressContainer = document.createElement('div');
161 |                 progressContainer.className = 'build-progress-container';
162 |                 button.appendChild(progressContainer);
163 |             }
164 | 
165 |             commandGrid.appendChild(button);
166 |         }
167 |     }
168 | 
169 |     updateBuildProgressDisplay(object) {
170 |         // Clear all previous queue counts
171 |         document.querySelectorAll('.build-queue-count').forEach(el => el.remove());
172 | 
173 |         if (!object || !object.buildQueue || object.buildQueue.length === 0) {
174 |             buildQueueDisplay.innerHTML = '';
175 |             document.querySelectorAll('.build-progress-bar').forEach(bar => bar.style.width = '0%');
176 |             return;
177 |         }
178 |         
179 |         let availableCommands = object.commands;
180 |         // If an addon is being built, the `commands` getter might only return that single command.
181 |         // We need the full list of potential commands to find icons for everything in the queue.
182 |         // The addonBehavior caches the list of possible addon builds.
183 |         if (object.addonBehavior && object.addonBehavior.cachedCommands.length > 0) {
184 |             // This is a bit of a hack; we merge the current commands with the cached addon commands
185 |             // to ensure we can find the icon for an addon being built.
186 |             const commandMap = new Map();
187 |             object.commands.forEach(c => c && commandMap.set(c.command, c));
188 |             object.addonBehavior.cachedCommands.forEach(c => c && !commandMap.has(c.command) && commandMap.set(c.command, c));
189 |             availableCommands = Array.from(commandMap.values());
190 |         }
191 | 
192 |         // --- Update Command Button Counters and Progress Bar ---
193 |         const queueCounts = {};
194 |         object.buildQueue.forEach(item => {
195 |             queueCounts[item.originalCommand] = (queueCounts[item.originalCommand] || 0) + 1;
196 |         });
197 | 
198 |         document.querySelectorAll('.command-button').forEach(button => {
199 |             const commandName = button.dataset.command;
200 |             if (queueCounts[commandName]) {
201 |                 const queueCountEl = document.createElement('div');
202 |                 queueCountEl.className = 'build-queue-count';
203 |                 queueCountEl.textContent = queueCounts[commandName];
204 |                 button.appendChild(queueCountEl);
205 |             }
206 |         });
207 | 
208 |         // Update progress bar for the item at the head of the queue
209 |         const trainingOrResearchingItem = object.buildQueue[0];
210 |         const progressPercent = (trainingOrResearchingItem.progress / trainingOrResearchingItem.buildTime) * 100;
211 | 
212 |         // Clear all progress bars first, then set the active one
213 |         document.querySelectorAll('.build-progress-bar').forEach(bar => bar.style.width = '0%');
214 | 
215 |         if (trainingOrResearchingItem) {
216 |             const button = commandGrid.querySelector(`.command-button[data-command='${trainingOrResearchingItem.originalCommand}']`);
217 |             if (button) {
218 |                 const progressContainer = button.querySelector('.build-progress-container');
219 |                 if (progressContainer) {
220 |                     let progressBar = progressContainer.querySelector('.build-progress-bar');
221 |                     if (!progressBar) {
222 |                         progressBar = document.createElement('div');
223 |                         progressBar.className = 'build-progress-bar';
224 |                         progressContainer.appendChild(progressBar);
225 |                     }
226 |                     progressBar.style.width = `${progressPercent}%`;
227 |                 }
228 |             }
229 |         }
230 | 
231 |         // --- Update Visual Queue Display ---
232 |         let queueHTML = '';
233 |         object.buildQueue.slice(0, 5).forEach((item) => {
234 |             const command = availableCommands.find(c => c && c.command === item.originalCommand);
235 |             if (command) {
236 |                 queueHTML += `<div class="build-queue-item">
237 |                     <img src="${command.icon}" alt="${command.name}" />
238 |                 </div>`;
239 |             }
240 |         });
241 |         buildQueueDisplay.innerHTML = queueHTML;
242 |     }
243 | 
244 |     showTooltip(event) {
245 |         const button = event.currentTarget;
246 |         const tooltipText = button.dataset.tooltipText;
247 |         const prereqText = button.dataset.prereqText;
248 |         if (tooltipText) {
249 |             let finalHtml = tooltipText.replace(/\n/g, '<br>');
250 | 
251 |             if (prereqText) {
252 |                 finalHtml += `<br><span style="color: #ff6666;">${prereqText}</span>`;
253 |             }
254 | 
255 |             tooltip.innerHTML = finalHtml;
256 |             tooltip.style.display = 'block'; // Make it visible to measure it
257 | 
258 |             const rect = button.getBoundingClientRect();
259 |             const tooltipRect = tooltip.getBoundingClientRect();
260 |             const containerRect = document.body.getBoundingClientRect();
261 | 
262 |             // Position the tooltip above the button, centered
263 |             let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
264 |             let top = rect.top - tooltipRect.height - 5;
265 | 
266 |             // Clamp to screen edges
267 |             if (left < 0) left = 0;
268 |             if (left + tooltipRect.width > containerRect.width) {
269 |                 left = containerRect.width - tooltipRect.width;
270 |             }
271 |             if (top < 0) top = 0;
272 | 
273 |             tooltip.style.left = `${left}px`;
274 |             tooltip.style.top = `${top}px`;
275 |         }
276 |     }
277 | 
278 |     hideTooltip() {
279 |         tooltip.style.display = 'none';
280 |     }
281 | }


--------------------------------------------------------------------------------
/src/game/ui/Compass.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | 
 3 | let compassEl;
 4 | let getCamera;
 5 | 
 6 | export class Compass {
 7 |     init(cameraGetter) {
 8 |         compassEl = document.getElementById('compass');
 9 |         getCamera = cameraGetter;
10 |     }
11 | 
12 |     update() {
13 |         if (!compassEl || !getCamera) return;
14 |         const camera = getCamera();
15 |         if (!camera) return;
16 | 
17 |         const dir = new THREE.Vector3();
18 |         camera.getWorldDirection(dir);
19 |         dir.y = 0;
20 |         dir.normalize();
21 | 
22 |         const angle = Math.atan2(dir.x, dir.z);
23 |         const deg = THREE.MathUtils.radToDeg(angle);
24 |         let orientation;
25 |         if (deg >= -45 && deg < 45) {
26 |             orientation = 'N';
27 |         } else if (deg >= 45 && deg < 135) {
28 |             orientation = 'W';
29 |         } else if (deg < -135 || deg >= 135) {
30 |             orientation = 'S';
31 |         } else {
32 |             orientation = 'E';
33 |         }
34 | 
35 |         compassEl.textContent = orientation;
36 |     }
37 | }
38 | 


--------------------------------------------------------------------------------
/src/game/ui/MenuManager.js:
--------------------------------------------------------------------------------
  1 | export class MenuManager {
  2 |     constructor() {
  3 |         this.isPaused = false;
  4 |         this.isGameRunning = false;
  5 | 
  6 |         this.startScreen = null;
  7 |         this.mainMenu = null;
  8 |         this.optionsMenu = null;
  9 |         this.ingameOptionsOverlay = null;
 10 | 
 11 |         this.audioManager = null;
 12 |         this.getGridHelper = null;
 13 |         this.onStartGame = null;
 14 |     }
 15 | 
 16 |     init(deps) {
 17 |         this.onStartGame = deps.onStartGame;
 18 |         this.audioManager = deps.audioManager;
 19 |         this.getGridHelper = deps.getGridHelper;
 20 | 
 21 |         this._findAllElements();
 22 |         this._attachEventListeners();
 23 |     }
 24 | 
 25 |     _findAllElements() {
 26 |         this.startScreen = document.getElementById('start-screen');
 27 |         this.mainMenu = document.getElementById('main-menu');
 28 |         this.optionsMenu = document.getElementById('options-menu');
 29 |         this.ingameOptionsOverlay = document.getElementById('ingame-options-overlay');
 30 |     }
 31 | 
 32 |     _attachEventListeners() {
 33 |         const startButton = this.startScreen?.querySelector('#start-button');
 34 |         if (startButton) {
 35 |             startButton.addEventListener('click', this.onStartGame, { once: true });
 36 |         }
 37 |         window.addEventListener('keydown', (e) => {
 38 |             if (this.startScreen && !this.startScreen.classList.contains('hidden')) {
 39 |                 this.onStartGame();
 40 |             }
 41 |         }, { once: true });
 42 | 
 43 |         document.getElementById('options-button')?.addEventListener('click', () => {
 44 |             this.mainMenu?.classList.add('hidden');
 45 |             this.optionsMenu?.classList.remove('hidden');
 46 |         });
 47 | 
 48 |         document.getElementById('back-button')?.addEventListener('click', () => {
 49 |             this.optionsMenu?.classList.add('hidden');
 50 |             this.mainMenu?.classList.remove('hidden');
 51 |         });
 52 | 
 53 |         const bgmSlider = document.getElementById('bgm-volume-slider');
 54 |         const sfxSlider = document.getElementById('sfx-volume-slider');
 55 |         const ingameBgmSlider = document.getElementById('ingame-bgm-volume-slider');
 56 |         const ingameSfxSlider = document.getElementById('ingame-sfx-volume-slider');
 57 | 
 58 |         bgmSlider?.addEventListener('input', (e) => this.audioManager.setBgmVolume(e.target.value));
 59 |         sfxSlider?.addEventListener('input', (e) => this.audioManager.setSfxVolume(e.target.value));
 60 |         
 61 |         document.getElementById('resume-button')?.addEventListener('click', () => this.togglePause());
 62 |         document.getElementById('quit-button')?.addEventListener('click', () => window.location.reload());
 63 |         document.getElementById('toggle-grid-button')?.addEventListener('click', () => this.toggleGrid());
 64 |         
 65 |         ingameBgmSlider?.addEventListener('input', (e) => {
 66 |             this.audioManager.setBgmVolume(e.target.value);
 67 |             if(bgmSlider) bgmSlider.value = e.target.value;
 68 |         });
 69 |         ingameSfxSlider?.addEventListener('input', (e) => {
 70 |             this.audioManager.setSfxVolume(e.target.value);
 71 |             if(sfxSlider) sfxSlider.value = e.target.value;
 72 |         });
 73 | 
 74 |         window.addEventListener('keyup', (e) => {
 75 |             if (!this.isGameRunning) return;
 76 |             if (e.code === 'Backquote') {
 77 |                 this.togglePause();
 78 |             }
 79 |         });
 80 |     }
 81 | 
 82 |     togglePause() {
 83 |         this.isPaused = !this.isPaused;
 84 |         const tooltip = document.getElementById('tooltip');
 85 |         if (tooltip) tooltip.style.display = 'none';
 86 | 
 87 |         if (this.isPaused) {
 88 |             this.ingameOptionsOverlay?.classList.remove('hidden');
 89 |             const ingameBgmSlider = document.getElementById('ingame-bgm-volume-slider');
 90 |             const ingameSfxSlider = document.getElementById('ingame-sfx-volume-slider');
 91 |             if (ingameBgmSlider) ingameBgmSlider.value = this.audioManager.bgmVolume;
 92 |             if (ingameSfxSlider) ingameSfxSlider.value = this.audioManager.sfxVolume;
 93 |         } else {
 94 |             this.ingameOptionsOverlay?.classList.add('hidden');
 95 |         }
 96 |     }
 97 | 
 98 |     toggleGrid() {
 99 |         const gridHelper = this.getGridHelper ? this.getGridHelper() : null;
100 |         if (gridHelper) {
101 |             gridHelper.visible = !gridHelper.visible;
102 |         }
103 |     }
104 | 
105 |     hideStartScreen() {
106 |         if (this.startScreen) this.startScreen.classList.add('hidden');
107 |     }
108 | 
109 |     setGameRunning(running) {
110 |         this.isGameRunning = running;
111 |     }
112 | }
113 | 
114 | 


--------------------------------------------------------------------------------
/src/game/ui/MessageDisplay.js:
--------------------------------------------------------------------------------
  1 | import { assetManager } from '../../utils/asset-manager.js';
  2 | 
  3 | let statusTextPanel, placementTextPanel, globalMessageContainer;
  4 | let audioManagerRef;
  5 | 
  6 | 
  7 | /** @tweakable Adjust the video player settings */
  8 | const videoPlayerSettings = {
  9 |     volume: 0, // Muted by default to allow autoplay
 10 |     playbackRate: 1.0,
 11 |     opacity: 0.8
 12 | };
 13 | 
 14 | /** @tweakable The width of the video panel in pixels. */
 15 | const videoPanelWidth = 180;
 16 | 
 17 | export class MessageDisplay {
 18 |     init(audioManager) {
 19 |         statusTextPanel = document.getElementById('status-text-panel');
 20 |         placementTextPanel = document.getElementById('placement-text-panel');
 21 |         globalMessageContainer = document.getElementById('global-message-container');
 22 |         audioManagerRef = audioManager;
 23 |     }
 24 |     
 25 |     setupVideoPanel() {
 26 |         const videoPanel = document.getElementById('video-panel');
 27 |         if (!videoPanel) return;
 28 | 
 29 |         videoPanel.style.width = `${videoPanelWidth}px`;
 30 | 
 31 |         try {
 32 |             const videoElement = assetManager.get('ad_video');
 33 |             videoElement.loop = true;
 34 |             videoElement.muted = true;
 35 |             videoElement.volume = videoPlayerSettings.volume;
 36 |             videoElement.playbackRate = videoPlayerSettings.playbackRate;
 37 | 
 38 |             videoElement.style.width = '100%';
 39 |             videoElement.style.height = '100%';
 40 |             videoElement.style.objectFit = 'cover';
 41 |             videoElement.style.opacity = videoPlayerSettings.opacity;
 42 | 
 43 |             videoPanel.innerHTML = '';
 44 |             videoPanel.appendChild(videoElement);
 45 | 
 46 |             videoElement.play().catch(e => {
 47 |                 console.warn("Video autoplay was prevented.", e);
 48 |                 videoPanel.addEventListener('click', () => videoElement.play(), { once: true });
 49 |             });
 50 |         } catch (e) {
 51 |             console.error("Could not find preloaded video asset 'ad_video'.", e);
 52 |             videoPanel.textContent = 'Video asset not found.';
 53 |         }
 54 |     }
 55 | 
 56 |     updatePlacementText(message) {
 57 |         if (placementTextPanel) {
 58 |             placementTextPanel.textContent = message;
 59 |         }
 60 |     }
 61 | 
 62 |     showGlobalMessage(message) {
 63 |         if (!globalMessageContainer) return;
 64 | 
 65 |         const p = document.createElement('p');
 66 |         p.textContent = message;
 67 |         p.className = 'global-message';
 68 | 
 69 |         globalMessageContainer.appendChild(p);
 70 | 
 71 |         setTimeout(() => {
 72 |             p.style.opacity = '0';
 73 |         }, 1000);
 74 | 
 75 |         setTimeout(() => {
 76 |             if (p.parentElement) {
 77 |                 p.parentElement.removeChild(p);
 78 |             }
 79 |         }, 2000);
 80 |     }
 81 | 
 82 |     updateStatusText(message) {
 83 |         const lowerCaseMessage = message.toLowerCase();
 84 |         
 85 |         if (audioManagerRef) {
 86 |             if (lowerCaseMessage.includes('not enough minerals') && audioManagerRef.mineralsWarningSoundName) {
 87 |                 audioManagerRef.playSound(audioManagerRef.mineralsWarningSoundName);
 88 |             } else if (lowerCaseMessage.includes('not enough vespene') && audioManagerRef.gasWarningSoundName) {
 89 |                 audioManagerRef.playSound(audioManagerRef.gasWarningSoundName);
 90 |             } else if (lowerCaseMessage.includes('additional supply required') && audioManagerRef.supplyWarningSoundName) {
 91 |                 audioManagerRef.playSound(audioManagerRef.supplyWarningSoundName);
 92 |             }
 93 |         }
 94 | 
 95 |         if (lowerCaseMessage.includes('not enough minerals') ||
 96 |             lowerCaseMessage.includes('not enough vespene') ||
 97 |             lowerCaseMessage.includes('additional supply required')) {
 98 |             this.showGlobalMessage(message);
 99 |             return;
100 |         }
101 | 
102 | 
103 |         Array.from(statusTextPanel.children).forEach(child => {
104 |             if (child.textContent === message) {
105 |                 child.remove();
106 |             }
107 |         });
108 | 
109 |         const p = document.createElement('p');
110 |         p.textContent = message;
111 |         p.style.margin = '0 0 4px 0';
112 |         p.style.transition = 'opacity 1s ease-out 3s';
113 |         p.style.opacity = '1';
114 |         statusTextPanel.prepend(p);
115 | 
116 |         p.style.opacity = '0';
117 |         setTimeout(() => p.remove(), 4000);
118 | 
119 |         while (statusTextPanel.children.length > 8) {
120 |             statusTextPanel.removeChild(statusTextPanel.lastChild);
121 |         }
122 |     }
123 | }


--------------------------------------------------------------------------------
/src/game/ui/ModalManager.js:
--------------------------------------------------------------------------------
 1 | import { ManualModal } from './modals/ManualModal.js';
 2 | import { ChangelogModal } from './modals/ChangelogModal.js';
 3 | import { DevLogModal } from './modals/DevLogModal.js';
 4 | import { PromoModal } from './modals/PromoModal.js';
 5 | 
 6 | export class ModalManager {
 7 |     constructor() {
 8 |         this.menuManager = null;
 9 |         this.manualModal = new ManualModal();
10 |         this.changelogModal = new ChangelogModal();
11 |         this.devLogModal = new DevLogModal();
12 |         this.promoModal = new PromoModal();
13 |     }
14 | 
15 |     init(menuManager) {
16 |         this.menuManager = menuManager;
17 |         this.manualModal.init();
18 |         this.changelogModal.init();
19 |         this.devLogModal.init(menuManager);
20 |         this.promoModal.init();
21 |     }
22 | 
23 |     switchManualTab(tabName) {
24 |         this.manualModal.switchTab(tabName);
25 |     }
26 | 
27 |     switchChangelogTab(tabName) {
28 |         this.changelogModal.switchTab(tabName);
29 |     }
30 | 
31 |     toggleManualModal() {
32 |         return this.manualModal.toggle();
33 |     }
34 | 
35 |     toggleChangelogModal() {
36 |         return this.changelogModal.toggle();
37 |     }
38 | 
39 |     toggleDevLogModal() {
40 |         this.devLogModal.toggle();
41 |     }
42 | 
43 |     togglePromoModal() {
44 |         this.promoModal.toggle();
45 |     }
46 | 
47 |     archiveChangelog() {
48 |         return this.changelogModal.archive();
49 |     }
50 | }
51 | 


--------------------------------------------------------------------------------
/src/game/ui/ResourceDisplay.js:
--------------------------------------------------------------------------------
 1 | let mineralCountEl, vespeneCountEl, supplyCountEl;
 2 | 
 3 | export class ResourceDisplay {
 4 |     init() {
 5 |         mineralCountEl = document.getElementById('mineral-count');
 6 |         vespeneCountEl = document.getElementById('vespene-count');
 7 |         supplyCountEl = document.getElementById('supply-count');
 8 |     }
 9 | 
10 |     update(gameState) {
11 |         if (gameState) {
12 |             mineralCountEl.textContent = Math.floor(gameState.minerals);
13 |             vespeneCountEl.textContent = Math.floor(gameState.vespene);
14 |             supplyCountEl.textContent = `${gameState.supplyUsed}/${gameState.supplyCap}`;
15 | 
16 |             const supplyRatio = gameState.supplyUsed / gameState.supplyCap;
17 |             if (supplyRatio >= 1) {
18 |                 supplyCountEl.style.color = '#ff4444'; // Red when capped
19 |             } else if (supplyRatio > 0.85) {
20 |                 supplyCountEl.style.color = '#ffff00'; // Yellow when close
21 |             } else {
22 |                 supplyCountEl.style.color = '#ffffff'; // White otherwise
23 |             }
24 |         }
25 |     }
26 | }
27 | 
28 | 


--------------------------------------------------------------------------------
/src/game/ui/SelectionInfoDisplay.js:
--------------------------------------------------------------------------------
  1 | import { CommandCenter } from '../../buildings/command-center.js'; // Needed for instanceof checks
  2 | import { Bunker } from '../../buildings/bunker.js';
  3 | import { Dropship } from '../../units/dropship.js';
  4 | import { ScienceVessel } from '../../units/science-vessel.js';
  5 | 
  6 | let unitPortraitPanel, portraitImg, unitCountOverlay, healthBarFill, unitHealthText, unitName;
  7 | let energyBarContainer, energyBarFill, unitEnergyText;
  8 | let shieldBarContainer, shieldBarFill, unitShieldText;
  9 | 
 10 | export class SelectionInfoDisplay {
 11 |     init() {
 12 |         unitPortraitPanel = document.getElementById('unit-portrait-panel');
 13 |         portraitImg = document.getElementById('portrait-img');
 14 |         unitCountOverlay = document.getElementById('unit-count-overlay');
 15 |         healthBarFill = document.getElementById('health-bar-fill');
 16 |         unitHealthText = document.getElementById('unit-health-text');
 17 |         unitName = document.getElementById('unit-name');
 18 |         energyBarContainer = document.querySelector('.energy-bar-container');
 19 |         energyBarFill = document.getElementById('energy-bar-fill');
 20 |         unitEnergyText = document.getElementById('unit-energy-text');
 21 |         shieldBarContainer = document.querySelector('.shield-bar-container');
 22 |         shieldBarFill = document.getElementById('shield-bar-fill');
 23 |         unitShieldText = document.getElementById('unit-shield-text');
 24 |     }
 25 | 
 26 |     update(selectedObjects) {
 27 |         if (selectedObjects.length === 0) {
 28 |             unitPortraitPanel.style.display = 'none';
 29 |             return;
 30 |         }
 31 | 
 32 |         unitPortraitPanel.style.display = 'block';
 33 | 
 34 |         const firstObject = selectedObjects[0];
 35 |         portraitImg.src = firstObject.portraitUrl;
 36 | 
 37 |         // Default name display
 38 |         if (firstObject instanceof Bunker || firstObject instanceof Dropship) {
 39 |             unitName.innerHTML = `${firstObject.name} <span style="color: #fff; font-size: 11px; font-weight: normal;">(${firstObject.garrisonedUnits.length}/${firstObject.capacity})</span>`;
 40 |         } else if (firstObject.name === 'Medic' || firstObject instanceof ScienceVessel) {
 41 |             unitName.innerHTML = `${firstObject.name}<br/><span style="color: #a7d1ff; font-size: 11px;">Energy: ${Math.floor(firstObject.energy ?? 0)}</span>`;
 42 |         } else {
 43 |             unitName.innerHTML = firstObject.name;
 44 |         }
 45 | 
 46 |         if (firstObject instanceof CommandCenter && firstObject.addon && firstObject.addon.name === 'Comsat Station') {
 47 |             unitName.innerHTML += `<br/><span style="color: #a7d1ff; font-size: 11px;">Energy: ${Math.floor(firstObject.addon.energy)}</span>`;
 48 |         }
 49 | 
 50 |         const statusBarContainer = healthBarFill.closest('.status-bar-container');
 51 | 
 52 |         if (firstObject.maxHealth > 0) {
 53 |             const healthPercent = (firstObject.currentHealth / firstObject.maxHealth) * 100;
 54 |             statusBarContainer.style.display = 'block';
 55 |             healthBarFill.style.width = `${healthPercent}%`;
 56 |             // Dynamically set status bar color
 57 |             if (firstObject.statusBarColor) {
 58 |                 healthBarFill.style.backgroundColor = firstObject.statusBarColor;
 59 |             } else if (firstObject.name === 'Refinery') {
 60 |                 healthBarFill.style.backgroundColor = '#00ff00'; // Show health as green
 61 |             } else {
 62 |                 healthBarFill.style.backgroundColor = '#00ff00'; // Default green for health
 63 |             }
 64 | 
 65 |             // Show health/resource text
 66 |             if (firstObject.name === 'Refinery' && firstObject.geyser) {
 67 |                 unitName.innerHTML = `${firstObject.name}<br/><span style="color: #00ff00; font-size: 11px;">Vespene: ${Math.floor(firstObject.geyser.currentVespene)}</span>`;
 68 |                 unitHealthText.textContent = `${Math.ceil(firstObject.currentHealth)} / ${firstObject.maxHealth}`;
 69 |             } else if (firstObject.name.includes('Mineral Field') || firstObject.name.includes('Vespene Geyser')) {
 70 |                 unitHealthText.textContent = `${Math.floor(firstObject.currentHealth)}`;
 71 |             } else {
 72 |                 unitHealthText.textContent = `${Math.ceil(firstObject.currentHealth)} / ${firstObject.maxHealth}`;
 73 |             }
 74 |         } else {
 75 |             statusBarContainer.style.display = 'none';
 76 |             unitHealthText.textContent = '';
 77 |         }
 78 | 
 79 |         // Shield Bar for units that have shields (e.g. Protoss)
 80 |         if (firstObject.maxShields > 0) {
 81 |             const shieldPercent = (firstObject.currentShields / firstObject.maxShields) * 100;
 82 |             shieldBarContainer.style.display = 'block';
 83 |             shieldBarFill.style.width = `${shieldPercent}%`;
 84 |             unitShieldText.textContent = `${Math.floor(firstObject.currentShields)} / ${firstObject.maxShields}`;
 85 |         } else {
 86 |             shieldBarContainer.style.display = 'none';
 87 |         }
 88 | 
 89 |         // Energy Bar display for units that have it (e.g. Comsat, Medic)
 90 |         if (firstObject.maxEnergy > 0) {
 91 |             const energyPercent = (firstObject.energy / firstObject.maxEnergy) * 100;
 92 |             energyBarContainer.style.display = 'block';
 93 |             energyBarFill.style.width = `${energyPercent}%`;
 94 |             unitEnergyText.textContent = `${Math.floor(firstObject.energy)} / ${firstObject.maxEnergy}`;
 95 |         } else {
 96 |             energyBarContainer.style.display = 'none';
 97 |         }
 98 | 
 99 |         // Show selection count if more than one object is selected
100 |         if (selectedObjects.length > 1) {
101 |             unitCountOverlay.style.display = 'block';
102 |             unitCountOverlay.textContent = selectedObjects.length;
103 |         } else {
104 |             unitCountOverlay.style.display = 'none';
105 |         }
106 |     }
107 | }


--------------------------------------------------------------------------------
/src/game/ui/modals/ChangelogModal.js:
--------------------------------------------------------------------------------
  1 | // Handles the changelog modal and archive functionality
  2 | 
  3 | /** @tweakable The filename for the main (recent) changelog document. */
  4 | const CHANGELOG_FILE = 'changelog.md'; // root-relative
  5 | /** @tweakable The filename for the old changelog file. */
  6 | const OLD_CHANGELOG_FILE = 'changelog.old.md';
  7 | /** @tweakable The maximum number of lines to display from the changelog. 0 for no limit. */
  8 | const maxChangelogLines = 50;
  9 | /** @tweakable enable closing the changelog modal by clicking its background */
 10 | const closeChangelogOnClickOutside = true;
 11 | /** @tweakable The default tab to show when opening the changelog modal. Can be 'recent' or 'old'. */
 12 | const defaultChangelogTab = 'recent';
 13 | 
 14 | /**
 15 |  * @tweakable Configuration for formatting ASCL timestamps in the changelog modal.
 16 |  */
 17 | const changelogTimestampConfig = {
 18 |     enabled: true,
 19 |     regex: /\[TS] (\d{6}-\d{4})/g,
 20 |     color: '#88aaff',
 21 |     prefix: '[TS] ',
 22 |     suffix: ''
 23 | };
 24 | 
 25 | export class ChangelogModal {
 26 |     init() {
 27 |         document.getElementById('changelog-button')?.addEventListener('click', () => {
 28 |             const recentOut = document.getElementById('recent-changelog-output');
 29 |             if (recentOut) recentOut.dataset.loaded = 'false';
 30 |             const oldOut = document.getElementById('old-changelog-output');
 31 |             if (oldOut) oldOut.dataset.loaded = 'false';
 32 |             this.toggle();
 33 |         });
 34 |         document.getElementById('close-changelog-modal')?.addEventListener('click', () => this.toggle());
 35 |         document.getElementById('recent-changelog-tab-button')?.addEventListener('click', () => this.switchTab('recent'));
 36 |         document.getElementById('old-changelog-tab-button')?.addEventListener('click', () => this.switchTab('old'));
 37 |         document.getElementById('changelog-modal')?.addEventListener('click', (event) => {
 38 |             if (closeChangelogOnClickOutside && event.target === event.currentTarget) {
 39 |                 this.toggle();
 40 |             }
 41 |         });
 42 |         document.getElementById('archive-changelog-button')?.addEventListener('click', () => this.archive());
 43 |     }
 44 | 
 45 |     switchTab(tabName) {
 46 |         document.querySelectorAll('.changelog-tab').forEach(tab => tab.classList.remove('active'));
 47 |         document.querySelectorAll('.changelog-tab-pane').forEach(pane => pane.classList.remove('active'));
 48 |         document.getElementById(`${tabName}-changelog-tab-button`)?.classList.add('active');
 49 |         document.getElementById(`${tabName}-changelog-tab-content`)?.classList.add('active');
 50 |     }
 51 | 
 52 |     async toggle() {
 53 |         const modal = document.getElementById('changelog-modal');
 54 |         const recentOutput = document.getElementById('recent-changelog-output');
 55 |         const oldOutput = document.getElementById('old-changelog-output');
 56 |         if (!modal || !recentOutput || !oldOutput) return;
 57 | 
 58 |         modal.classList.toggle('hidden');
 59 |         if (modal.classList.contains('hidden')) return;
 60 | 
 61 |         this.switchTab(defaultChangelogTab);
 62 | 
 63 |         if (recentOutput.dataset.loaded !== 'true' || oldOutput.dataset.loaded !== 'true') {
 64 |             recentOutput.textContent = 'Loading...';
 65 |             oldOutput.textContent = 'Loading...';
 66 |             try {
 67 |                 const [recentResponse, oldResponse] = await Promise.all([
 68 |                     fetch(CHANGELOG_FILE).catch(e => { console.warn(`Could not load ${CHANGELOG_FILE}`, e); return null; }),
 69 |                     fetch(OLD_CHANGELOG_FILE).catch(e => { console.warn(`Could not load ${OLD_CHANGELOG_FILE}`, e); return null; })
 70 |                 ]);
 71 | 
 72 |                 let recentText = recentResponse && recentResponse.ok ? await recentResponse.text() : `Error loading ${CHANGELOG_FILE}.`;
 73 |                 let oldText = oldResponse && oldResponse.ok ? await oldResponse.text() : '';
 74 | 
 75 |                 if (maxChangelogLines > 0 && recentText) {
 76 |                     const lines = recentText.split('\n');
 77 |                     if (lines.length > maxChangelogLines) {
 78 |                         recentText = lines.slice(0, maxChangelogLines).join('\n') + `\n\n... (and more)`;
 79 |                     }
 80 |                 }
 81 | 
 82 |                 if (changelogTimestampConfig.enabled) {
 83 |                     const replacement = `<span style="color:${changelogTimestampConfig.color}">${changelogTimestampConfig.prefix}$1${changelogTimestampConfig.suffix}</span>`;
 84 |                     recentText = recentText.replace(changelogTimestampConfig.regex, replacement);
 85 |                     oldText = oldText.replace(changelogTimestampConfig.regex, replacement);
 86 |                 }
 87 | 
 88 |                 recentOutput.innerHTML = recentText;
 89 |                 oldOutput.innerHTML = oldText || 'No archived entries.';
 90 |                 recentOutput.dataset.loaded = 'true';
 91 |                 oldOutput.dataset.loaded = 'true';
 92 |             } catch (error) {
 93 |                 console.error('Failed to fetch changelogs:', error);
 94 |                 recentOutput.textContent = 'Error loading changelog.';
 95 |                 oldOutput.textContent = 'Error loading changelog.';
 96 |             }
 97 |         }
 98 |     }
 99 | 
100 |     async archive() {
101 |         alert('This feature is for demonstration purposes. In a real environment, this would modify files on the server. The logic has been implemented but file writing is disabled for safety.');
102 |         console.log('Changelog archive process started.');
103 |         // See ModalManager.js for the full implementation that would write files.
104 |     }
105 | }
106 | 


--------------------------------------------------------------------------------
/src/game/ui/modals/DevLogModal.js:
--------------------------------------------------------------------------------
 1 | import { devLogger } from '../../../utils/dev-logger.js';
 2 | 
 3 | export class DevLogModal {
 4 |     constructor() {
 5 |         this.menuManager = null;
 6 |     }
 7 | 
 8 |     init(menuManager) {
 9 |         this.menuManager = menuManager;
10 |         document.getElementById('close-dev-log-modal')?.addEventListener('click', () => this.toggle());
11 |         document.getElementById('clear-dev-log-button')?.addEventListener('click', () => devLogger.clearLogs());
12 |         window.addEventListener('keyup', (e) => {
13 |             if (e.code === 'Backslash' && devLogger.isActive && this.menuManager?.isPaused) {
14 |                 this.toggle();
15 |             }
16 |         });
17 |     }
18 | 
19 |     toggle() {
20 |         const modal = document.getElementById('dev-log-modal');
21 |         const output = document.getElementById('dev-log-output');
22 |         if (!modal || !output) return;
23 | 
24 |         modal.classList.toggle('hidden');
25 |         if (!modal.classList.contains('hidden')) {
26 |             output.textContent = devLogger.getLogs().join('\n');
27 |         }
28 |     }
29 | }
30 | 


--------------------------------------------------------------------------------
/src/game/ui/modals/ManualModal.js:
--------------------------------------------------------------------------------
  1 | // Handles the manual and asset list modal
  2 | 
  3 | /** @tweakable The filename for the manual document. */
  4 | const MANUAL_FILE = 'manual.md';
  5 | /** @tweakable The maximum number of lines to display from the manual. 0 for no limit. */
  6 | const maxManualLines = 0;
  7 | /** @tweakable enable closing the manual modal by clicking its background */
  8 | const closeManualOnClickOutside = true;
  9 | 
 10 | /** @tweakable The title for the asset list section in the manual modal. */
 11 | const ASSET_LIST_TITLE = 'Generated Assets';
 12 | /** @tweakable Enable or disable showing the asset list in the manual modal. */
 13 | const showAssetListInManual = true;
 14 | /** @tweakable The default tab to show when opening the manual modal. Can be 'manual' or 'assets'. */
 15 | const defaultManualTab = 'manual';
 16 | 
 17 | /** @tweakable CSS object-fit property for asset icons in the manual. Can be 'contain', 'cover', 'fill', 'none', 'scale-down'. */
 18 | const assetIconObjectFit = 'contain';
 19 | 
 20 | /** @tweakable CSS image-rendering property for asset icons. Helps with pixel art. Can be 'auto', 'smooth', 'high-quality', 'pixelated', 'crisp-edges'. */
 21 | const assetIconImageRendering = 'pixelated';
 22 | 
 23 | export class ManualModal {
 24 |     init() {
 25 |         document.getElementById('manual-button')?.addEventListener('click', () => this.toggle());
 26 |         document.getElementById('close-manual-modal')?.addEventListener('click', () => this.toggle());
 27 |         document.getElementById('manual-modal')?.addEventListener('click', (event) => {
 28 |             if (closeManualOnClickOutside && event.target === event.currentTarget) {
 29 |                 this.toggle();
 30 |             }
 31 |         });
 32 |         document.getElementById('manual-tab-button')?.addEventListener('click', () => this.switchTab('manual'));
 33 |         document.getElementById('assets-tab-button')?.addEventListener('click', () => this.switchTab('assets'));
 34 |     }
 35 | 
 36 |     switchTab(tabName) {
 37 |         document.querySelectorAll('.manual-tab').forEach(tab => tab.classList.remove('active'));
 38 |         document.querySelectorAll('.manual-tab-pane').forEach(pane => pane.classList.remove('active'));
 39 |         document.getElementById(`${tabName}-tab-button`)?.classList.add('active');
 40 |         document.getElementById(`${tabName}-tab-content`)?.classList.add('active');
 41 |     }
 42 | 
 43 |     async toggle() {
 44 |         const modal = document.getElementById('manual-modal');
 45 |         const output = document.getElementById('manual-output');
 46 |         const assetListDiv = document.getElementById('asset-list');
 47 |         const assetsTabButton = document.getElementById('assets-tab-button');
 48 |         if (!modal || !output || !assetListDiv || !assetsTabButton) return;
 49 | 
 50 |         assetsTabButton.style.display = showAssetListInManual ? 'block' : 'none';
 51 |         modal.classList.toggle('hidden');
 52 |         if (modal.classList.contains('hidden')) return;
 53 | 
 54 |         this.switchTab(defaultManualTab);
 55 | 
 56 |         if (output.dataset.loaded !== 'true') {
 57 |             try {
 58 |                 const response = await fetch(MANUAL_FILE);
 59 |                 if (response.ok) {
 60 |                     let text = await response.text();
 61 |                     if (maxManualLines > 0) {
 62 |                         const lines = text.split('\n');
 63 |                         if (lines.length > maxManualLines) {
 64 |                             text = lines.slice(0, maxManualLines).join('\n') + `\n\n... (and more)`;
 65 |                         }
 66 |                     }
 67 |                     output.textContent = text;
 68 |                     output.dataset.loaded = 'true';
 69 |                 } else {
 70 |                     output.textContent = 'Error loading manual.';
 71 |                 }
 72 |             } catch (error) {
 73 |                 console.error(`Failed to fetch ${MANUAL_FILE}:`, error);
 74 |                 output.textContent = 'Error loading manual.';
 75 |             }
 76 |         }
 77 | 
 78 |         if (showAssetListInManual && assetListDiv.dataset.loaded !== 'true') {
 79 |             try {
 80 |                 const response = await fetch('assets/asset-list.json');
 81 |                 if (response.ok) {
 82 |                     const assetList = await response.json();
 83 |                     assetListDiv.innerHTML = assetList.map(assetPath => {
 84 |                         const fileName = assetPath.split('/').pop();
 85 |                         const correctedPath = assetPath.startsWith('/') ? `.${assetPath}` : assetPath;
 86 |                         return `
 87 |                             <div class="asset-item" title="${assetPath}">
 88 |                                 <img src="${correctedPath}" alt="${fileName}" loading="lazy" style="object-fit: ${assetIconObjectFit}; image-rendering: ${assetIconImageRendering};">
 89 |                                 <span class="asset-name">${fileName}</span>
 90 |                             </div>
 91 |                         `;
 92 |                     }).join('');
 93 |                     assetListDiv.dataset.loaded = 'true';
 94 |                     document.querySelector('#asset-list-title').textContent = ASSET_LIST_TITLE;
 95 |                 } else {
 96 |                     assetListDiv.textContent = 'Error loading asset list.';
 97 |                 }
 98 |             } catch (error) {
 99 |                 console.error('Failed to fetch asset-list.json:', error);
100 |                 assetListDiv.textContent = 'Error loading asset list.';
101 |             }
102 |         }
103 |     }
104 | }
105 | 


--------------------------------------------------------------------------------
/src/game/ui/modals/PromoModal.js:
--------------------------------------------------------------------------------
 1 | export class PromoModal {
 2 |     init() {
 3 |         document.getElementById('close-promo-modal')?.addEventListener('click', () => this.toggle());
 4 |         document.getElementById('promo-modal')?.addEventListener('click', (event) => {
 5 |             if (event.target === event.currentTarget) {
 6 |                 this.toggle();
 7 |             }
 8 |         });
 9 |     }
10 | 
11 |     toggle() {
12 |         const modal = document.getElementById('promo-modal');
13 |         const iframe = document.getElementById('promo-video');
14 |         if (!modal) return;
15 | 
16 |         modal.classList.toggle('hidden');
17 |         if (iframe) {
18 |             if (modal.classList.contains('hidden')) {
19 |                 iframe.src = '';
20 |             } else {
21 |                 iframe.src = 'https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1';
22 |             }
23 |         }
24 |     }
25 | }
26 | 


--------------------------------------------------------------------------------
/src/protoss/adept.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from '../units/infantry.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | export class Adept extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 |         
  9 |         const unitData = assetManager.get('unit_adept').stats;
 10 |         this.name = 'Adept';
 11 |         this.portraitUrl = 'assets/images/protoss/adept_portrait.png';
 12 |         this.maxHealth = unitData.health;
 13 |         this.currentHealth = unitData.health;
 14 |         this.maxShields = unitData.shields;
 15 |         this.currentShields = unitData.shields;
 16 |         this.armor = unitData.armor;
 17 |         this.speed = unitData.speed;
 18 |         this.timeSinceLastDamage = Infinity;
 19 | 
 20 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 21 |         
 22 |         /** @tweakable Shield recharge rate for Adepts (shields per second). */
 23 |         this.shieldRechargeRate = 2;
 24 | 
 25 |         this.commands = [
 26 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 27 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 28 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 29 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 30 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 31 |         ];
 32 |         
 33 |         try {
 34 |             const asset = assetManager.get('protoss_adept');
 35 |             this.mesh = this.createMeshFromGLB(asset);
 36 |         } catch (error) {
 37 |             console.warn("Could not load adept model, using procedural fallback.", error);
 38 |             this.mesh = this.createProceduralMesh();
 39 |         }
 40 | 
 41 |         this.setup(position); 
 42 |     }
 43 | 
 44 |     createMeshFromGLB(asset) {
 45 |         const model = asset.scene.clone();
 46 | 
 47 |         const box = new THREE.Box3().setFromObject(model);
 48 |         const size = box.getSize(new THREE.Vector3());
 49 |         const desiredSize = 2.0; 
 50 |         const maxDim = Math.max(size.x, size.y, size.z);
 51 |         
 52 |         if (maxDim > 0) {
 53 |             const scale = desiredSize / maxDim;
 54 |             model.scale.set(scale, scale, scale);
 55 |         }
 56 | 
 57 |         const scaledBox = new THREE.Box3().setFromObject(model);
 58 |         model.position.y = -scaledBox.min.y;
 59 | 
 60 |         model.traverse((child) => {
 61 |             if (child.isMesh) {
 62 |                 child.castShadow = true;
 63 |                 child.userData.owner = this;
 64 |             }
 65 |         });
 66 |         
 67 |         return model;
 68 |     }
 69 | 
 70 |     createProceduralMesh() {
 71 |         const group = new THREE.Group();
 72 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8888cc, metalness: 0.8, roughness: 0.4 });
 73 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeff, metalness: 0.9, roughness: 0.3 });
 74 | 
 75 |         const torsoGeo = new THREE.CylinderGeometry(0.3, 0.2, 1.0, 8);
 76 |         const torso = new THREE.Mesh(torsoGeo, bodyMaterial);
 77 |         torso.position.y = 1.0;
 78 |         group.add(torso);
 79 | 
 80 |         const legGeo = new THREE.BoxGeometry(0.25, 1.0, 0.25);
 81 |         const leftLeg = new THREE.Mesh(legGeo, armorMaterial);
 82 |         leftLeg.position.set(-0.25, 0.5, 0);
 83 |         group.add(leftLeg);
 84 |         const rightLeg = leftLeg.clone();
 85 |         rightLeg.position.x = 0.25;
 86 |         group.add(rightLeg);
 87 | 
 88 |         const headGeo = new THREE.IcosahedronGeometry(0.3, 1);
 89 |         const head = new THREE.Mesh(headGeo, bodyMaterial);
 90 |         head.position.y = 1.6;
 91 |         group.add(head);
 92 | 
 93 |         group.traverse((child) => {
 94 |             if (child.isMesh) {
 95 |                 child.castShadow = true;
 96 |                 child.userData.owner = this;
 97 |             }
 98 |         });
 99 |         
100 |         return group;
101 |     }
102 |     
103 |     update(delta, pathfinder, gameState, buildings, scene) {
104 |         super.update(delta, pathfinder, gameState, buildings, scene);
105 | 
106 |         this.timeSinceLastDamage += delta;
107 | 
108 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
109 |             this.currentShields += this.shieldRechargeRate * delta;
110 |             if (this.currentShields > this.maxShields) {
111 |                 this.currentShields = this.maxShields;
112 |             }
113 |         }
114 |     }
115 | }


--------------------------------------------------------------------------------
/src/protoss/darktemplar.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from '../units/infantry.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | export class DarkTemplar extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 | 
  9 |         const unitData = assetManager.get('unit_darktemplar').stats;
 10 |         this.name = 'Dark Templar';
 11 |         this.portraitUrl = 'assets/images/protoss/darktemplar_portrait.png';
 12 |         this.maxHealth = unitData.health;
 13 |         this.currentHealth = unitData.health;
 14 |         this.maxShields = unitData.shields;
 15 |         this.currentShields = unitData.shields;
 16 |         this.armor = unitData.armor;
 17 |         this.speed = unitData.speed;
 18 |         this.timeSinceLastDamage = Infinity;
 19 | 
 20 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 21 |         /** @tweakable Shield recharge rate for Dark Templar (shields per second). */
 22 |         this.shieldRechargeRate = 2;
 23 | 
 24 |         this.commands = [
 25 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 26 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 27 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 28 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 29 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 30 |         ];
 31 | 
 32 |         try {
 33 |             const asset = assetManager.get('protoss_darktemplar');
 34 |             this.mesh = this.createMeshFromGLB(asset);
 35 |         } catch (error) {
 36 |             console.warn('Could not load dark templar model, using procedural fallback.', error);
 37 |             this.mesh = this.createProceduralMesh();
 38 |         }
 39 | 
 40 |         this.setup(position);
 41 |     }
 42 | 
 43 |     createMeshFromGLB(asset) {
 44 |         const model = asset.scene.clone();
 45 | 
 46 |         const box = new THREE.Box3().setFromObject(model);
 47 |         const size = box.getSize(new THREE.Vector3());
 48 |         const desiredSize = 2.0;
 49 |         const maxDim = Math.max(size.x, size.y, size.z);
 50 | 
 51 |         if (maxDim > 0) {
 52 |             const scale = desiredSize / maxDim;
 53 |             model.scale.set(scale, scale, scale);
 54 |         }
 55 | 
 56 |         const scaledBox = new THREE.Box3().setFromObject(model);
 57 |         model.position.y = -scaledBox.min.y;
 58 | 
 59 |         model.traverse((child) => {
 60 |             if (child.isMesh) {
 61 |                 child.castShadow = true;
 62 |                 child.userData.owner = this;
 63 |             }
 64 |         });
 65 | 
 66 |         return model;
 67 |     }
 68 | 
 69 |     createProceduralMesh() {
 70 |         const group = new THREE.Group();
 71 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.4 });
 72 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.3 });
 73 | 
 74 |         const torsoGeo = new THREE.CylinderGeometry(0.35, 0.25, 1.2, 8);
 75 |         const torso = new THREE.Mesh(torsoGeo, bodyMaterial);
 76 |         torso.position.y = 1.0;
 77 |         group.add(torso);
 78 | 
 79 |         const legGeo = new THREE.BoxGeometry(0.25, 1.0, 0.25);
 80 |         const leftLeg = new THREE.Mesh(legGeo, armorMaterial);
 81 |         leftLeg.position.set(-0.25, 0.5, 0);
 82 |         group.add(leftLeg);
 83 |         const rightLeg = leftLeg.clone();
 84 |         rightLeg.position.x = 0.25;
 85 |         group.add(rightLeg);
 86 | 
 87 |         const headGeo = new THREE.IcosahedronGeometry(0.3, 1);
 88 |         const head = new THREE.Mesh(headGeo, bodyMaterial);
 89 |         head.position.y = 1.6;
 90 |         group.add(head);
 91 | 
 92 |         group.traverse((child) => {
 93 |             if (child.isMesh) {
 94 |                 child.castShadow = true;
 95 |                 child.userData.owner = this;
 96 |             }
 97 |         });
 98 | 
 99 |         return group;
100 |     }
101 | 
102 |     update(delta, pathfinder, gameState, buildings, scene) {
103 |         super.update(delta, pathfinder, gameState, buildings, scene);
104 | 
105 |         this.timeSinceLastDamage += delta;
106 | 
107 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
108 |             this.currentShields += this.shieldRechargeRate * delta;
109 |             if (this.currentShields > this.maxShields) {
110 |                 this.currentShields = this.maxShields;
111 |             }
112 |         }
113 |     }
114 | }
115 | 


--------------------------------------------------------------------------------
/src/protoss/dragoon.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from '../units/infantry.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | export class Dragoon extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 |         
  9 |         const unitData = assetManager.get('unit_dragoon').stats;
 10 |         this.name = 'Dragoon';
 11 |         this.portraitUrl = 'assets/images/protoss/dragoon_portrait.png';
 12 |         this.maxHealth = unitData.health;
 13 |         this.currentHealth = unitData.health;
 14 |         this.maxShields = unitData.shields;
 15 |         this.currentShields = unitData.shields;
 16 |         this.armor = unitData.armor;
 17 |         this.speed = unitData.speed;
 18 |         this.timeSinceLastDamage = Infinity;
 19 | 
 20 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 21 |         
 22 |         /** @tweakable Shield recharge rate for Dragoons (shields per second). */
 23 |         this.shieldRechargeRate = 2;
 24 | 
 25 |         this.commands = [
 26 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 27 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 28 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 29 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 30 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 31 |         ];
 32 |         
 33 |         try {
 34 |             const asset = assetManager.get('protoss_dragoon');
 35 |             this.mesh = this.createMeshFromGLB(asset);
 36 |         } catch (error) {
 37 |             console.warn("Could not load dragoon model, using procedural fallback.", error);
 38 |             this.mesh = this.createProceduralMesh();
 39 |         }
 40 | 
 41 |         this.setup(position); 
 42 |     }
 43 | 
 44 |     createMeshFromGLB(asset) {
 45 |         const model = asset.scene.clone();
 46 | 
 47 |         const box = new THREE.Box3().setFromObject(model);
 48 |         const size = box.getSize(new THREE.Vector3());
 49 |         const desiredSize = 2.5; 
 50 |         const maxDim = Math.max(size.x, size.y, size.z);
 51 |         
 52 |         if (maxDim > 0) {
 53 |             const scale = desiredSize / maxDim;
 54 |             model.scale.set(scale, scale, scale);
 55 |         }
 56 | 
 57 |         const scaledBox = new THREE.Box3().setFromObject(model);
 58 |         model.position.y = -scaledBox.min.y;
 59 | 
 60 |         model.traverse((child) => {
 61 |             if (child.isMesh) {
 62 |                 child.castShadow = true;
 63 |                 child.userData.owner = this;
 64 |             }
 65 |         });
 66 |         
 67 |         return model;
 68 |     }
 69 | 
 70 |     createProceduralMesh() {
 71 |         const group = new THREE.Group();
 72 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4a6a8a, metalness: 0.9, roughness: 0.4 });
 73 |         const coreMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.8 });
 74 | 
 75 |         const torsoGeo = new THREE.SphereGeometry(0.8, 8, 6);
 76 |         const torso = new THREE.Mesh(torsoGeo, bodyMaterial);
 77 |         torso.position.y = 1.0;
 78 |         group.add(torso);
 79 | 
 80 |         const coreGeo = new THREE.SphereGeometry(0.4, 16, 8);
 81 |         const core = new THREE.Mesh(coreGeo, coreMaterial);
 82 |         core.position.y = 1.0;
 83 |         group.add(core);
 84 | 
 85 |         const legGeo = new THREE.CylinderGeometry(0.15, 0.1, 1.8, 6);
 86 |         
 87 |         const frontLeftLeg = new THREE.Mesh(legGeo, bodyMaterial);
 88 |         frontLeftLeg.position.set(-0.7, 0.9, 0.7);
 89 |         frontLeftLeg.rotation.z = Math.PI / 6;
 90 |         group.add(frontLeftLeg);
 91 |         
 92 |         const frontRightLeg = frontLeftLeg.clone();
 93 |         frontRightLeg.position.x = 0.7;
 94 |         frontRightLeg.rotation.z = -Math.PI / 6;
 95 |         group.add(frontRightLeg);
 96 |         
 97 |         const backLeftLeg = frontLeftLeg.clone();
 98 |         backLeftLeg.position.z = -0.7;
 99 |         group.add(backLeftLeg);
100 |         
101 |         const backRightLeg = frontRightLeg.clone();
102 |         backRightLeg.position.z = -0.7;
103 |         group.add(backRightLeg);
104 |         
105 |         const cannonGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.0, 8);
106 |         const cannon = new THREE.Mesh(cannonGeo, bodyMaterial);
107 |         cannon.position.y = 1.6;
108 |         cannon.rotation.x = Math.PI / 4;
109 |         group.add(cannon);
110 | 
111 |         group.traverse((child) => {
112 |             if (child.isMesh) {
113 |                 child.castShadow = true;
114 |                 child.userData.owner = this;
115 |             }
116 |         });
117 |         
118 |         return group;
119 |     }
120 |     
121 |     update(delta, pathfinder, gameState, buildings, scene) {
122 |         super.update(delta, pathfinder, gameState, buildings, scene);
123 | 
124 |         this.timeSinceLastDamage += delta;
125 | 
126 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
127 |             this.currentShields += this.shieldRechargeRate * delta;
128 |             if (this.currentShields > this.maxShields) {
129 |                 this.currentShields = this.maxShields;
130 |             }
131 |         }
132 |     }
133 | }
134 | 
135 | 


--------------------------------------------------------------------------------
/src/protoss/hightemplar.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { Infantry } from '../units/infantry.js';
 3 | import { assetManager } from '../utils/asset-manager.js';
 4 | 
 5 | export class HighTemplar extends Infantry {
 6 |     constructor(position) {
 7 |         super(position);
 8 | 
 9 |         const unitData = assetManager.get('unit_hightemplar').stats;
10 |         this.name = 'High Templar';
11 |         this.portraitUrl = 'assets/images/protoss/zealot_portrait.png';
12 |         this.maxHealth = unitData.health;
13 |         this.currentHealth = unitData.health;
14 |         this.maxShields = unitData.shields;
15 |         this.currentShields = unitData.shields;
16 |         this.armor = unitData.armor;
17 |         this.speed = unitData.speed;
18 |         this.maxEnergy = unitData.energy;
19 |         this.currentEnergy = unitData.energy;
20 |         this.timeSinceLastDamage = Infinity;
21 | 
22 |         this.shieldRechargeDelay = 7;
23 |         /** @tweakable Shield recharge rate for High Templar (shields per second). */
24 |         this.shieldRechargeRate = 2;
25 | 
26 |         this.commands = [
27 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
28 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
29 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
30 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
31 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
32 |         ];
33 | 
34 |         this.mesh = this.createProceduralMesh();
35 |         this.setup(position);
36 |     }
37 | 
38 |     createProceduralMesh() {
39 |         const group = new THREE.Group();
40 |         const robeMaterial = new THREE.MeshStandardMaterial({ color: 0x88aaff, metalness: 0.3, roughness: 0.8 });
41 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.5, roughness: 0.5 });
42 | 
43 |         const robeGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12);
44 |         const robe = new THREE.Mesh(robeGeo, robeMaterial);
45 |         robe.position.y = 0.6;
46 |         group.add(robe);
47 | 
48 |         const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
49 |         const head = new THREE.Mesh(headGeo, bodyMaterial);
50 |         head.position.y = 1.4;
51 |         group.add(head);
52 | 
53 |         group.traverse(child => {
54 |             if (child.isMesh) {
55 |                 child.castShadow = true;
56 |                 child.userData.owner = this;
57 |             }
58 |         });
59 | 
60 |         return group;
61 |     }
62 | 
63 |     update(delta, pathfinder, gameState, buildings, scene) {
64 |         super.update(delta, pathfinder, gameState, buildings, scene);
65 | 
66 |         this.timeSinceLastDamage += delta;
67 | 
68 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
69 |             this.currentShields += this.shieldRechargeRate * delta;
70 |             if (this.currentShields > this.maxShields) {
71 |                 this.currentShields = this.maxShields;
72 |             }
73 |         }
74 |     }
75 | }
76 | 


--------------------------------------------------------------------------------
/src/protoss/probe.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { getTerrainHeight } from '../utils/terrain.js';
  4 | 
  5 | export class Probe {
  6 |     constructor(position) {
  7 |         const unitData = assetManager.get('unit_probe').stats;
  8 |         this.name = 'Probe';
  9 |         this.portraitUrl = 'assets/images/protoss/probe_portrait.png';
 10 |         
 11 |         this.maxHealth = unitData.health;
 12 |         this.currentHealth = unitData.health;
 13 |         this.maxShields = unitData.shields;
 14 |         this.currentShields = unitData.shields;
 15 |         this.armor = unitData.armor;
 16 |         this.timeSinceLastDamage = Infinity;
 17 |         
 18 |         this.state = 'idle'; // idle, moving, movingToResource, gathering, returning
 19 |         this.isGarrisoned = false; // Cannot be garrisoned
 20 |         this.isStuckOnDepot = false; // Not really applicable but for consistency
 21 |         this.stuckOnDepotInstance = null;
 22 |         this.isFlying = true; // Probes hover
 23 | 
 24 |         this.targetResource = null;
 25 |         this.gatherPosition = null;
 26 |         this.dropOffPoint = null;
 27 |         this.resourceLoad = 0;
 28 |         this.resourceType = null;
 29 |         this.carryCapacity = unitData.carryCapacity;
 30 |         this.gatherTime = unitData.gatherTime;
 31 |         this.gatherProgress = 0;
 32 | 
 33 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 34 |         
 35 |         /** @tweakable Shield recharge rate for Probes (shields per second). */
 36 |         this.shieldRechargeRate = 2;
 37 | 
 38 |         this.commands = [
 39 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 40 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 41 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 42 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 43 |             { command: 'gather', hotkey: 'G', icon: 'assets/images/gather_icon.png', name: 'Gather' },
 44 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 45 |         ];
 46 |         
 47 |         this.hoverHeight = 0.5;
 48 |         this.baseY = position.y + this.hoverHeight;
 49 |         
 50 |         try {
 51 |             const asset = assetManager.get('protoss_probe');
 52 |             this.mesh = this.createMeshFromGLB(asset);
 53 |         } catch (error) {
 54 |             console.warn("Could not load probe model, using procedural fallback.", error);
 55 |             this.mesh = this.createProceduralMesh();
 56 |         }
 57 | 
 58 |         this.mesh.position.copy(position);
 59 |         this.mesh.position.y = this.baseY;
 60 | 
 61 |         this.selected = false;
 62 |         this.path = [];
 63 |         this.currentWaypointIndex = 0;
 64 |         this.speed = unitData.speed;
 65 | 
 66 |         this.driveTime = Math.random() * Math.PI * 2;
 67 |         this.driveFrequency = 8;
 68 |         this.driveAmplitude = 0.1;
 69 | 
 70 |         const selectionGeometry = new THREE.RingGeometry(0.6, 0.7, 32);
 71 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 72 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 73 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 74 |         this.selectionIndicator.position.y = position.y + 0.01;
 75 |         this.selectionIndicator.visible = false;
 76 |         this.selectionIndicator.userData.owner = this;
 77 |         
 78 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 79 |         
 80 |         this.addCarryVisuals(this.mesh);
 81 |     }
 82 |     
 83 |     addCarryVisuals(model) {
 84 |         // Probe warps resources, so just a glow
 85 |         const glowMaterial = new THREE.SpriteMaterial({ color: 0x41aeff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
 86 |         this.resourceGlow = new THREE.Sprite(glowMaterial);
 87 |         this.resourceGlow.scale.set(1.5, 1.5, 1.5);
 88 |         this.resourceGlow.position.set(0, 0.2, 0);
 89 |         model.add(this.resourceGlow);
 90 |     }
 91 | 
 92 |     createMeshFromGLB(asset) {
 93 |         const model = asset.scene.clone();
 94 | 
 95 |         const box = new THREE.Box3().setFromObject(model);
 96 |         const size = box.getSize(new THREE.Vector3());
 97 |         const desiredSize = 1.0; 
 98 |         const maxDim = Math.max(size.x, size.y, size.z);
 99 |         
100 |         if (maxDim > 0) {
101 |             const scale = desiredSize / maxDim;
102 |             model.scale.set(scale, scale, scale);
103 |         }
104 |         
105 |         const scaledBox = new THREE.Box3().setFromObject(model);
106 |         model.position.y = -scaledBox.min.y;
107 | 
108 |         const wrapper = new THREE.Group();
109 |         wrapper.add(model);
110 | 
111 |         wrapper.traverse((child) => {
112 |             if (child.isMesh) {
113 |                 child.castShadow = true;
114 |                 child.receiveShadow = true;
115 |                 child.userData.owner = this;
116 |             }
117 |         });
118 |         
119 |         return wrapper;
120 |     }
121 | 
122 |     createProceduralMesh() {
123 |         const group = new THREE.Group();
124 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0xdaa520, metalness: 0.8, roughness: 0.4 });
125 |         const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x00a1ff, emissive: 0x00a1ff, emissiveIntensity: 0.8 });
126 | 
127 |         const bodyGeo = new THREE.IcosahedronGeometry(0.5, 1);
128 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
129 |         group.add(body);
130 | 
131 |         const eyeGeo = new THREE.SphereGeometry(0.2, 16, 8);
132 |         const eye = new THREE.Mesh(eyeGeo, eyeMaterial);
133 |         eye.position.z = 0.4;
134 |         group.add(eye);
135 |         
136 |         group.traverse((child) => {
137 |             if (child.isMesh) {
138 |                 child.castShadow = true;
139 |                 child.receiveShadow = true;
140 |                 child.userData.owner = this;
141 |             }
142 |         });
143 |         
144 |         return group;
145 |     }
146 |     
147 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
148 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
149 |     
150 |     stopActions() {
151 |         if (this.targetResource && this.targetResource.removeMiner) {
152 |             this.targetResource.removeMiner(this);
153 |         }
154 |         this.targetResource = null;
155 |         this.gatherPosition = null;
156 |         this.dropOffPoint = null;
157 |         this.resourceLoad = 0;
158 |         this.resourceType = null;
159 |     }
160 |     
161 |     setPath(path) {
162 |         if (path && path.length > 0) {
163 |             this.path = path;
164 |             this.currentWaypointIndex = 0;
165 |         } else {
166 |             this.path = [];
167 |         }
168 |     }
169 |     
170 |     findClosestDropOff(allBuildings) {
171 |         let closest = null;
172 |         let minDistance = Infinity;
173 |         // Probes drop off at a Nexus, which isn't in the game yet.
174 |         // As a fallback, they'll use the Command Center.
175 |         const depots = allBuildings.filter(b => b.name === 'Command Center' || b.name === 'Nexus');
176 |         if (depots.length === 0) return;
177 | 
178 |         depots.forEach(building => {
179 |             const distance = this.mesh.position.distanceToSquared(building.mesh.position);
180 |             if (distance < minDistance) {
181 |                 minDistance = distance;
182 |                 closest = building;
183 |             }
184 |         });
185 |         this.dropOffPoint = closest;
186 |     }
187 | 
188 |     gather(resource, allBuildings, gatherPosition) {
189 |         this.stopActions();
190 |         this.targetResource = resource;
191 |         if (typeof this.targetResource.addMiner === 'function') {
192 |             this.targetResource.addMiner(this);
193 |         }
194 |         this.gatherPosition = gatherPosition;
195 |         this.findClosestDropOff(allBuildings);
196 |         if (this.targetResource && this.dropOffPoint) {
197 |             this.state = 'movingToResource';
198 |             this.path = [];
199 |         } else {
200 |             this.state = 'idle';
201 |         }
202 |     }
203 | 
204 |     update(delta, pathfinder, gameState, buildings, scene) {
205 |         this.timeSinceLastDamage += delta;
206 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
207 |             this.currentShields += this.shieldRechargeRate * delta;
208 |             if (this.currentShields > this.maxShields) {
209 |                 this.currentShields = this.maxShields;
210 |             }
211 |         }
212 |         
213 |         if (this.resourceLoad > 0) {
214 |             this.resourceGlow.material.opacity = 0.8;
215 |             this.resourceGlow.material.color.set(this.resourceType === 'minerals' ? 0x41aeff : 0x00ff00);
216 |         } else {
217 |             this.resourceGlow.material.opacity = 0;
218 |         }
219 | 
220 |         switch (this.state) {
221 |             case 'idle':
222 |                  this.driveTime += delta;
223 |                  this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
224 |                 break;
225 |             case 'moving':
226 |                 this.updateMovement(delta, scene, () => { this.state = 'idle'; });
227 |                 break;
228 |             case 'movingToResource':
229 |                 if (!this.targetResource || this.targetResource.isDepleted) {
230 |                     this.state = 'idle'; this.targetResource = null; this.gatherPosition = null; return;
231 |                 }
232 |                 if (!this.path || this.path.length === 0) {
233 |                     const targetPos = this.gatherPosition || this.targetResource.mesh.position;
234 |                     this.setPath(pathfinder.findPath(this.mesh.position, targetPos));
235 |                     if (!this.path || this.path.length === 0) { this.state = 'idle'; return; }
236 |                 }
237 |                 this.updateMovement(delta, scene, () => {
238 |                     this.mesh.lookAt(this.targetResource.mesh.position);
239 |                     this.state = 'gathering'; this.gatherProgress = 0;
240 |                 });
241 |                 break;
242 |             case 'gathering':
243 |                 this.gatherProgress += delta;
244 |                 if (this.gatherProgress >= this.gatherTime) {
245 |                     this.gatherProgress = 0;
246 |                     const amountExtracted = this.targetResource.extract(this.carryCapacity);
247 |                     if (amountExtracted > 0) {
248 |                         this.resourceLoad = amountExtracted;
249 |                         this.resourceType = this.targetResource.resourceType;
250 |                         this.state = 'returning'; this.path = [];
251 |                     } else {
252 |                         this.state = 'idle';
253 |                         this.targetResource = null;
254 |                     }
255 |                 }
256 |                 break;
257 |             case 'returning':
258 |                  if (!this.dropOffPoint) {
259 |                     this.findClosestDropOff(buildings);
260 |                     if (!this.dropOffPoint) { this.state = 'idle'; return; }
261 |                  }
262 |                 if(!this.path || this.path.length === 0) {
263 |                     this.setPath(pathfinder.findPath(this.mesh.position, this.dropOffPoint.mesh.position));
264 |                     if(!this.path || this.path.length === 0) { this.state = 'idle'; return; }
265 |                 }
266 |                 this.updateMovement(delta, scene, () => {
267 |                     if (this.resourceType === 'minerals') gameState.minerals += this.resourceLoad;
268 |                     else if (this.resourceType === 'vespene') gameState.vespene += this.resourceLoad;
269 |                     this.resourceLoad = 0; this.resourceType = null;
270 |                     if (this.targetResource && !this.targetResource.isDepleted) {
271 |                         this.state = 'movingToResource'; this.path = [];
272 |                     } else {
273 |                         this.state = 'idle'; this.targetResource = null;
274 |                     }
275 |                 });
276 |                 break;
277 |         }
278 | 
279 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
280 |     }
281 | 
282 |     updateMovement(delta, scene, onPathComplete) {
283 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
284 |             if (onPathComplete) onPathComplete();
285 |             return;
286 |         }
287 |         const targetPosition = this.path[this.currentWaypointIndex];
288 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
289 |         targetPosition.y = targetY + this.hoverHeight;
290 |         const distance = this.mesh.position.distanceTo(targetPosition);
291 | 
292 |         if (distance < 0.2) {
293 |             this.currentWaypointIndex++;
294 |         } else {
295 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
296 |             const moveDistance = this.speed * delta;
297 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
298 | 
299 |             if (moveVector.length() > distance) moveVector.setLength(distance);
300 | 
301 |             this.mesh.position.add(moveVector);
302 | 
303 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
304 |             this.mesh.lookAt(lookAtTarget);
305 |         }
306 |         
307 |         if (this.currentWaypointIndex >= this.path.length) {
308 |             this.path = [];
309 |             if (onPathComplete) onPathComplete();
310 |         }
311 |     }
312 | }


--------------------------------------------------------------------------------
/src/protoss/stalker.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from '../units/infantry.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | export class Stalker extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 | 
  9 |         const unitData = assetManager.get('unit_stalker').stats;
 10 |         this.name = 'Stalker';
 11 |         this.portraitUrl = 'assets/images/protoss/stalker_portrait.png';
 12 |         this.maxHealth = unitData.health;
 13 |         this.currentHealth = unitData.health;
 14 |         this.maxShields = unitData.shields;
 15 |         this.currentShields = unitData.shields;
 16 |         this.armor = unitData.armor;
 17 |         this.speed = unitData.speed;
 18 |         this.timeSinceLastDamage = Infinity;
 19 | 
 20 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 21 |         
 22 |         /** @tweakable Shield recharge rate for Stalkers (shields per second). */
 23 |         this.shieldRechargeRate = 2;
 24 | 
 25 |         this.commands = [
 26 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 27 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 28 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 29 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 30 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 31 |         ];
 32 |         
 33 |         try {
 34 |             const asset = assetManager.get('protoss_stalker');
 35 |             this.mesh = this.createMeshFromGLB(asset);
 36 |         } catch (error) {
 37 |             console.warn("Could not load stalker model, using procedural fallback.", error);
 38 |             this.mesh = this.createProceduralMesh();
 39 |         }
 40 | 
 41 |         this.setup(position); 
 42 |     }
 43 | 
 44 |     createMeshFromGLB(asset) {
 45 |         const model = asset.scene.clone();
 46 | 
 47 |         const box = new THREE.Box3().setFromObject(model);
 48 |         const size = box.getSize(new THREE.Vector3());
 49 |         const desiredSize = 2.5; 
 50 |         const maxDim = Math.max(size.x, size.y, size.z);
 51 |         
 52 |         if (maxDim > 0) {
 53 |             const scale = desiredSize / maxDim;
 54 |             model.scale.set(scale, scale, scale);
 55 |         }
 56 | 
 57 |         const scaledBox = new THREE.Box3().setFromObject(model);
 58 |         model.position.y = -scaledBox.min.y;
 59 | 
 60 |         model.traverse((child) => {
 61 |             if (child.isMesh) {
 62 |                 child.castShadow = true;
 63 |                 child.userData.owner = this;
 64 |             }
 65 |         });
 66 |         
 67 |         return model;
 68 |     }
 69 | 
 70 |     createProceduralMesh() {
 71 |         const group = new THREE.Group();
 72 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x333355, metalness: 0.9, roughness: 0.4 });
 73 |         const coreMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.8 });
 74 | 
 75 |         const torsoGeo = new THREE.BoxGeometry(1.2, 0.8, 1.2);
 76 |         const torso = new THREE.Mesh(torsoGeo, bodyMaterial);
 77 |         torso.position.y = 1.2;
 78 |         group.add(torso);
 79 | 
 80 |         const coreGeo = new THREE.SphereGeometry(0.3, 16, 8);
 81 |         const core = new THREE.Mesh(coreGeo, coreMaterial);
 82 |         core.position.y = 1.2;
 83 |         group.add(core);
 84 | 
 85 |         const legGeo = new THREE.CylinderGeometry(0.1, 0.05, 1.5, 6);
 86 |         
 87 |         const frontLeftLeg = new THREE.Mesh(legGeo, bodyMaterial);
 88 |         frontLeftLeg.position.set(-0.5, 0.75, 0.5);
 89 |         frontLeftLeg.rotation.z = Math.PI / 8;
 90 |         group.add(frontLeftLeg);
 91 |         
 92 |         const frontRightLeg = frontLeftLeg.clone();
 93 |         frontRightLeg.position.x = 0.5;
 94 |         frontRightLeg.rotation.z = -Math.PI / 8;
 95 |         group.add(frontRightLeg);
 96 |         
 97 |         const backLeftLeg = frontLeftLeg.clone();
 98 |         backLeftLeg.position.z = -0.5;
 99 |         group.add(backLeftLeg);
100 |         
101 |         const backRightLeg = frontRightLeg.clone();
102 |         backRightLeg.position.z = -0.5;
103 |         group.add(backRightLeg);
104 | 
105 |         group.traverse((child) => {
106 |             if (child.isMesh) {
107 |                 child.castShadow = true;
108 |                 child.userData.owner = this;
109 |             }
110 |         });
111 |         
112 |         return group;
113 |     }
114 |     
115 |     update(delta, pathfinder, gameState, buildings, scene) {
116 |         super.update(delta, pathfinder, gameState, buildings, scene);
117 | 
118 |         this.timeSinceLastDamage += delta;
119 | 
120 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
121 |             this.currentShields += this.shieldRechargeRate * delta;
122 |             if (this.currentShields > this.maxShields) {
123 |                 this.currentShields = this.maxShields;
124 |             }
125 |         }
126 |     }
127 | }


--------------------------------------------------------------------------------
/src/protoss/zealot.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from '../units/infantry.js';
  3 | import { assetManager } from '../utils/asset-manager.js';
  4 | 
  5 | export class Zealot extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 | 
  9 |         const unitData = assetManager.get('unit_zealot').stats;
 10 |         this.name = 'Zealot';
 11 |         this.portraitUrl = 'assets/images/protoss/zealot_portrait.png';
 12 |         this.maxHealth = unitData.health;
 13 |         this.currentHealth = unitData.health;
 14 |         this.maxShields = unitData.shields;
 15 |         this.currentShields = unitData.shields;
 16 |         this.armor = unitData.armor;
 17 |         this.speed = unitData.speed;
 18 |         this.timeSinceLastDamage = Infinity;
 19 | 
 20 |         this.shieldRechargeDelay = 7; // Standard for all Protoss units with shields
 21 |         
 22 |         /** @tweakable Shield recharge rate for Zealots (shields per second). */
 23 |         this.shieldRechargeRate = 2;
 24 | 
 25 |         this.commands = [
 26 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 27 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 28 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 29 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 30 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 31 |         ];
 32 |         
 33 |         try {
 34 |             const asset = assetManager.get('protoss_zealot');
 35 |             this.mesh = this.createMeshFromGLB(asset);
 36 |         } catch (error) {
 37 |             console.warn("Could not load zealot model, using procedural fallback.", error);
 38 |             this.mesh = this.createProceduralMesh();
 39 |         }
 40 | 
 41 |         this.setup(position); 
 42 |     }
 43 | 
 44 |     createMeshFromGLB(asset) {
 45 |         const model = asset.scene.clone();
 46 | 
 47 |         const box = new THREE.Box3().setFromObject(model);
 48 |         const size = box.getSize(new THREE.Vector3());
 49 |         const desiredSize = 2.0; 
 50 |         const maxDim = Math.max(size.x, size.y, size.z);
 51 |         
 52 |         if (maxDim > 0) {
 53 |             const scale = desiredSize / maxDim;
 54 |             model.scale.set(scale, scale, scale);
 55 |         }
 56 | 
 57 |         const scaledBox = new THREE.Box3().setFromObject(model);
 58 |         model.position.y = -scaledBox.min.y;
 59 | 
 60 |         model.traverse((child) => {
 61 |             if (child.isMesh) {
 62 |                 child.castShadow = true;
 63 |                 child.userData.owner = this;
 64 |             }
 65 |         });
 66 |         
 67 |         return model;
 68 |     }
 69 | 
 70 |     createProceduralMesh() {
 71 |         const group = new THREE.Group();
 72 |         const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xdaa520, metalness: 0.8, roughness: 0.4 });
 73 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.9, roughness: 0.3 });
 74 | 
 75 |         const torsoGeo = new THREE.CylinderGeometry(0.4, 0.3, 1.2, 8);
 76 |         const torso = new THREE.Mesh(torsoGeo, bodyMaterial);
 77 |         torso.position.y = 1.0;
 78 |         group.add(torso);
 79 | 
 80 |         const legGeo = new THREE.BoxGeometry(0.3, 1.0, 0.3);
 81 |         const leftLeg = new THREE.Mesh(legGeo, armorMaterial);
 82 |         leftLeg.position.set(-0.3, 0.5, 0);
 83 |         group.add(leftLeg);
 84 |         const rightLeg = leftLeg.clone();
 85 |         rightLeg.position.x = 0.3;
 86 |         group.add(rightLeg);
 87 | 
 88 |         const headGeo = new THREE.IcosahedronGeometry(0.3, 1);
 89 |         const head = new THREE.Mesh(headGeo, bodyMaterial);
 90 |         head.position.y = 1.7;
 91 |         group.add(head);
 92 | 
 93 |         group.traverse((child) => {
 94 |             if (child.isMesh) {
 95 |                 child.castShadow = true;
 96 |                 child.userData.owner = this;
 97 |             }
 98 |         });
 99 |         
100 |         return group;
101 |     }
102 |     
103 |     update(delta, pathfinder, gameState, buildings, scene) {
104 |         super.update(delta, pathfinder, gameState, buildings, scene);
105 | 
106 |         this.timeSinceLastDamage += delta;
107 | 
108 |         if (this.currentShields < this.maxShields && this.timeSinceLastDamage > this.shieldRechargeDelay) {
109 |             this.currentShields += this.shieldRechargeRate * delta;
110 |             if (this.currentShields > this.maxShields) {
111 |                 this.currentShields = this.maxShields;
112 |             }
113 |         }
114 |     }
115 | }


--------------------------------------------------------------------------------
/src/resources/mineral-field.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | 
  4 | export class MineralField {
  5 |     constructor(position) {
  6 |         this.name = 'Mineral Field';
  7 |         this.portraitUrl = 'assets/images/mineral_field_portrait.png';
  8 |         this.maxMinerals = 1500;
  9 |         this.currentMinerals = 1500;
 10 |         this.isDepleted = false;
 11 |         this.statusBarColor = '#4169e1'; // Royal Blue for minerals
 12 |         this.resourceType = 'minerals';
 13 |         this.miners = new Set(); // Keep track of SCVs mining this field
 14 | 
 15 |         this.commands = []; // Mineral fields don't have commands.
 16 | 
 17 |         this.model = this.createMesh();
 18 |         this.mesh = new THREE.Group();
 19 |         this.mesh.add(this.model);
 20 |         this.mesh.position.copy(position);
 21 |         // Raise the model so it rests on the ground while keeping the selection
 22 |         // ring at y=0 on the parent group.
 23 |         const offsetY = this.model.userData.offsetY || 0;
 24 |         this.model.position.y = offsetY;
 25 | 
 26 |         this.mesh.traverse((child) => {
 27 |             if (child instanceof THREE.Mesh) {
 28 |                 child.castShadow = true;
 29 |                 child.userData.owner = this;
 30 |             }
 31 |         });
 32 | 
 33 |         this.selected = false;
 34 |         const selectionGeometry = new THREE.RingGeometry(1.4, 1.5, 32);
 35 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 36 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 37 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 38 |         this.selectionIndicator.position.y = 0.01;
 39 |         this.selectionIndicator.visible = false;
 40 |         this.mesh.add(this.selectionIndicator);
 41 | 
 42 |         // Define a tighter collider
 43 |         this.collider = new THREE.Box3(
 44 |             new THREE.Vector3(-1, 0, -1),
 45 |             new THREE.Vector3(1, 2.5, 1)
 46 |         );
 47 |         this.collider.translate(this.mesh.position);
 48 |     }
 49 | 
 50 |     createMesh() {
 51 |         try {
 52 |             const asset = assetManager.get('extra_minerals');
 53 |             return this.createMeshFromGLB(asset);
 54 |         } catch (error) {
 55 |             // Procedural fallback
 56 |             const group = new THREE.Group();
 57 |             const mineralMaterial = new THREE.MeshStandardMaterial({
 58 |                 color: 0x4169e1, // Royal Blue
 59 |                 metalness: 0.2,
 60 |                 roughness: 0.3,
 61 |                 emissive: 0x2030a0,
 62 |                 emissiveIntensity: 0.4
 63 |             });
 64 | 
 65 |             const numCrystals = 5 + Math.floor(Math.random() * 4); // 5 to 8 crystals
 66 |             this.crystals = [];
 67 | 
 68 |             for (let i = 0; i < numCrystals; i++) {
 69 |                 const height = 1 + Math.random() * 1.5;
 70 |                 const radius = 0.2 + Math.random() * 0.4;
 71 |                 const geometry = new THREE.CylinderGeometry(radius / 2, radius, height, 6);
 72 |                 const crystal = new THREE.Mesh(geometry, mineralMaterial);
 73 | 
 74 |                 crystal.position.set(
 75 |                     (Math.random() - 0.5) * 1.5,
 76 |                     height / 2,
 77 |                     (Math.random() - 0.5) * 1.5
 78 |                 );
 79 | 
 80 |                 crystal.rotation.set(
 81 |                     (Math.random() - 0.5) * Math.PI * 0.2,
 82 |                     Math.random() * Math.PI * 2,
 83 |                     (Math.random() - 0.5) * Math.PI * 0.2
 84 |                 );
 85 | 
 86 |                 group.add(crystal);
 87 |                 this.crystals.push(crystal);
 88 |             }
 89 | 
 90 |             return group;
 91 |         }
 92 |     }
 93 | 
 94 |     createMeshFromGLB(asset) {
 95 |         const model = asset.scene.clone();
 96 | 
 97 |         const box = new THREE.Box3().setFromObject(model);
 98 |         const size = box.getSize(new THREE.Vector3());
 99 |         const desired = new THREE.Vector3(3, 2.5, 3);
100 |         const scale = Math.min(
101 |             desired.x / size.x,
102 |             desired.y / size.y,
103 |             desired.z / size.z
104 |         );
105 | 
106 |         if (scale > 0 && Number.isFinite(scale)) {
107 |             model.scale.set(scale, scale, scale);
108 |         }
109 | 
110 |         // Align the model so its bottom touches the ground. Imported models have
111 |         // their origin at the center, leaving half of them below y=0.
112 |         const adjustedBox = new THREE.Box3().setFromObject(model);
113 |         /**
114 |          * Offset needed to raise the model so its bottom rests on the ground.
115 |          * We apply this after positioning the parent group so the selection
116 |          * indicator remains at ground level.
117 |          */
118 |         const modelYOffset = 0.0;
119 |         const offsetY = -adjustedBox.min.y + modelYOffset;
120 |         model.userData.offsetY = offsetY;
121 | 
122 |         model.traverse(child => {
123 |             if (child.isMesh) {
124 |                 child.castShadow = true;
125 |                 child.receiveShadow = true;
126 |                 child.userData.owner = this;
127 |             }
128 |         });
129 | 
130 |         this.crystals = model.children;
131 | 
132 |         return model;
133 |     }
134 | 
135 |     addMiner(scv) {
136 |         this.miners.add(scv);
137 |     }
138 | 
139 |     removeMiner(scv) {
140 |         this.miners.delete(scv);
141 |     }
142 | 
143 |     extract(amount) {
144 |         if (this.isDepleted) return 0;
145 | 
146 |         const extractableAmount = Math.min(amount, this.currentMinerals);
147 |         this.currentMinerals -= extractableAmount;
148 | 
149 |         if (this.currentMinerals <= 0) {
150 |             this.currentMinerals = 0;
151 |             this.isDepleted = true;
152 |             // Change appearance when depleted by hiding crystals
153 |             this.crystals.forEach(c => c.visible = false);
154 |             // Tell miners to stop
155 |             this.miners.forEach(scv => {
156 |                 if (scv.stopActions) scv.stopActions();
157 |                 if (scv.state) scv.state = 'idle';
158 |             });
159 |             this.miners.clear();
160 |         }
161 | 
162 |         return extractableAmount;
163 |     }
164 | 
165 |     getCollider() {
166 |         return this.collider;
167 |     }
168 | 
169 |     select() {
170 |         this.selected = true;
171 |         this.selectionIndicator.visible = true;
172 |     }
173 | 
174 |     deselect() {
175 |         this.selected = false;
176 |         this.selectionIndicator.visible = false;
177 |     }
178 | 
179 |     get maxHealth() {
180 |         return this.maxMinerals;
181 |     }
182 |     
183 |     get currentHealth() {
184 |         return this.currentMinerals;
185 |     }
186 | }


--------------------------------------------------------------------------------
/src/resources/vespene-geyser.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class VespeneGeyser {
  4 |     constructor(position) {
  5 |         this.name = 'Vespene Geyser';
  6 |         this.portraitUrl = 'assets/images/vespene_geyser_portrait.png';
  7 |         this.maxVespene = 5000;
  8 |         this.currentVespene = 5000;
  9 |         this.isDepleted = false;
 10 |         this.statusBarColor = '#00ff00'; // Green for vespene
 11 |         this.resourceType = 'vespene';
 12 |         this.hasRefinery = false;
 13 | 
 14 |         this.commands = []; // Geysers don't have commands.
 15 | 
 16 |         this.mesh = this.createMesh();
 17 |         this.mesh.position.copy(position);
 18 | 
 19 |         this.mesh.traverse((child) => {
 20 |             if (child instanceof THREE.Mesh) {
 21 |                 child.castShadow = true;
 22 |                 child.userData.owner = this;
 23 |             }
 24 |         });
 25 |         
 26 |         this.gasParticles = this.mesh.children.filter(c => c.userData.isGas);
 27 | 
 28 |         this.selected = false;
 29 |         const selectionGeometry = new THREE.RingGeometry(2.4, 2.5, 32);
 30 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 31 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 32 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 33 |         this.selectionIndicator.position.y = 0.01;
 34 |         this.selectionIndicator.visible = false;
 35 |         this.mesh.add(this.selectionIndicator);
 36 | 
 37 |         // Define a collider
 38 |         this.collider = new THREE.Box3(
 39 |             new THREE.Vector3(-2, 0, -2),
 40 |             new THREE.Vector3(2, 1, 2)
 41 |         );
 42 |         this.collider.translate(this.mesh.position);
 43 |     }
 44 | 
 45 |     createMesh() {
 46 |         const group = new THREE.Group();
 47 |         const moundMaterial = new THREE.MeshStandardMaterial({
 48 |             color: 0x60554a,
 49 |             roughness: 0.8,
 50 |             metalness: 0.1
 51 |         });
 52 | 
 53 |         // Create a mound shape
 54 |         const moundGeo = new THREE.CylinderGeometry(2, 3, 0.5, 12);
 55 |         const mound = new THREE.Mesh(moundGeo, moundMaterial);
 56 |         mound.position.y = 0.25;
 57 |         group.add(mound);
 58 | 
 59 |         // Create the geyser hole rim
 60 |         const rimGeo = new THREE.TorusGeometry(0.8, 0.3, 8, 16);
 61 |         const rim = new THREE.Mesh(rimGeo, moundMaterial);
 62 |         rim.rotation.x = Math.PI / 2;
 63 |         rim.position.y = 0.5;
 64 |         rim.name = 'geyser_rim';
 65 |         group.add(rim);
 66 | 
 67 |         // Create gas particles
 68 |         const gasMaterial = new THREE.MeshBasicMaterial({
 69 |             color: 0x00ff00,
 70 |             transparent: true,
 71 |             opacity: 0.3,
 72 |             side: THREE.DoubleSide,
 73 |             blending: THREE.AdditiveBlending,
 74 |             depthWrite: false,
 75 |         });
 76 | 
 77 |         for (let i = 0; i < 20; i++) {
 78 |             const size = 0.2 + Math.random() * 0.5;
 79 |             const particleGeo = new THREE.PlaneGeometry(size, size);
 80 |             const particle = new THREE.Mesh(particleGeo, gasMaterial);
 81 |             
 82 |             particle.position.set(
 83 |                 (Math.random() - 0.5) * 1.5,
 84 |                 0.5 + Math.random() * 3, // Start at different heights
 85 |                 (Math.random() - 0.5) * 1.5
 86 |             );
 87 |             particle.rotation.y = Math.random() * Math.PI * 2;
 88 |             
 89 |             particle.userData.isGas = true;
 90 |             particle.userData.velocity = 1 + Math.random() * 2; // Upward speed
 91 |             group.add(particle);
 92 |         }
 93 | 
 94 |         return group;
 95 |     }
 96 | 
 97 |     update(delta) {
 98 |         if (this.isDepleted) return;
 99 | 
100 |         this.gasParticles.forEach(particle => {
101 |             particle.position.y += particle.userData.velocity * delta;
102 |             particle.material.opacity = 0.3 * (1.0 - ((particle.position.y - 0.5) / 3.5)); // Fade as it rises
103 | 
104 |             if (particle.position.y > 4) {
105 |                 particle.position.y = 0.5;
106 |                 particle.position.x = (Math.random() - 0.5) * 1.5;
107 |                 particle.position.z = (Math.random() - 0.5) * 1.5;
108 |                 particle.userData.velocity = 1 + Math.random() * 2;
109 |             }
110 |         });
111 |     }
112 | 
113 |     extract(amount) {
114 |         if (this.isDepleted) return 0;
115 | 
116 |         const extractableAmount = Math.min(amount, this.currentVespene);
117 |         this.currentVespene -= extractableAmount;
118 | 
119 |         if (this.currentVespene <= 0) {
120 |             this.currentVespene = 0;
121 |             this.isDepleted = true;
122 |             // Hide gas particles when depleted
123 |             this.gasParticles.forEach(p => p.visible = false);
124 |         }
125 | 
126 |         return extractableAmount;
127 |     }
128 | 
129 |     getCollider() {
130 |         return this.collider;
131 |     }
132 | 
133 |     select() {
134 |         this.selected = true;
135 |         this.selectionIndicator.visible = true;
136 |     }
137 | 
138 |     deselect() {
139 |         this.selected = false;
140 |         this.selectionIndicator.visible = false;
141 |     }
142 | 
143 |     // Use getters to map vespene count to the UI's health bar properties
144 |     get maxHealth() {
145 |         return this.maxVespene;
146 |     }
147 |     
148 |     get currentHealth() {
149 |         return this.currentVespene;
150 |     }
151 | }


--------------------------------------------------------------------------------
/src/units/battlecruiser.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { createYamatoBlast } from '../game/effects.js';
  4 | 
  5 | export class Battlecruiser {
  6 |     constructor(position) {
  7 |         this.name = 'Battlecruiser';
  8 |         this.portraitUrl = 'assets/images/battlecruiser_portrait.png';
  9 |         this.maxHealth = 500;
 10 |         this.currentHealth = 500;
 11 |         this.armor = 3;
 12 |         this.isFlying = true;
 13 |         this.hoverHeight = 11;
 14 | 
 15 |         this.energy = 50;
 16 |         this.maxEnergy = 200;
 17 | 
 18 |         this.isGarrisoned = false;
 19 |         this.state = 'idle';
 20 | 
 21 |         this.commands = [
 22 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 23 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 24 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 25 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 26 |             null,
 27 |             { command: 'yamato_cannon', hotkey: 'Y', icon: 'assets/images/yamato_cannon_icon.png', name: 'Yamato Cannon', cost: { energy: 150 } },
 28 |         ];
 29 | 
 30 |         this.baseY = this.hoverHeight;
 31 | 
 32 |         try {
 33 |             const asset = assetManager.get('battlecruiser');
 34 |             this.mesh = this.createMeshFromGLB(asset);
 35 |         } catch (error) {
 36 |             console.warn("Could not load battlecruiser model, using procedural fallback.", error);
 37 |             this.mesh = this.createProceduralMesh();
 38 |         }
 39 | 
 40 |         this.mesh.position.copy(position);
 41 |         this.mesh.position.y = this.baseY;
 42 | 
 43 |         this.selected = false;
 44 |         this.path = [];
 45 |         this.currentWaypointIndex = 0;
 46 |         this.speed = 5.0; // Slow
 47 | 
 48 |         this.driveTime = 0;
 49 |         this.driveFrequency = 5;
 50 |         this.driveAmplitude = 0.3;
 51 | 
 52 |         const selectionGeometry = new THREE.RingGeometry(4.0, 4.2, 32);
 53 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 54 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 55 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 56 |         this.selectionIndicator.position.y = 0.01;
 57 |         this.selectionIndicator.visible = false;
 58 |         this.selectionIndicator.userData.owner = this;
 59 | 
 60 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 61 |     }
 62 | 
 63 |     createMeshFromGLB(asset) {
 64 |         const model = asset.scene.clone();
 65 | 
 66 |         const box = new THREE.Box3().setFromObject(model);
 67 |         const size = box.getSize(new THREE.Vector3());
 68 |         const desiredSize = 8.0;
 69 |         const maxDim = Math.max(size.x, size.y, size.z);
 70 | 
 71 |         if (maxDim > 0) {
 72 |             const scale = desiredSize / maxDim;
 73 |             model.scale.set(scale, scale, scale);
 74 |         }
 75 | 
 76 |         const wrapper = new THREE.Group();
 77 |         model.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
 78 |         wrapper.add(model);
 79 | 
 80 |         wrapper.traverse((child) => {
 81 |             if (child.isMesh) {
 82 |                 child.castShadow = true;
 83 |                 child.userData.owner = this;
 84 |             }
 85 |         });
 86 | 
 87 |         return wrapper;
 88 |     }
 89 | 
 90 |     createProceduralMesh() {
 91 |         const wrapper = new THREE.Group();
 92 |         const group = new THREE.Group();
 93 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x8a9aaa, metalness: 0.8, roughness: 0.4 });
 94 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
 95 | 
 96 |         const bodyGeo = new THREE.BoxGeometry(2.5, 2, 7);
 97 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
 98 |         group.add(body);
 99 | 
100 |         const hammerheadGeo = new THREE.BoxGeometry(5, 1.5, 2);
101 |         const hammerhead = new THREE.Mesh(hammerheadGeo, mainMaterial);
102 |         hammerhead.position.z = 4;
103 |         group.add(hammerhead);
104 | 
105 |         const bridgeGeo = new THREE.BoxGeometry(1.5, 1, 1.5);
106 |         const bridge = new THREE.Mesh(bridgeGeo, darkMaterial);
107 |         bridge.position.y = 1.2;
108 |         bridge.position.z = -1;
109 |         group.add(bridge);
110 | 
111 |         group.traverse((child) => {
112 |             if (child.isMesh) {
113 |                 child.userData.owner = this;
114 |                 child.castShadow = true;
115 |             }
116 |         });
117 | 
118 |         group.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
119 |         wrapper.add(group);
120 |         return wrapper;
121 |     }
122 | 
123 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
124 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
125 | 
126 |     setPath(path) {
127 |         if (path && path.length > 0) {
128 |             this.path = path;
129 |             this.currentWaypointIndex = 0;
130 |             this.state = 'moving';
131 |         } else {
132 |             this.path = [];
133 |             this.state = 'idle';
134 |         }
135 |     }
136 | 
137 |     executeCommand(commandName, gameState, statusCallback) {
138 |         if (commandName === 'yamato_cannon') {
139 |             if (!gameState.upgrades.yamatoGun) {
140 |                 statusCallback('Yamato Cannon not researched.');
141 |                 return;
142 |             }
143 |             if (this.energy < 150) {
144 |                 statusCallback('Not enough energy.');
145 |                 return;
146 |             }
147 |             this.energy -= 150;
148 |             const start = this.mesh.position.clone();
149 |             start.y += 2;
150 |             const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.mesh.quaternion).normalize();
151 |             const target = start.clone().add(forward.multiplyScalar(20));
152 |             createYamatoBlast(start, target);
153 |             statusCallback('Firing Yamato Cannon!');
154 |         }
155 |     }
156 | 
157 |     update(delta, pathfinder, gameState, buildings, scene) {
158 |         if (this.energy < this.maxEnergy) {
159 |             this.energy += 0.5625 * delta;
160 |         }
161 |         if (this.energy > this.maxEnergy) {
162 |             this.energy = this.maxEnergy;
163 |         }
164 | 
165 |         if (this.state === 'moving') {
166 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
167 |         } else {
168 |             this.driveTime += delta;
169 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
170 |         }
171 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
172 |     }
173 | 
174 |     updateMovement(delta, scene, onPathComplete) {
175 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
176 |             if (onPathComplete) onPathComplete();
177 |             return;
178 |         }
179 | 
180 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
181 |         targetPosition.y = this.hoverHeight;
182 | 
183 |         const distance = this.mesh.position.distanceTo(targetPosition);
184 | 
185 |         if (distance < 0.2) {
186 |             this.currentWaypointIndex++;
187 |         } else {
188 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
189 |             const moveDistance = this.speed * delta;
190 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
191 |             if (moveVector.length() > distance) moveVector.setLength(distance);
192 | 
193 |             this.mesh.position.add(moveVector);
194 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
195 |             this.mesh.lookAt(lookAtTarget);
196 |         }
197 | 
198 |         if (this.currentWaypointIndex >= this.path.length) {
199 |             this.path = [];
200 |             this.state = 'idle';
201 |             if (onPathComplete) onPathComplete();
202 |         }
203 |     }
204 | }


--------------------------------------------------------------------------------
/src/units/dropship.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { getTerrainHeight } from '../utils/terrain.js';
  4 | import { Infantry } from './infantry.js';
  5 | 
  6 | export class Dropship {
  7 |     constructor(position) {
  8 |         this.name = 'Dropship';
  9 |         this.portraitUrl = 'assets/images/dropship_portrait.png';
 10 |         this.maxHealth = 200;
 11 |         this.currentHealth = 200;
 12 |         this.isFlying = true;
 13 |         this.hoverHeight = 8;
 14 |         this.armor = 1;
 15 | 
 16 |         this.isGarrisoned = false; // Cannot be garrisoned itself
 17 |         this.state = 'idle'; // idle, moving
 18 | 
 19 |         // Garrison properties
 20 |         this.garrisonedUnits = [];
 21 |         this.capacity = 8;
 22 | 
 23 |         this.commands = [
 24 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 25 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 26 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 27 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 28 |             null,
 29 |             null,
 30 |             null,
 31 |             null,
 32 |             { 
 33 |                 command: 'unload_all', 
 34 |                 hotkey: 'U', 
 35 |                 icon: 'assets/images/unload_all_icon.png', 
 36 |                 name: 'Unload All'
 37 |             },
 38 |         ];
 39 | 
 40 |         this.baseY = this.hoverHeight;
 41 |         
 42 |         try {
 43 |             const asset = assetManager.get('dropship');
 44 |             this.mesh = this.createMeshFromGLB(asset);
 45 |         } catch (error) {
 46 |             console.warn("Could not load dropship model, using procedural fallback.", error);
 47 |             this.mesh = this.createProceduralMesh();
 48 |         }
 49 | 
 50 |         this.mesh.position.copy(position);
 51 |         this.mesh.position.y = this.baseY;
 52 | 
 53 |         this.selected = false;
 54 |         this.path = [];
 55 |         this.currentWaypointIndex = 0;
 56 |         this.speed = 7.5; // Fast, but slower than a wraith
 57 | 
 58 |         // For hover animation
 59 |         this.driveTime = 0;
 60 |         this.driveFrequency = 8;
 61 |         this.driveAmplitude = 0.3;
 62 | 
 63 |         const selectionGeometry = new THREE.RingGeometry(2.2, 2.4, 32);
 64 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 65 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 66 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 67 |         this.selectionIndicator.position.y = 0.01;
 68 |         this.selectionIndicator.visible = false;
 69 |         this.selectionIndicator.userData.owner = this;
 70 | 
 71 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 72 |     }
 73 |     
 74 |     createMeshFromGLB(asset) {
 75 |         const model = asset.scene.clone();
 76 | 
 77 |         const box = new THREE.Box3().setFromObject(model);
 78 |         const size = box.getSize(new THREE.Vector3());
 79 |         const desiredSize = 4.0; 
 80 |         const maxDim = Math.max(size.x, size.y, size.z);
 81 |         
 82 |         if (maxDim > 0) {
 83 |             const scale = desiredSize / maxDim;
 84 |             model.scale.set(scale, scale, scale);
 85 |         }
 86 | 
 87 |         const wrapper = new THREE.Group();
 88 |         model.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
 89 |         wrapper.add(model);
 90 | 
 91 |         wrapper.traverse((child) => {
 92 |             if (child.isMesh) {
 93 |                 child.castShadow = true;
 94 |                 child.userData.owner = this;
 95 |             }
 96 |         });
 97 |         
 98 |         return wrapper;
 99 |     }
100 | 
101 |     createProceduralMesh() {
102 |         const wrapper = new THREE.Group();
103 |         const group = new THREE.Group();
104 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8aaa, metalness: 0.8, roughness: 0.4 });
105 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
106 |         
107 |         // Main body
108 |         const bodyGeo = new THREE.BoxGeometry(2, 1, 4);
109 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
110 |         group.add(body);
111 |         
112 |         // Cockpit
113 |         const cockpitGeo = new THREE.BoxGeometry(1.5, 0.8, 1);
114 |         const cockpit = new THREE.Mesh(cockpitGeo, mainMaterial);
115 |         cockpit.position.z = 2;
116 |         group.add(cockpit);
117 | 
118 |         // Wings
119 |         const wingGeo = new THREE.BoxGeometry(5, 0.2, 1.5);
120 |         const wings = new THREE.Mesh(wingGeo, mainMaterial);
121 |         wings.position.y = 0.4;
122 |         group.add(wings);
123 | 
124 |         // Engines
125 |         const engineGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
126 |         const leftEngine = new THREE.Mesh(engineGeo, darkMaterial);
127 |         leftEngine.rotation.x = Math.PI / 2;
128 |         leftEngine.position.set(-2, 0.4, -0.5);
129 |         group.add(leftEngine);
130 |         const rightEngine = leftEngine.clone();
131 |         rightEngine.position.x = 2;
132 |         group.add(rightEngine);
133 | 
134 |         group.traverse((child) => {
135 |             if (child.isMesh) {
136 |                 child.userData.owner = this;
137 |                 child.castShadow = true;
138 |             }
139 |         });
140 | 
141 |         group.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
142 |         wrapper.add(group);
143 |         return wrapper;
144 |     }
145 | 
146 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
147 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
148 | 
149 |     setPath(path) {
150 |         if (path && path.length > 0) {
151 |             this.path = path;
152 |             this.currentWaypointIndex = 0;
153 |             this.state = 'moving';
154 |         } else {
155 |             this.path = [];
156 |             this.state = 'idle';
157 |         }
158 |     }
159 |     
160 |     executeCommand(commandName, gameState, statusCallback) {
161 |         if (commandName === 'unload_all') {
162 |             if (this.garrisonedUnits.length > 0) {
163 |                 this.unloadAll(gameState.scene);
164 |                 statusCallback("Units unloaded.");
165 |             } else {
166 |                 statusCallback("Dropship is empty.");
167 |             }
168 |         }
169 |     }
170 | 
171 |     update(delta, pathfinder, gameState, buildings, scene) {
172 |         if (this.state === 'moving') {
173 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
174 |         } else {
175 |              // Bobbing animation
176 |             this.driveTime += delta;
177 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
178 |         }
179 | 
180 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
181 |     }
182 | 
183 |     updateMovement(delta, scene, onPathComplete) {
184 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
185 |             if (onPathComplete) onPathComplete();
186 |             return;
187 |         }
188 | 
189 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
190 |         targetPosition.y = this.hoverHeight;
191 | 
192 |         const distance = this.mesh.position.distanceTo(targetPosition);
193 | 
194 |         if (distance < 0.2) {
195 |             this.currentWaypointIndex++;
196 |         } else {
197 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
198 |             const moveDistance = this.speed * delta;
199 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
200 | 
201 |             if (moveVector.length() > distance) {
202 |                 moveVector.setLength(distance);
203 |             }
204 | 
205 |             this.mesh.position.add(moveVector);
206 | 
207 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
208 |             this.mesh.lookAt(lookAtTarget);
209 |         }
210 |         
211 |         if (this.currentWaypointIndex >= this.path.length) {
212 |             this.path = [];
213 |             this.state = 'idle';
214 |             if (onPathComplete) onPathComplete();
215 |         }
216 |     }
217 | 
218 |     // Garrisoning Logic
219 |     addUnit(unit) {
220 |         if (this.garrisonedUnits.length >= this.capacity) {
221 |             return false;
222 |         }
223 |         // Only infantry can be transported
224 |         if (unit.isFlying === undefined || unit.isFlying === false) {
225 |             this.garrisonedUnits.push(unit);
226 |             unit.isGarrisoned = true;
227 |             unit.mesh.visible = false;
228 |             unit.deselect();
229 |             return true;
230 |         }
231 |         return false;
232 |     }
233 | 
234 |     getSpawnPoints(scene) {
235 |         const points = [];
236 |         const radius = 3.5;
237 |         const count = this.garrisonedUnits.length > 0 ? this.garrisonedUnits.length : 1;
238 |         for (let i = 0; i < this.garrisonedUnits.length; i++) {
239 |             const angle = (i / count) * Math.PI * 2;
240 |             const spawnPos = this.mesh.position.clone().add(new THREE.Vector3(radius * Math.cos(angle), 0, radius * Math.sin(angle)));
241 |             spawnPos.y = getTerrainHeight(scene, spawnPos.x, spawnPos.z);
242 |             points.push(spawnPos);
243 |         }
244 |         return points;
245 |     }
246 | 
247 |     unloadAll(scene) {
248 |         const spawnPoints = this.getSpawnPoints(scene);
249 |         if (spawnPoints.length === 0) return;
250 | 
251 |         this.garrisonedUnits.forEach((unit, i) => {
252 |             const spawnPoint = spawnPoints[i % spawnPoints.length];
253 |             unit.mesh.position.copy(spawnPoint);
254 |             unit.isGarrisoned = false;
255 |             unit.mesh.visible = true;
256 |             unit.path = [];
257 |             unit.state = 'idle';
258 |         });
259 | 
260 |         this.garrisonedUnits = [];
261 |     }
262 | }


--------------------------------------------------------------------------------
/src/units/firebat.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { getTerrainHeight } from '../utils/terrain.js';
 3 | import { Infantry } from './infantry.js';
 4 | 
 5 | export class Firebat extends Infantry {
 6 |     constructor(position) {
 7 |         super(position);
 8 | 
 9 |         this.name = 'Firebat';
10 |         this.portraitUrl = 'assets/images/firebat_portrait.png';
11 |         this.maxHealth = 50; // Firebats have more health than marines
12 |         this.currentHealth = 50;
13 |         
14 |         this.commands = [
15 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
16 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
17 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
18 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
19 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
20 |         ];
21 | 
22 |         this.mesh = this.createMesh();
23 |         this.setup(position);
24 |     }
25 | 
26 |     createMesh() {
27 |         const group = new THREE.Group();
28 | 
29 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xaa6a6a, metalness: 0.6, roughness: 0.5 }); // More reddish armor
30 |         const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7, roughness: 0.4 });
31 |         const visorMaterial = new THREE.MeshStandardMaterial({ color: 0xff8c00, metalness: 0.9, roughness: 0.2, emissive: 0xff8c00, emissiveIntensity: 0.6 }); // Orange visor
32 | 
33 |         // Torso
34 |         const torsoGeometry = new THREE.CylinderGeometry(0.45, 0.35, 0.9, 8); // Bulkier
35 |         const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
36 |         torso.position.y = 0.45;
37 |         torso.castShadow = true;
38 |         group.add(torso);
39 | 
40 |         // Backpack (fuel tanks)
41 |         const backpackGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8);
42 |         const leftTank = new THREE.Mesh(backpackGeo, armorMaterial);
43 |         leftTank.position.set(-0.2, 0.6, -0.3);
44 |         leftTank.castShadow = true;
45 |         group.add(leftTank);
46 |         const rightTank = leftTank.clone();
47 |         rightTank.position.x = 0.2;
48 |         group.add(rightTank);
49 | 
50 |         // Head
51 |         const headGeometry = new THREE.IcosahedronGeometry(0.25, 1);
52 |         const head = new THREE.Mesh(headGeometry, armorMaterial);
53 |         head.position.y = 1.05;
54 |         head.castShadow = true;
55 |         group.add(head);
56 |         
57 |         // Visor
58 |         const visorGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.05);
59 |         const visor = new THREE.Mesh(visorGeometry, visorMaterial);
60 |         visor.position.set(0, 1.05, 0.22);
61 |         group.add(visor);
62 | 
63 |         // Shoulder pads
64 |         const shoulderGeo = new THREE.SphereGeometry(0.3, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2); // Bigger
65 |         const leftShoulder = new THREE.Mesh(shoulderGeo, armorMaterial);
66 |         leftShoulder.position.set(0.5, 0.8, 0);
67 |         leftShoulder.rotation.z = Math.PI / 8;
68 |         leftShoulder.castShadow = true;
69 |         group.add(leftShoulder);
70 | 
71 |         const rightShoulder = leftShoulder.clone();
72 |         rightShoulder.position.x = -0.5;
73 |         rightShoulder.rotation.z = -Math.PI / 8;
74 |         group.add(rightShoulder);
75 | 
76 |         // Flamethrowers (on wrists)
77 |         const flamethrowerGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
78 |         const leftFlamer = new THREE.Mesh(flamethrowerGeo, gunMaterial);
79 |         leftFlamer.rotation.x = Math.PI / 2;
80 |         leftFlamer.position.set(0.5, 0.3, 0.3);
81 |         group.add(leftFlamer);
82 |         
83 |         const rightFlamer = leftFlamer.clone();
84 |         rightFlamer.position.x = -0.5;
85 |         group.add(rightFlamer);
86 | 
87 |         group.traverse((child) => {
88 |             if (child instanceof THREE.Mesh) {
89 |                 child.userData.owner = this;
90 |             }
91 |         });
92 | 
93 |         group.scale.set(0.7, 0.7, 0.7);
94 | 
95 |         return group;
96 |     }
97 | }


--------------------------------------------------------------------------------
/src/units/ghost.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from './infantry.js';
  3 | 
  4 | export class Ghost extends Infantry {
  5 |     constructor(position) {
  6 |         super(position);
  7 | 
  8 |         this.name = 'Ghost';
  9 |         this.portraitUrl = 'assets/images/ghost_portrait.png';
 10 |         this.maxHealth = 45;
 11 |         this.currentHealth = 45;
 12 |         this.speed = 3.5; // Slightly slower than a marine
 13 | 
 14 |         this.energy = 50;
 15 |         this.maxEnergy = 200;
 16 | 
 17 |         this.isCloaked = false;
 18 |         this._buildings = null;
 19 | 
 20 |         this.commands = [
 21 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 22 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 23 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 24 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 25 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 26 |             null,
 27 |             null,
 28 |             { command: 'cloak', hotkey: 'C', icon: 'assets/images/cloak_icon.png', name: 'Cloak' },
 29 |             { command: 'lockdown', hotkey: 'L', icon: 'assets/images/lockdown_icon.png', name: 'Lockdown' },
 30 |             { command: 'nuke_strike', hotkey: 'N', icon: 'assets/images/nuke_strike_icon.png', name: 'Nuke Strike' },
 31 |         ];
 32 |         
 33 |         this.mesh = this.createMesh();
 34 |         this.setup(position);
 35 |     }
 36 | 
 37 |     createMesh() {
 38 |         const group = new THREE.Group();
 39 | 
 40 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.6, roughness: 0.5 });
 41 |         const suitMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
 42 |         const visorMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.9, roughness: 0.2, emissive: 0xff0000, emissiveIntensity: 0.6 });
 43 | 
 44 |         // Torso (slender)
 45 |         const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.20, 0.9, 8);
 46 |         const torso = new THREE.Mesh(torsoGeometry, suitMaterial);
 47 |         torso.position.y = 0.45;
 48 |         torso.castShadow = true;
 49 |         group.add(torso);
 50 | 
 51 |         // Head
 52 |         const headGeometry = new THREE.IcosahedronGeometry(0.25, 1);
 53 |         const head = new THREE.Mesh(headGeometry, armorMaterial);
 54 |         head.position.y = 1.05;
 55 |         head.castShadow = true;
 56 |         group.add(head);
 57 |         
 58 |         // Visor
 59 |         const visorGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.05);
 60 |         const visor = new THREE.Mesh(visorGeometry, visorMaterial);
 61 |         visor.position.set(0, 1.05, 0.22);
 62 |         group.add(visor);
 63 | 
 64 |         // Shoulder pads (small)
 65 |         const shoulderGeo = new THREE.SphereGeometry(0.18, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
 66 |         const leftShoulder = new THREE.Mesh(shoulderGeo, armorMaterial);
 67 |         leftShoulder.position.set(0.3, 0.8, 0);
 68 |         leftShoulder.rotation.z = Math.PI / 8;
 69 |         leftShoulder.castShadow = true;
 70 |         group.add(leftShoulder);
 71 | 
 72 |         const rightShoulder = leftShoulder.clone();
 73 |         rightShoulder.position.x = -0.3;
 74 |         rightShoulder.rotation.z = -Math.PI / 8;
 75 |         group.add(rightShoulder);
 76 | 
 77 |         // Sniper Rifle (C-10 Canister Rifle)
 78 |         const gunGroup = new THREE.Group();
 79 |         const gunBodyGeo = new THREE.BoxGeometry(0.1, 0.15, 1.2);
 80 |         const gunBody = new THREE.Mesh(gunBodyGeo, suitMaterial);
 81 |         gunGroup.add(gunBody);
 82 | 
 83 |         const gunBarrelGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.5, 8);
 84 |         const gunBarrel = new THREE.Mesh(gunBarrelGeo, suitMaterial);
 85 |         gunBarrel.rotation.x = Math.PI / 2;
 86 |         gunBarrel.position.z = 0.75;
 87 |         gunGroup.add(gunBarrel);
 88 |         
 89 |         const scopeGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
 90 |         const scope = new THREE.Mesh(scopeGeo, suitMaterial);
 91 |         scope.rotation.x = Math.PI / 2;
 92 |         scope.position.set(0, 0.15, -0.2);
 93 |         gunGroup.add(scope);
 94 | 
 95 |         gunBody.castShadow = true;
 96 |         gunBarrel.castShadow = true;
 97 |         gunGroup.position.set(0.45, 0.5, 0.4);
 98 |         group.add(gunGroup);
 99 | 
100 |         group.traverse((child) => {
101 |             if (child instanceof THREE.Mesh) {
102 |                 child.userData.owner = this;
103 |             }
104 |         });
105 | 
106 |         group.scale.set(0.7, 0.7, 0.7);
107 | 
108 |         return group;
109 |     }
110 | 
111 |     executeCommand(commandName, gameState, statusCallback) {
112 |         switch (commandName) {
113 |             case 'cloak':
114 |                 if (!this.isCloaked) {
115 |                     if (this.energy < 25) {
116 |                         statusCallback('Not enough energy.');
117 |                         return;
118 |                     }
119 |                     this.energy -= 25;
120 |                     this.isCloaked = true;
121 |                     this.mesh.traverse(child => {
122 |                         if (child.material) {
123 |                             child.material.transparent = true;
124 |                             child.material.opacity = 0.35;
125 |                         }
126 |                     });
127 |                     statusCallback('Cloak engaged.');
128 |                 } else {
129 |                     this.isCloaked = false;
130 |                     this.mesh.traverse(child => {
131 |                         if (child.material) {
132 |                             child.material.opacity = 1;
133 |                             child.material.transparent = false;
134 |                         }
135 |                     });
136 |                     statusCallback('Cloak disengaged.');
137 |                 }
138 |                 break;
139 |             case 'lockdown':
140 |                 if (this.energy < 100) {
141 |                     statusCallback('Not enough energy.');
142 |                     return;
143 |                 }
144 |                 this.energy -= 100;
145 |                 statusCallback('Lockdown fired (no effect in demo).');
146 |                 break;
147 |             case 'nuke_strike':
148 |                 if (!this._buildings) {
149 |                     statusCallback('No Nuclear Silo available.');
150 |                     return;
151 |                 }
152 |                 const silo = this._buildings.find(b => b.name === 'Nuclear Silo');
153 |                 if (!silo) {
154 |                     statusCallback('No Nuclear Silo available.');
155 |                     return;
156 |                 }
157 |                 if (!silo.hasNuke) {
158 |                     statusCallback('Nuclear missile not ready.');
159 |                     return;
160 |                 }
161 |                 if (this.energy < 50) {
162 |                     statusCallback('Not enough energy.');
163 |                     return;
164 |                 }
165 |                 this.energy -= 50;
166 |                 silo.hasNuke = false;
167 |                 statusCallback('Nuclear launch initiated!');
168 |                 break;
169 |         }
170 |     }
171 | 
172 |     update(delta, pathfinder, gameState, buildings, scene) {
173 |         this._buildings = buildings;
174 | 
175 |         if (this.isCloaked) {
176 |             this.energy -= delta;
177 |             if (this.energy <= 0) {
178 |                 this.energy = 0;
179 |                 this.isCloaked = false;
180 |                 this.mesh.traverse(child => {
181 |                     if (child.material) {
182 |                         child.material.opacity = 1;
183 |                         child.material.transparent = false;
184 |                     }
185 |                 });
186 |             }
187 |         } else if (this.energy < this.maxEnergy) {
188 |             this.energy += 0.5625 * delta;
189 |             if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
190 |         }
191 | 
192 |         super.update(delta, pathfinder, gameState, buildings, scene);
193 |     }
194 | }


--------------------------------------------------------------------------------
/src/units/goliath.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { getTerrainHeight } from '../utils/terrain.js';
  4 | 
  5 | export class Goliath {
  6 |     constructor(position) {
  7 |         this.name = 'Goliath';
  8 |         this.portraitUrl = 'assets/images/goliath_portrait.png';
  9 |         this.maxHealth = 125;
 10 |         this.currentHealth = 125;
 11 |         
 12 |         this.isGarrisoned = false;
 13 |         this.isStuckOnDepot = false;
 14 |         this.stuckOnDepotInstance = null;
 15 |         this.state = 'idle'; // idle, moving, attacking
 16 | 
 17 |         this.commands = [
 18 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 19 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 20 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 21 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 22 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 23 |         ];
 24 | 
 25 |         this.baseY = position.y;
 26 |         
 27 |         try {
 28 |             const asset = assetManager.get('goliath');
 29 |             this.mesh = this.createMeshFromGLB(asset);
 30 |         } catch (error) {
 31 |             this.mesh = this.createProceduralMesh();
 32 |         }
 33 | 
 34 |         this.mesh.position.copy(position);
 35 | 
 36 |         this.selected = false;
 37 |         this.path = [];
 38 |         this.currentWaypointIndex = 0;
 39 |         this.speed = 3.8; // Medium speed
 40 | 
 41 |         // For walk animation
 42 |         this.walkTime = 0;
 43 |         this.walkFrequency = 12;
 44 |         this.walkAmplitude = 0.1;
 45 | 
 46 |         const selectionGeometry = new THREE.RingGeometry(1.2, 1.4, 32);
 47 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 48 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 49 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 50 |         this.selectionIndicator.position.y = 0.01;
 51 |         this.selectionIndicator.visible = false;
 52 |         this.mesh.add(this.selectionIndicator);
 53 | 
 54 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 55 |     }
 56 |     
 57 |     createMeshFromGLB(asset) {
 58 |         const model = asset.scene.clone();
 59 | 
 60 |         const box = new THREE.Box3().setFromObject(model);
 61 |         const size = box.getSize(new THREE.Vector3());
 62 |         const desiredSize = 2.5; // Goliaths are tall
 63 |         const maxDim = Math.max(size.x, size.y, size.z);
 64 |         
 65 |         if (maxDim > 0) {
 66 |             const scale = desiredSize / maxDim;
 67 |             model.scale.set(scale, scale, scale);
 68 |         }
 69 | 
 70 |         const scaledBox = new THREE.Box3().setFromObject(model);
 71 |         model.position.y = -scaledBox.min.y;
 72 | 
 73 |         model.traverse((child) => {
 74 |             if (child.isMesh) {
 75 |                 child.castShadow = true;
 76 |                 child.userData.owner = this;
 77 |             }
 78 |         });
 79 |         
 80 |         return model;
 81 |     }
 82 |     
 83 |     createProceduralMesh() {
 84 |         const group = new THREE.Group();
 85 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8aaa, metalness: 0.8, roughness: 0.4 });
 86 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
 87 | 
 88 |         // Cockpit / Torso
 89 |         const torsoGeo = new THREE.BoxGeometry(1.2, 1.2, 1);
 90 |         const torso = new THREE.Mesh(torsoGeo, mainMaterial);
 91 |         torso.position.y = 1.6;
 92 |         group.add(torso);
 93 | 
 94 |         // Legs
 95 |         const legGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
 96 |         const leftLeg = new THREE.Mesh(legGeo, darkMaterial);
 97 |         leftLeg.position.set(-0.4, 1.0, 0);
 98 |         group.add(leftLeg);
 99 |         const rightLeg = leftLeg.clone();
100 |         rightLeg.position.x = 0.4;
101 |         group.add(rightLeg);
102 |         
103 |         const footGeo = new THREE.BoxGeometry(0.6, 0.2, 0.8);
104 |         const leftFoot = new THREE.Mesh(footGeo, darkMaterial);
105 |         leftFoot.position.set(-0.4, 0.1, 0.2);
106 |         group.add(leftFoot);
107 |         const rightFoot = leftFoot.clone();
108 |         rightFoot.position.x = 0.4;
109 |         group.add(rightFoot);
110 | 
111 |         // Arms (autocannons)
112 |         const armGeo = new THREE.BoxGeometry(0.3, 0.3, 1.5);
113 |         const leftArm = new THREE.Mesh(armGeo, darkMaterial);
114 |         leftArm.position.set(-0.8, 1.6, 0.5);
115 |         group.add(leftArm);
116 |         const rightArm = leftArm.clone();
117 |         rightArm.position.x = 0.8;
118 |         group.add(rightArm);
119 |         
120 |         // Missile pods
121 |         const podGeo = new THREE.BoxGeometry(0.8, 0.4, 0.4);
122 |         const missilePod = new THREE.Mesh(podGeo, mainMaterial);
123 |         missilePod.position.set(0, 2.4, 0);
124 |         group.add(missilePod);
125 | 
126 |         group.traverse((child) => {
127 |             if (child.isMesh) {
128 |                 child.castShadow = true;
129 |                 child.userData.owner = this;
130 |             }
131 |         });
132 | 
133 |         group.scale.set(0.9, 0.9, 0.9);
134 | 
135 |         return group;
136 |     }
137 | 
138 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
139 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
140 | 
141 |     setPath(path) {
142 |         if (this.isStuckOnDepot) return;
143 |         if (path && path.length > 0) {
144 |             this.path = path;
145 |             this.currentWaypointIndex = 0;
146 |             this.state = 'moving';
147 |         } else {
148 |             this.path = [];
149 |             this.state = 'idle';
150 |         }
151 |     }
152 |     
153 |     executeCommand(commandName, gameState, statusCallback) {
154 |         // No special commands for Goliath yet.
155 |     }
156 | 
157 |     update(delta, pathfinder, gameState, buildings, scene) {
158 |         if (this.isStuckOnDepot || this.isGarrisoned) return;
159 | 
160 |         if (this.state === 'moving') {
161 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
162 |         } else {
163 |             // Stop bobbing animation if idle
164 |             if (this.walkTime !== 0) {
165 |                  this.mesh.position.y = this.baseY;
166 |                  this.walkTime = 0;
167 |             }
168 |         }
169 |     }
170 | 
171 |     updateMovement(delta, scene, onPathComplete) {
172 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
173 |             if (onPathComplete) onPathComplete();
174 |             return;
175 |         }
176 | 
177 |         const targetPosition = this.path[this.currentWaypointIndex];
178 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
179 |         targetPosition.y = targetY;
180 |         this.baseY = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z);
181 | 
182 |         const currentPos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
183 |         const targetPos2D = new THREE.Vector2(targetPosition.x, targetPosition.z);
184 |         const distance = currentPos2D.distanceTo(targetPos2D);
185 | 
186 |         if (distance < 0.1) {
187 |             this.currentWaypointIndex++;
188 |         } else {
189 |             const direction = targetPosition.clone().sub(this.mesh.position);
190 |             direction.y = 0;
191 |             direction.normalize();
192 | 
193 |             const moveDistance = this.speed * delta;
194 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
195 | 
196 |             if (moveVector.length() > distance) {
197 |                 moveVector.setLength(distance);
198 |             }
199 | 
200 |             this.mesh.position.add(moveVector);
201 | 
202 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
203 |             this.mesh.lookAt(lookAtTarget);
204 | 
205 |             // Walking animation
206 |             this.walkTime += delta;
207 |             this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.walkTime * this.walkFrequency) * this.walkAmplitude);
208 |         }
209 |         
210 |         if (this.currentWaypointIndex >= this.path.length) {
211 |             this.path = [];
212 |             this.mesh.position.y = this.baseY;
213 |             this.walkTime = 0;
214 |             if (onPathComplete) onPathComplete();
215 |         }
216 |     }
217 | }


--------------------------------------------------------------------------------
/src/units/infantry.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { getTerrainHeight } from '../utils/terrain.js';
  3 | 
  4 | export class Infantry {
  5 |     constructor(position) {
  6 |         // Common properties for all infantry units
  7 |         this.isGarrisoned = false;
  8 |         this.garrisonTarget = null;
  9 |         this.isStuckOnDepot = false;
 10 |         this.stuckOnDepotInstance = null;
 11 |         this.state = 'idle'; // idle, moving, movingToGarrison, attack
 12 | 
 13 |         this.baseY = position.y;
 14 | 
 15 |         this.selected = false;
 16 |         this.path = [];
 17 |         this.currentWaypointIndex = 0;
 18 |         /** @tweakable Default movement speed for infantry units. */
 19 |         this.speed = 4; // Default speed, can be overridden by subclass
 20 | 
 21 |         // For walk animation
 22 |         this.walkTime = 0;
 23 |         /** @tweakable The frequency of the bobbing motion in the infantry walk animation. Higher is faster. */
 24 |         this.walkFrequency = 15;
 25 |         /** @tweakable The amplitude of the bobbing motion in the infantry walk animation. Higher is more pronounced. */
 26 |         this.walkAmplitude = 0.08;
 27 | 
 28 |         // Subclass should define: name, portraitUrl, maxHealth, currentHealth, commands, mesh
 29 |     }
 30 | 
 31 |     // Called by subclass after mesh is created
 32 |     setup(position) {
 33 |         this.mesh.position.copy(position);
 34 | 
 35 |         // The selection circle on the ground
 36 |         const selectionGeometry = new THREE.RingGeometry(0.7, 0.8, 32);
 37 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 38 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 39 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 40 |         this.selectionIndicator.position.y = 0.01;
 41 |         this.selectionIndicator.visible = false;
 42 |         this.mesh.add(this.selectionIndicator);
 43 | 
 44 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 45 |     }
 46 |     
 47 |     // createMesh() must be implemented by subclass
 48 | 
 49 |     select() {
 50 |         this.selected = true;
 51 |         this.selectionIndicator.visible = true;
 52 |     }
 53 | 
 54 |     deselect() {
 55 |         this.selected = false;
 56 |         this.selectionIndicator.visible = false;
 57 |     }
 58 | 
 59 |     garrison(bunker) {
 60 |         if (this.isGarrisoned) return;
 61 |         this.state = 'movingToGarrison';
 62 |         this.garrisonTarget = bunker;
 63 |     }
 64 | 
 65 |     setPath(path) {
 66 |         if (this.isStuckOnDepot) return;
 67 |         if (path && path.length > 0) {
 68 |             this.path = path;
 69 |             this.currentWaypointIndex = 0;
 70 |         } else {
 71 |             this.path = [];
 72 |         }
 73 |     }
 74 | 
 75 |     moveTo(position) {
 76 |         this.targetPosition = new THREE.Vector3(position.x, this.baseY, position.z);
 77 |     }
 78 | 
 79 |     update(delta, pathfinder, gameState, buildings, scene) {
 80 |         if (this.isStuckOnDepot) {
 81 |             this.state = 'idle';
 82 |             this.path = [];
 83 |             return;
 84 |         }
 85 | 
 86 |         if (this.isGarrisoned) {
 87 |             return; // Don't update if inside a bunker
 88 |         }
 89 | 
 90 |         switch (this.state) {
 91 |             case 'idle':
 92 |                 // Stop bobbing animation if it exists
 93 |                 if (this.walkTime !== 0) {
 94 |                      this.mesh.position.y = this.baseY;
 95 |                      this.walkTime = 0;
 96 |                 }
 97 |                 break;
 98 |             case 'moving':
 99 |                 this.updateMovement(delta, scene, () => { this.state = 'idle'; });
100 |                 break;
101 |             case 'movingToGarrison':
102 |                 if (!this.garrisonTarget) {
103 |                     this.state = 'idle';
104 |                     return;
105 |                 }
106 |                 this.updateMovement(delta, scene, () => {
107 |                     this.garrisonTarget.addUnit(this);
108 |                     this.garrisonTarget = null;
109 |                     this.state = 'idle';
110 |                 });
111 |                 break;
112 |         }
113 |     }
114 | 
115 |     updateMovement(delta, scene, onPathComplete) {
116 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
117 |             if (onPathComplete) onPathComplete();
118 |             return;
119 |         }
120 | 
121 |         const targetPosition = this.path[this.currentWaypointIndex];
122 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
123 |         targetPosition.y = targetY;
124 |         this.baseY = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z);
125 | 
126 |         const currentPos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
127 |         const targetPos2D = new THREE.Vector2(targetPosition.x, targetPosition.z);
128 |         const distance = currentPos2D.distanceTo(targetPos2D);
129 | 
130 |         if (distance < 0.1) {
131 |             this.currentWaypointIndex++;
132 |         } else {
133 |             const direction = targetPosition.clone().sub(this.mesh.position);
134 |             direction.y = 0;
135 |             direction.normalize();
136 | 
137 |             const moveDistance = this.speed * delta;
138 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
139 | 
140 |             if (moveVector.length() > distance) {
141 |                 moveVector.setLength(distance);
142 |             }
143 | 
144 |             this.mesh.position.add(moveVector);
145 | 
146 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
147 |             this.mesh.lookAt(lookAtTarget);
148 | 
149 |             this.walkTime += delta;
150 |             this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.walkTime * this.walkFrequency) * this.walkAmplitude);
151 |         }
152 |         
153 |         if (this.currentWaypointIndex >= this.path.length) {
154 |             this.path = [];
155 |             this.mesh.position.y = this.baseY;
156 |             this.walkTime = 0;
157 |             if (onPathComplete) onPathComplete();
158 |         }
159 |     }
160 | }


--------------------------------------------------------------------------------
/src/units/medic.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { Infantry } from './infantry.js';
  3 | 
  4 | export class Medic extends Infantry {
  5 |     constructor(position) {
  6 |         super(position);
  7 | 
  8 |         this.name = 'Medic';
  9 |         this.portraitUrl = 'assets/images/medic_portrait.png';
 10 |         this.maxHealth = 60;
 11 |         this.currentHealth = 60;
 12 | 
 13 |         this.energy = 50;
 14 |         this.maxEnergy = 200;
 15 |         this.healRange = 1.5;
 16 |         this.healTarget = null;
 17 |         this.state = 'idle'; // idle, moving, movingToHeal, healing
 18 |         this.healCooldown = 0;
 19 | 
 20 |         this.commands = [
 21 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 22 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 23 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 24 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 25 |             { command: 'heal', hotkey: 'E', icon: 'assets/images/heal_icon.png', name: 'Heal', cost: { energy: 1 } },
 26 |         ];
 27 | 
 28 |         this.mesh = this.createMesh();
 29 |         this.setup(position);
 30 |     }
 31 | 
 32 |     createMesh() {
 33 |         const group = new THREE.Group();
 34 | 
 35 |         // White armor, red accents
 36 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.5 });
 37 |         const accentMaterial = new THREE.MeshStandardMaterial({ color: 0xbb2222, metalness: 0.5, roughness: 0.6 });
 38 |         const visorMaterial = new THREE.MeshStandardMaterial({ color: 0x00d1ff, metalness: 0.9, roughness: 0.2, emissive: 0x00a1ff, emissiveIntensity: 0.6 });
 39 | 
 40 |         // Torso - slightly smaller than marine
 41 |         const torsoGeometry = new THREE.CylinderGeometry(0.30, 0.22, 0.7, 8);
 42 |         const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
 43 |         torso.position.y = 0.35;
 44 |         torso.castShadow = true;
 45 |         group.add(torso);
 46 | 
 47 |         // Backpack with red cross
 48 |         const backpackGeo = new THREE.BoxGeometry(0.4, 0.5, 0.25);
 49 |         const backpack = new THREE.Mesh(backpackGeo, armorMaterial);
 50 |         backpack.position.set(0, 0.5, -0.2);
 51 |         backpack.castShadow = true;
 52 |         group.add(backpack);
 53 | 
 54 |         const crossHGeo = new THREE.BoxGeometry(0.3, 0.1, 0.02);
 55 |         const crossVGeo = new THREE.BoxGeometry(0.1, 0.3, 0.02);
 56 |         const crossH = new THREE.Mesh(crossHGeo, accentMaterial);
 57 |         const crossV = new THREE.Mesh(crossVGeo, accentMaterial);
 58 |         crossH.position.z = 0.13;
 59 |         crossV.position.z = 0.13;
 60 |         backpack.add(crossH);
 61 |         backpack.add(crossV);
 62 | 
 63 |         // Head
 64 |         const headGeometry = new THREE.IcosahedronGeometry(0.22, 1);
 65 |         const head = new THREE.Mesh(headGeometry, armorMaterial);
 66 |         head.position.y = 0.9;
 67 |         head.castShadow = true;
 68 |         group.add(head);
 69 |         
 70 |         // Visor
 71 |         const visorGeometry = new THREE.BoxGeometry(0.28, 0.13, 0.05);
 72 |         const visor = new THREE.Mesh(visorGeometry, visorMaterial);
 73 |         visor.position.set(0, 0.9, 0.20);
 74 |         group.add(visor);
 75 | 
 76 |         // Shoulder pads
 77 |         const shoulderGeo = new THREE.SphereGeometry(0.20, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
 78 |         const leftShoulder = new THREE.Mesh(shoulderGeo, accentMaterial);
 79 |         leftShoulder.position.set(0.35, 0.65, 0);
 80 |         leftShoulder.rotation.z = Math.PI / 8;
 81 |         leftShoulder.castShadow = true;
 82 |         group.add(leftShoulder);
 83 | 
 84 |         const rightShoulder = leftShoulder.clone();
 85 |         rightShoulder.position.x = -0.35;
 86 |         rightShoulder.rotation.z = -Math.PI / 8;
 87 |         group.add(rightShoulder);
 88 | 
 89 |         // No gun for medic
 90 | 
 91 |         group.traverse((child) => {
 92 |             if (child instanceof THREE.Mesh) {
 93 |                 child.userData.owner = this;
 94 |             }
 95 |         });
 96 | 
 97 |         group.scale.set(0.7, 0.7, 0.7);
 98 | 
 99 |         return group;
100 |     }
101 | 
102 |     stopActions() {
103 |         if (this.state === 'movingToHeal' || this.state === 'healing') {
104 |             this.state = 'idle';
105 |             this.healTarget = null;
106 |         }
107 |     }
108 | 
109 |     heal(target, pathfinder, targetPosition = null) {
110 |         this.stopActions();
111 |         if (!target) return;
112 |         this.state = 'movingToHeal';
113 |         this.healTarget = target;
114 | 
115 |         let finalPos = targetPosition;
116 |         if (!finalPos && target.getCollider) {
117 |             const collider = target.getCollider();
118 |             const size = collider.getSize(new THREE.Vector3());
119 |             const pos = target.mesh.position;
120 |             const radius = Math.max(size.x, size.z) / 2 + 1.0;
121 |             finalPos = new THREE.Vector3(pos.x + radius, pos.y, pos.z);
122 |         }
123 |         if (!finalPos) finalPos = target.mesh.position.clone();
124 | 
125 |         if (pathfinder) {
126 |             const path = pathfinder.findPath(this.mesh.position, finalPos);
127 |             this.setPath(path);
128 |         }
129 |     }
130 | 
131 |     executeCommand(commandName, gameState, statusCallback) {
132 |         if (commandName === 'heal') {
133 |             const wounded = gameState.units
134 |                 .filter(u => u instanceof Infantry && u.currentHealth < u.maxHealth && u !== this);
135 |             if (wounded.length === 0) {
136 |                 statusCallback('No wounded units to heal.');
137 |                 return;
138 |             }
139 |             wounded.sort((a, b) => a.mesh.position.distanceToSquared(this.mesh.position) - b.mesh.position.distanceToSquared(this.mesh.position));
140 |             const target = wounded[0];
141 |             const pathfinder = window.pathfinder;
142 |             this.heal(target, pathfinder);
143 |             statusCallback(`Healing ${target.name}.`);
144 |         }
145 |     }
146 | 
147 |     update(delta, pathfinder, gameState, buildings, scene) {
148 |         if (this.energy < this.maxEnergy) {
149 |             this.energy += 0.5625 * delta;
150 |             if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
151 |         }
152 | 
153 |         if (this.state === 'movingToHeal') {
154 |             if (!this.healTarget || this.healTarget.currentHealth >= this.healTarget.maxHealth) {
155 |                 this.state = 'idle';
156 |                 this.healTarget = null;
157 |             } else {
158 |                 this.updateMovement(delta, scene, () => {
159 |                     this.state = 'healing';
160 |                     this.mesh.lookAt(this.healTarget.mesh.position);
161 |                 });
162 |                 return;
163 |             }
164 |         }
165 | 
166 |         if (this.state === 'healing') {
167 |             if (!this.healTarget || this.healTarget.currentHealth >= this.healTarget.maxHealth) {
168 |                 this.state = 'idle';
169 |                 this.healTarget = null;
170 |             } else if (this.energy <= 0) {
171 |                 this.state = 'idle';
172 |                 this.healTarget = null;
173 |             } else {
174 |                 const healAmount = 10 * delta;
175 |                 const energyCost = healAmount;
176 |                 const actualHeal = Math.min(healAmount, this.healTarget.maxHealth - this.healTarget.currentHealth);
177 |                 const actualCost = Math.min(this.energy, energyCost * (actualHeal / healAmount));
178 |                 this.healTarget.currentHealth += actualHeal;
179 |                 this.energy -= actualCost;
180 |                 if (this.healTarget.currentHealth >= this.healTarget.maxHealth) {
181 |                     this.healTarget.currentHealth = this.healTarget.maxHealth;
182 |                     this.state = 'idle';
183 |                     this.healTarget = null;
184 |                 }
185 |             }
186 |             return;
187 |         }
188 | 
189 |         super.update(delta, pathfinder, gameState, buildings, scene);
190 |     }
191 | }


--------------------------------------------------------------------------------
/src/units/science-vessel.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { createDefensiveMatrix, createEMPShockwave, createIrradiate } from '../game/effects.js';
  4 | 
  5 | /** @tweakable Hotkeys for Science Vessel abilities */
  6 | const scienceVesselHotkeys = {
  7 |     defensiveMatrix: 'F',
  8 |     empShockwave: 'E',
  9 |     irradiate: 'R',
 10 | };
 11 | 
 12 | export class ScienceVessel {
 13 |     constructor(position) {
 14 |         this.name = 'Science Vessel';
 15 |         this.portraitUrl = 'assets/images/science_vessel_portrait.png';
 16 |         this.maxHealth = 200;
 17 |         this.currentHealth = 200;
 18 |         this.armor = 1;
 19 |         this.isFlying = true;
 20 |         this.hoverHeight = 9;
 21 |         this.isDetector = true;
 22 | 
 23 |         this.energy = 50;
 24 |         this.maxEnergy = 200;
 25 | 
 26 |         this.isGarrisoned = false; // Cannot be garrisoned itself
 27 |         this.state = 'idle'; // idle, moving
 28 | 
 29 |         this.commands = [
 30 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 31 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 32 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 33 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 34 |             null,
 35 |             null,
 36 |             { command: 'defensive_matrix', hotkey: scienceVesselHotkeys.defensiveMatrix, icon: 'assets/images/defensive_matrix_icon.png', name: 'Defensive Matrix', cost: { energy: 100 } },
 37 |             { command: 'emp_shockwave', hotkey: scienceVesselHotkeys.empShockwave, icon: 'assets/images/emp_shockwave_icon.png', name: 'EMP Shockwave', cost: { energy: 100 } },
 38 |             { command: 'irradiate', hotkey: scienceVesselHotkeys.irradiate, icon: 'assets/images/irradiate_icon.png', name: 'Irradiate', cost: { energy: 75 } },
 39 |         ];
 40 | 
 41 |         this.baseY = this.hoverHeight;
 42 | 
 43 |         try {
 44 |             const asset = assetManager.get('science_vessel');
 45 |             this.mesh = this.createMeshFromGLB(asset);
 46 |         } catch (error) {
 47 |             console.warn("Could not load science vessel model, using procedural fallback.", error);
 48 |             this.mesh = this.createProceduralMesh();
 49 |         }
 50 | 
 51 |         this.mesh.position.copy(position);
 52 |         this.mesh.position.y = this.baseY;
 53 | 
 54 |         this.selected = false;
 55 |         this.path = [];
 56 |         this.currentWaypointIndex = 0;
 57 |         this.speed = 7.5;
 58 | 
 59 |         this.driveTime = 0;
 60 |         this.driveFrequency = 7;
 61 |         this.driveAmplitude = 0.25;
 62 | 
 63 |         const selectionGeometry = new THREE.RingGeometry(2.0, 2.2, 32);
 64 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 65 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 66 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 67 |         this.selectionIndicator.position.y = 0.01;
 68 |         this.selectionIndicator.visible = false;
 69 |         this.selectionIndicator.userData.owner = this;
 70 | 
 71 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 72 |     }
 73 | 
 74 |     createMeshFromGLB(asset) {
 75 |         const model = asset.scene.clone();
 76 |         const box = new THREE.Box3().setFromObject(model);
 77 |         const size = box.getSize(new THREE.Vector3());
 78 |         const desiredSize = 3.5;
 79 |         const maxDim = Math.max(size.x, size.y, size.z);
 80 | 
 81 |         if (maxDim > 0) {
 82 |             const scale = desiredSize / maxDim;
 83 |             model.scale.set(scale, scale, scale);
 84 |         }
 85 |         const wrapper = new THREE.Group();
 86 |         model.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
 87 |         wrapper.add(model);
 88 |         wrapper.traverse((child) => {
 89 |             if (child.isMesh) {
 90 |                 child.castShadow = true;
 91 |                 child.userData.owner = this;
 92 |             }
 93 |         });
 94 |         return wrapper;
 95 |     }
 96 | 
 97 |     createProceduralMesh() {
 98 |         const wrapper = new THREE.Group();
 99 |         const group = new THREE.Group();
100 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.4 });
101 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
102 |         const emissiveMaterial = new THREE.MeshStandardMaterial({ color: 0x00a1ff, emissive: 0x00a1ff, emissiveIntensity: 0.5 });
103 |         
104 |         const bodyGeo = new THREE.SphereGeometry(1.5, 16, 8);
105 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
106 |         group.add(body);
107 |         
108 |         const bottomGeo = new THREE.ConeGeometry(1, 1, 8);
109 |         const bottom = new THREE.Mesh(bottomGeo, darkMaterial);
110 |         bottom.position.y = -1.2;
111 |         group.add(bottom);
112 | 
113 |         const dishGeo = new THREE.CylinderGeometry(2, 2, 0.2, 16);
114 |         const dish = new THREE.Mesh(dishGeo, mainMaterial);
115 |         dish.position.y = 0.2;
116 |         group.add(dish);
117 | 
118 |         group.traverse((child) => {
119 |             if (child.isMesh) {
120 |                 child.userData.owner = this;
121 |                 child.castShadow = true;
122 |             }
123 |         });
124 |         group.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
125 |         wrapper.add(group);
126 |         return wrapper;
127 |     }
128 | 
129 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
130 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
131 | 
132 |     setPath(path) {
133 |         if (path && path.length > 0) {
134 |             this.path = path;
135 |             this.currentWaypointIndex = 0;
136 |             this.state = 'moving';
137 |         } else {
138 |             this.path = [];
139 |             this.state = 'idle';
140 |         }
141 |     }
142 | 
143 |     executeCommand(commandName, gameState, statusCallback) {
144 |         switch (commandName) {
145 |             case 'defensive_matrix':
146 |                 if (this.energy < 100) {
147 |                     statusCallback('Not enough energy.');
148 |                     break;
149 |                 }
150 |                 this.energy -= 100;
151 |                 createDefensiveMatrix(this.mesh.position);
152 |                 statusCallback('Defensive Matrix deployed.');
153 |                 break;
154 |             case 'emp_shockwave':
155 |                 if (!gameState.upgrades.empShockwave) {
156 |                     statusCallback('EMP Shockwave not researched.');
157 |                     break;
158 |                 }
159 |                 if (this.energy < 100) {
160 |                     statusCallback('Not enough energy.');
161 |                     break;
162 |                 }
163 |                 this.energy -= 100;
164 |                 createEMPShockwave(this.mesh.position);
165 |                 statusCallback('EMP Shockwave fired.');
166 |                 break;
167 |             case 'irradiate':
168 |                 if (this.energy < 75) {
169 |                     statusCallback('Not enough energy.');
170 |                     break;
171 |                 }
172 |                 this.energy -= 75;
173 |                 createIrradiate(this.mesh.position);
174 |                 statusCallback('Irradiate activated.');
175 |                 break;
176 |         }
177 |     }
178 | 
179 |     update(delta, pathfinder, gameState, buildings, scene) {
180 |         if (this.energy < this.maxEnergy) {
181 |             this.energy += 0.5625 * delta;
182 |         }
183 |         if (this.energy > this.maxEnergy) {
184 |             this.energy = this.maxEnergy;
185 |         }
186 | 
187 |         if (this.state === 'moving') {
188 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
189 |         } else {
190 |             this.driveTime += delta;
191 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
192 |         }
193 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
194 |     }
195 | 
196 |     updateMovement(delta, scene, onPathComplete) {
197 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
198 |             if (onPathComplete) onPathComplete();
199 |             return;
200 |         }
201 | 
202 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
203 |         targetPosition.y = this.hoverHeight;
204 | 
205 |         const distance = this.mesh.position.distanceTo(targetPosition);
206 | 
207 |         if (distance < 0.2) {
208 |             this.currentWaypointIndex++;
209 |         } else {
210 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
211 |             const moveDistance = this.speed * delta;
212 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
213 |             if (moveVector.length() > distance) moveVector.setLength(distance);
214 | 
215 |             this.mesh.position.add(moveVector);
216 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
217 |             this.mesh.lookAt(lookAtTarget);
218 |         }
219 |         
220 |         if (this.currentWaypointIndex >= this.path.length) {
221 |             this.path = [];
222 |             this.state = 'idle';
223 |             if (onPathComplete) onPathComplete();
224 |         }
225 |     }
226 | }


--------------------------------------------------------------------------------
/src/units/scv-base.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { getTerrainHeight } from '../utils/terrain.js';
  3 | 
  4 | export class SCVBase {
  5 |     constructor(position) {
  6 |         this.state = 'idle'; // idle, moving, movingToResource, gathering, returning, movingToGarrison
  7 |         this.isGarrisoned = false;
  8 |         this.garrisonTarget = null;
  9 |         this.isStuckOnDepot = false;
 10 |         this.stuckOnDepotInstance = null;
 11 | 
 12 |         this.targetResource = null;
 13 |         this.gatherPosition = null;
 14 |         this.dropOffPoint = null;
 15 |         this.resourceLoad = 0;
 16 |         this.resourceType = null; // 'minerals' or 'vespene'
 17 |         this.carryCapacity = 5;
 18 |         this.gatherTime = 2.0;
 19 |         this.gatherProgress = 0;
 20 | 
 21 |         this.baseY = position.y;
 22 |         this.mixer = null;
 23 | 
 24 |         this.selected = false;
 25 |         this.path = [];
 26 |         this.currentWaypointIndex = 0;
 27 |         this.speed = 3.5;
 28 | 
 29 |         this.driveTime = 0;
 30 |         this.driveFrequency = 15;
 31 |         this.driveAmplitude = 0.05;
 32 |     }
 33 | 
 34 |     stopActions() {
 35 |         if (this.targetResource && this.targetResource.removeMiner) {
 36 |             this.targetResource.removeMiner(this);
 37 |         }
 38 |         this.targetResource = null;
 39 |         this.gatherPosition = null;
 40 |         this.dropOffPoint = null;
 41 |         this.resourceLoad = 0;
 42 |         this.resourceType = null;
 43 | 
 44 |         if (this.buildingTarget) {
 45 |             this.buildingTarget = null;
 46 |         }
 47 | 
 48 |         if (this.garrisonTarget) {
 49 |             this.garrisonTarget = null;
 50 |         }
 51 |     }
 52 | 
 53 |     setupModel(model, position) {
 54 |         this.mesh = model;
 55 |         this.mesh.position.copy(position);
 56 | 
 57 |         const selectionGeometry = new THREE.RingGeometry(0.6, 0.7, 32);
 58 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 59 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 60 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 61 |         this.selectionIndicator.position.y = 0.01;
 62 |         this.selectionIndicator.visible = false;
 63 |         this.mesh.add(this.selectionIndicator);
 64 | 
 65 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 66 |     }
 67 | 
 68 |     addCarryVisuals(model) {
 69 |         this.mineralCarryMesh = new THREE.Mesh(
 70 |             new THREE.BoxGeometry(0.25, 0.25, 0.25),
 71 |             new THREE.MeshStandardMaterial({ color: 0x4169e1, emissive: 0x2030a0, emissiveIntensity: 0.5 })
 72 |         );
 73 |         this.mineralCarryMesh.position.set(0, 0.5, -0.3);
 74 |         this.mineralCarryMesh.visible = false;
 75 |         model.add(this.mineralCarryMesh);
 76 | 
 77 |         const gasMaterial = new THREE.SpriteMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
 78 |         this.vespeneCarrySprite = new THREE.Sprite(gasMaterial);
 79 |         this.vespeneCarrySprite.scale.set(0.6, 0.6, 0.6);
 80 |         this.vespeneCarrySprite.position.set(0, 0.6, -0.3);
 81 |         this.vespeneCarrySprite.visible = false;
 82 |         model.add(this.vespeneCarrySprite);
 83 |     }
 84 | 
 85 |     select() {
 86 |         this.selected = true;
 87 |         this.selectionIndicator.visible = true;
 88 |     }
 89 | 
 90 |     deselect() {
 91 |         this.selected = false;
 92 |         this.selectionIndicator.visible = false;
 93 |     }
 94 | 
 95 |     garrison(bunker) {
 96 |         if (this.isGarrisoned) return;
 97 |         this.stopActions();
 98 |         this.state = 'movingToGarrison';
 99 |         this.garrisonTarget = bunker;
100 |     }
101 | 
102 |     setPath(path) {
103 |         if (this.isStuckOnDepot) return;
104 |         if (path && path.length > 0) {
105 |             this.path = path;
106 |             this.currentWaypointIndex = 0;
107 |         } else {
108 |             this.path = [];
109 |         }
110 |     }
111 | 
112 |     gather(resource, allBuildings, gatherPosition) {
113 |         this.stopActions();
114 | 
115 |         this.targetResource = resource;
116 |         
117 |         if (typeof this.targetResource.addMiner === 'function') {
118 |             this.targetResource.addMiner(this);
119 |         }
120 | 
121 |         this.gatherPosition = gatherPosition;
122 |         this.findClosestDropOff(allBuildings);
123 |         if (this.targetResource && this.dropOffPoint) {
124 |             this.state = 'movingToResource';
125 |             this.path = [];
126 |         } else {
127 |             console.warn('SCV cannot gather, no resource or drop-off point found.');
128 |             this.state = 'idle';
129 |         }
130 |     }
131 | 
132 |     findClosestDropOff(allBuildings) {
133 |         let closest = null;
134 |         let minDistance = Infinity;
135 |         const depots = allBuildings.filter(b => b.name === 'Command Center');
136 |         depots.forEach(building => {
137 |             const distance = this.mesh.position.distanceToSquared(building.mesh.position);
138 |             if (distance < minDistance) {
139 |                 minDistance = distance;
140 |                 closest = building;
141 |             }
142 |         });
143 |         this.dropOffPoint = closest;
144 |     }
145 | 
146 |     update(delta, pathfinder, gameState, allBuildings, scene) {
147 |         if (this.isStuckOnDepot) {
148 |             this.state = 'idle';
149 |             this.path = [];
150 |             return;
151 |         }
152 | 
153 |         if (this.isGarrisoned) return;
154 | 
155 |         if (this.mixer) {
156 |             this.mixer.update(delta);
157 |         }
158 | 
159 |         this.mineralCarryMesh.visible = this.resourceType === 'minerals' && this.resourceLoad > 0;
160 |         this.vespeneCarrySprite.visible = this.resourceType === 'vespene' && this.resourceLoad > 0;
161 | 
162 |         switch (this.state) {
163 |             case 'idle':
164 |                 break;
165 |             case 'moving':
166 |                 this.updateMovement(delta, scene, () => { this.state = 'idle'; });
167 |                 break;
168 |             case 'movingToGarrison':
169 |                 if (!this.garrisonTarget) {
170 |                     this.state = 'idle';
171 |                     return;
172 |                 }
173 |                 this.updateMovement(delta, scene, () => {
174 |                     this.garrisonTarget.addUnit(this);
175 |                     this.garrisonTarget = null;
176 |                     this.state = 'idle';
177 |                 });
178 |                 break;
179 |             case 'movingToResource':
180 |                 if (!this.targetResource || this.targetResource.isDepleted) {
181 |                     this.state = 'idle';
182 |                     this.targetResource = null;
183 |                     this.gatherPosition = null;
184 |                     return;
185 |                 }
186 |                 if (!this.path || this.path.length === 0) {
187 |                     const targetPos = this.gatherPosition || this.targetResource.mesh.position;
188 |                     const newPath = pathfinder.findPath(this.mesh.position, targetPos);
189 |                     this.setPath(newPath);
190 |                     if (!this.path || this.path.length === 0) {
191 |                         this.state = 'idle';
192 |                         return;
193 |                     }
194 |                 }
195 |                 this.updateMovement(delta, scene, () => {
196 |                     this.mesh.lookAt(this.targetResource.mesh.position);
197 |                     this.state = 'gathering';
198 |                     this.gatherProgress = 0;
199 |                 });
200 |                 break;
201 |             case 'gathering':
202 |                 this.gatherProgress += delta;
203 |                 if (this.gatherProgress >= this.gatherTime) {
204 |                     this.gatherProgress = 0;
205 |                     const amountExtracted = this.targetResource.extract(this.carryCapacity);
206 |                     if (amountExtracted > 0) {
207 |                         this.resourceLoad = amountExtracted;
208 |                         this.resourceType = this.targetResource.resourceType;
209 |                         this.state = 'returning';
210 |                         this.path = [];
211 |                     } else {
212 |                         this.state = 'idle';
213 |                         this.targetResource = null;
214 |                     }
215 |                 }
216 |                 break;
217 |             case 'returning':
218 |                  if (!this.dropOffPoint) {
219 |                     this.findClosestDropOff(allBuildings);
220 |                     if (!this.dropOffPoint) {
221 |                         this.state = 'idle';
222 |                         return;
223 |                     }
224 |                  }
225 |                 const dropOffPos = this.dropOffPoint.mesh.position;
226 |                 if (!this.path || this.path.length === 0) {
227 |                     const newPath = pathfinder.findPath(this.mesh.position, dropOffPos);
228 |                     this.setPath(newPath);
229 |                     if (!this.path || this.path.length === 0) {
230 |                         this.state = 'idle';
231 |                         return;
232 |                     }
233 |                     this.state = 'returning';
234 |                 }
235 |                 this.updateMovement(delta, scene, () => {
236 |                     if (this.resourceType === 'minerals') {
237 |                         gameState.minerals += this.resourceLoad;
238 |                     } else if (this.resourceType === 'vespene') {
239 |                         gameState.vespene += this.resourceLoad;
240 |                     }
241 |                     this.resourceLoad = 0;
242 |                     this.resourceType = null;
243 | 
244 |                     if (this.targetResource && !this.targetResource.isDepleted) {
245 |                         this.state = 'movingToResource';
246 |                         this.path = [];
247 |                     } else {
248 |                         this.state = 'idle';
249 |                         this.targetResource = null;
250 |                     }
251 |                 });
252 |                 break;
253 |         }
254 |     }
255 | 
256 |     updateMovement(delta, scene, onPathComplete) {
257 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
258 |             if (onPathComplete) onPathComplete();
259 |             return;
260 |         }
261 | 
262 |         const targetPosition = this.path[this.currentWaypointIndex];
263 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
264 |         targetPosition.y = targetY;
265 |         this.baseY = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z);
266 | 
267 |         const currentPos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
268 |         const targetPos2D = new THREE.Vector2(targetPosition.x, targetPosition.z);
269 |         const distance = currentPos2D.distanceTo(targetPos2D);
270 | 
271 |         if (distance < 0.2) {
272 |             this.currentWaypointIndex++;
273 |         } else {
274 |             const direction = targetPosition.clone().sub(this.mesh.position);
275 |             direction.y = 0;
276 |             direction.normalize();
277 | 
278 |             const moveDistance = this.speed * delta;
279 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
280 | 
281 |             if (moveVector.length() > distance) {
282 |                 moveVector.setLength(distance);
283 |             }
284 | 
285 |             this.mesh.position.add(moveVector);
286 | 
287 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
288 |             this.mesh.lookAt(lookAtTarget);
289 | 
290 |             if (!this.mixer) {
291 |                 this.driveTime += delta;
292 |                 this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude);
293 |             }
294 |         }
295 | 
296 |         if (this.currentWaypointIndex >= this.path.length) {
297 |             this.path = [];
298 |             if (!this.mixer) {
299 |                 this.mesh.position.y = this.baseY;
300 |                 this.driveTime = 0;
301 |             }
302 |             if (onPathComplete) onPathComplete();
303 |         }
304 |     }
305 | }


--------------------------------------------------------------------------------
/src/units/scv-mark-2.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { SCVBase } from './scv-base.js';
  4 | 
  5 | /* @tweakable SCV Mark 2 animation settings */
  6 | const scv2AnimationConfig = {
  7 |     crossfadeDuration: 0.2,
  8 |     speedMultiplier: 1.0,
  9 | };
 10 | 
 11 | /** @tweakable Hotkeys for SCV Mark 2 commands. Change these values to customize keybinds. */
 12 | const scv2Hotkeys = {
 13 |     // Basic
 14 |     move: 'M',
 15 |     stop: 'T', // Changed from S
 16 |     hold: 'H',
 17 |     patrol: 'P',
 18 |     gather: 'G',
 19 |     repair: 'R',
 20 |     openBuildMenu: 'B',
 21 |     openAdvancedBuildMenu: 'V',
 22 |     cancelBuildMenu: 'Escape',
 23 |     // Basic Build
 24 |     buildCommandCenter: 'C',
 25 |     buildSupplyDepot: 'U', // Changed from S
 26 |     buildRefinery: 'R',
 27 |     buildBarracks: 'B',
 28 |     buildEngBay: 'E',
 29 |     buildAcademy: 'Y', // Changed from A
 30 |     buildBunker: 'K',
 31 |     buildMissileTurret: 'T',
 32 |     // Advanced Build
 33 |     buildFactory: 'F',
 34 |     buildStarport: 'P', // Changed from S
 35 |     buildArmory: 'R', // Changed from A
 36 |     buildScienceFacility: 'C',
 37 | };
 38 | 
 39 | export class SCVMark2 extends SCVBase {
 40 |     constructor(position) {
 41 |         super(position);
 42 |         this.name = 'SCV Mark 2';
 43 |         this.portraitUrl = 'assets/images/scv2.png';
 44 |         this.maxHealth = 75;
 45 |         this.currentHealth = 75;
 46 | 
 47 |         this.carryCapacity = 8; // Mark 2 can carry more
 48 |         this.gatherTime = 2.0;
 49 |         this.gatherProgress = 0;
 50 |         this.buildingTarget = null;
 51 |         this.commandMode = 'basic'; // 'basic', 'build', or 'build_advanced'
 52 |         this._commands = [];
 53 | 
 54 |         this.mixer = null;
 55 |         this.animations = {};
 56 |         this.activeAnimation = null;
 57 | 
 58 |         try {
 59 |             const scvAsset = assetManager.get('extra_scv2');
 60 |             const { wrapper, model } = this.createMeshFromGLB(scvAsset);
 61 |             this.mesh = wrapper;
 62 |             this.model = model;
 63 | 
 64 |             this.mixer = new THREE.AnimationMixer(this.model);
 65 | 
 66 |             // Separate animation files are loaded via the extra-assets manifest
 67 |             const idleAsset = assetManager.get('extra_Animation_Idle');
 68 |             const walkAsset = assetManager.get('extra_Animation_Walking');
 69 |             const mineRepairAsset = assetManager.get('extra_Animation_MineRepair');
 70 | 
 71 |             if (idleAsset && idleAsset.animations && idleAsset.animations[0]) {
 72 |                 this.animations.idle = this.mixer.clipAction(idleAsset.animations[0]);
 73 |             }
 74 |             if (walkAsset && walkAsset.animations && walkAsset.animations[0]) {
 75 |                 this.animations.walk = this.mixer.clipAction(walkAsset.animations[0]);
 76 |             }
 77 |             if (mineRepairAsset && mineRepairAsset.animations && mineRepairAsset.animations[0]) {
 78 |                 this.animations.mineRepair = this.mixer.clipAction(mineRepairAsset.animations[0]);
 79 |             }
 80 |             
 81 |             this.switchAnimation('idle');
 82 |         } catch (error) {
 83 |             console.error("Failed to initialize SCV Mark 2 with animations:", error);
 84 |             this.mesh = this.createProceduralMesh();
 85 |         }
 86 | 
 87 |         this.setupModel(this.mesh, position);
 88 |         this.speed = 4.0;
 89 |         this.updateCommands({});
 90 |     }
 91 |     
 92 |     get commands() {
 93 |         return this._commands;
 94 |     }
 95 |     
 96 |     updateCommands(gameState) {
 97 |         const commands = new Array(12).fill(null);
 98 | 
 99 |         if (this.commandMode === 'build') {
100 |             commands[0] = { command: 'build_command_center', hotkey: scv2Hotkeys.buildCommandCenter, icon: 'assets/images/build_command_center_icon.png', name: 'Build Command Center', cost: { minerals: 400 }, buildTime: 75.6 };
101 |             commands[1] = { command: 'build_supply_depot', hotkey: scv2Hotkeys.buildSupplyDepot, icon: 'assets/images/build_supply_depot_icon.png', name: 'Build Supply Depot', cost: { minerals: 100 }, buildTime: 25.2 };
102 |             commands[2] = { command: 'build_refinery', hotkey: scv2Hotkeys.buildRefinery, icon: 'assets/images/build_refinery_icon.png', name: 'Build Refinery', cost: { minerals: 100 }, buildTime: 25.2 };
103 |             commands[3] = { command: 'build_barracks', hotkey: scv2Hotkeys.buildBarracks, icon: 'assets/images/build_barracks_icon.png', name: 'Build Barracks', cost: { minerals: 150 }, buildTime: 50.4 };
104 |             commands[4] = { command: 'build_engineering_bay', hotkey: scv2Hotkeys.buildEngBay, icon: 'assets/images/build_engineering_bay_icon.png', name: 'Build Engineering Bay', cost: { minerals: 125 }, buildTime: 37.8 };
105 |             commands[5] = { command: 'build_academy', hotkey: scv2Hotkeys.buildAcademy, icon: 'assets/images/build_academy_icon.png', name: 'Build Academy', cost: { minerals: 150 }, buildTime: 50.4, prereq: 'barracksBuilt' };
106 |             commands[6] = { command: 'build_bunker', hotkey: scv2Hotkeys.buildBunker, icon: 'assets/images/build_bunker_icon.png', name: 'Build Bunker', cost: { minerals: 100 }, buildTime: 18.9 };
107 |             
108 |             commands[7] = { command: 'build_missile_turret', hotkey: scv2Hotkeys.buildMissileTurret, icon: 'assets/images/build_missile_turret_icon.png', name: 'Build Missile Turret', cost: { minerals: 75 }, buildTime: 18.9, prereq: 'engineeringBayBuilt' };
109 | 
110 |             commands[11] = { command: 'cancel_build_menu', hotkey: scv2Hotkeys.cancelBuildMenu, icon: 'assets/images/stop_icon.png', name: 'Cancel' };
111 |         } else if (this.commandMode === 'build_advanced') {
112 |             commands[0] = {
113 |                 command: 'build_factory',
114 |                 hotkey: scv2Hotkeys.buildFactory,
115 |                 icon: 'assets/images/build_factory_icon.png',
116 |                 name: 'Build Factory',
117 |                 cost: { minerals: 200, vespene: 100 },
118 |                 buildTime: 50.4,
119 |                 prereq: 'barracksBuilt'
120 |             };
121 |             commands[1] = {
122 |                 command: 'build_starport',
123 |                 hotkey: scv2Hotkeys.buildStarport,
124 |                 icon: 'assets/images/build_starport_icon.png',
125 |                 name: 'Build Starport',
126 |                 cost: { minerals: 150, vespene: 100 },
127 |                 buildTime: 50.4,
128 |                 prereq: 'factoryBuilt'
129 |             };
130 |             commands[2] = {
131 |                 command: 'build_armory',
132 |                 hotkey: scv2Hotkeys.buildArmory,
133 |                 icon: 'assets/images/build_armory_icon.png',
134 |                 name: 'Build Armory',
135 |                 cost: { minerals: 100, vespene: 50 },
136 |                 buildTime: 50.4,
137 |                 prereq: 'factoryBuilt'
138 |             };
139 |             commands[3] = {
140 |                 command: 'build_science_facility',
141 |                 hotkey: scv2Hotkeys.buildScienceFacility,
142 |                 icon: 'assets/images/build_science_facility_icon.png',
143 |                 name: 'Build Science Facility',
144 |                 cost: { minerals: 100, vespene: 150 },
145 |                 buildTime: 60,
146 |                 prereq: 'starportBuilt'
147 |             };
148 | 
149 |             // Here you could add Science Facility, etc.
150 |             
151 |             commands[11] = { command: 'cancel_build_menu', hotkey: scv2Hotkeys.cancelBuildMenu, icon: 'assets/images/stop_icon.png', name: 'Cancel' };
152 |         } else { // 'basic' mode
153 |             commands[0] = { command: 'move', hotkey: scv2Hotkeys.move, icon: 'assets/images/move_icon.png', name: 'Move' };
154 |             commands[1] = { command: 'stop', hotkey: scv2Hotkeys.stop, icon: 'assets/images/stop_icon.png', name: 'Stop' };
155 |             commands[2] = { command: 'hold', hotkey: scv2Hotkeys.hold, icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' };
156 |             commands[3] = { command: 'patrol', hotkey: scv2Hotkeys.patrol, icon: 'assets/images/patrol_icon.png', name: 'Patrol' };
157 |             commands[4] = { command: 'gather', hotkey: scv2Hotkeys.gather, icon: 'assets/images/gather_icon.png', name: 'Gather' };
158 |             commands[5] = { command: 'repair', hotkey: scv2Hotkeys.repair, icon: 'assets/images/heal_icon.png', name: 'Repair' };
159 |             commands[6] = { command: 'open_build_menu', hotkey: scv2Hotkeys.openBuildMenu, icon: 'assets/images/build_basic_structures_icon.png', name: 'Build Basic Structures' };
160 |             commands[7] = { command: 'open_advanced_build_menu', hotkey: scv2Hotkeys.openAdvancedBuildMenu, icon: 'assets/images/build_advanced_structures_icon.png', name: 'Build Advanced Structures' };
161 |         }
162 | 
163 |         this._commands = commands;
164 |     }
165 |     
166 |     createMeshFromGLB(asset) {
167 |         const model = asset.scene.clone();
168 | 
169 |         const box = new THREE.Box3().setFromObject(model);
170 |         const size = box.getSize(new THREE.Vector3());
171 |         const desiredSize = 0.9; 
172 |         const maxDim = Math.max(size.x, size.y, size.z);
173 |         
174 |         if (maxDim > 0) { 
175 |             const scale = desiredSize / maxDim;
176 |             model.scale.set(scale, scale, scale);
177 |         }
178 | 
179 |         const scaledBox = new THREE.Box3().setFromObject(model);
180 |         model.position.set(
181 |             -(scaledBox.min.x + scaledBox.max.x) / 2,
182 |             -scaledBox.min.y,
183 |             -(scaledBox.min.z + scaledBox.max.z) / 2
184 |         );
185 | 
186 |         model.traverse((child) => {
187 |             if (child.isMesh) {
188 |                 child.castShadow = true;
189 |                 child.userData.owner = this;
190 |             }
191 |         });
192 |         
193 |         this.addCarryVisuals(model);
194 | 
195 |         const wrapper = new THREE.Group();
196 |         wrapper.add(model);
197 | 
198 |         return { wrapper, model };
199 |     }
200 |     
201 |     createProceduralMesh() {
202 |         const group = new THREE.Group();
203 |         const scvMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.7, roughness: 0.5 }); 
204 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
205 |         const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 }); 
206 | 
207 |         const bodyGeo = new THREE.BoxGeometry(0.8, 0.6, 1);
208 |         const body = new THREE.Mesh(bodyGeo, scvMaterial);
209 |         body.position.y = 0.4;
210 |         body.castShadow = true;
211 |         group.add(body);
212 | 
213 |         const cockpitGeo = new THREE.BoxGeometry(0.5, 0.3, 0.2);
214 |         const cockpit = new THREE.Mesh(cockpitGeo, cockpitMaterial);
215 |         cockpit.position.set(0, 0.6, 0.45);
216 |         group.add(cockpit);
217 | 
218 |         const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 6);
219 |         const leftArm = new THREE.Mesh(armGeo, darkMaterial);
220 |         leftArm.position.set(0.5, 0.4, 0);
221 |         leftArm.rotation.z = Math.PI / 4;
222 |         leftArm.castShadow = true;
223 |         group.add(leftArm);
224 | 
225 |         const rightArm = leftArm.clone();
226 |         rightArm.position.x = -0.5;
227 |         rightArm.rotation.z = -Math.PI / 4;
228 |         group.add(rightArm);
229 |         
230 |         const treadGeo = new THREE.BoxGeometry(0.2, 0.3, 1.2);
231 |         const leftTread = new THREE.Mesh(treadGeo, darkMaterial);
232 |         leftTread.position.set(0.5, 0.15, 0);
233 |         leftTread.castShadow = true;
234 |         group.add(leftTread);
235 | 
236 |         const rightTread = leftTread.clone();
237 |         rightTread.position.x = -0.5;
238 |         group.add(rightTread);
239 | 
240 |         group.traverse((child) => {
241 |             if (child instanceof THREE.Mesh) {
242 |                 child.userData.owner = this;
243 |             }
244 |         });
245 | 
246 |         group.scale.set(0.8, 0.8, 0.8);
247 |         this.addCarryVisuals(group);
248 |         return group;
249 |     }
250 | 
251 |     switchAnimation(name) {
252 |         if (!this.mixer || !this.animations[name]) return;
253 | 
254 |         const nextAction = this.animations[name];
255 |         const currentAction = this.activeAnimation;
256 | 
257 |         if (currentAction !== nextAction) {
258 |             nextAction.reset();
259 |             nextAction.timeScale = scv2AnimationConfig.speedMultiplier;
260 |             nextAction.play();
261 |             if (currentAction) {
262 |                 currentAction.crossFadeTo(nextAction, scv2AnimationConfig.crossfadeDuration, true);
263 |             }
264 |             this.activeAnimation = nextAction;
265 |         }
266 |     }
267 | 
268 |     updateAnimationBasedOnState() {
269 |         let anim = 'idle';
270 |         switch (this.state) {
271 |             case 'moving':
272 |             case 'movingToBuild':
273 |             case 'movingToResource':
274 |             case 'movingToRepair':
275 |             case 'movingToGarrison':
276 |             case 'returning':
277 |                 anim = 'walk';
278 |                 break;
279 |             case 'gathering':
280 |             case 'building':
281 |             case 'repairing':
282 |                 anim = 'mineRepair';
283 |                 break;
284 |         }
285 |         this.switchAnimation(anim);
286 |     }
287 | 
288 | 
289 |     build(buildingInstance, pathfinder, targetPosition = null) {
290 |         this.stopActions();
291 |         this.state = 'movingToBuild';
292 |         this.buildingTarget = buildingInstance;
293 | 
294 |         let finalTargetPos = targetPosition;
295 |         if (!finalTargetPos) {
296 |             // Pathfind to a spot next to the building site (default logic for one SCV)
297 |             const buildingCollider = this.buildingTarget.getCollider();
298 |             const size = buildingCollider.getSize(new THREE.Vector3());
299 |             const buildPosition = this.buildingTarget.mesh.position;
300 |             const radius = Math.max(size.x, size.z) / 2 + 1.5; // SCV radius + buffer
301 |             
302 |             finalTargetPos = new THREE.Vector3(
303 |                 buildPosition.x + radius,
304 |                 buildPosition.y,
305 |                 buildPosition.z
306 |             );
307 |         }
308 | 
309 |         const path = pathfinder.findPath(this.mesh.position, finalTargetPos);
310 |         this.setPath(path);
311 |     }
312 | 
313 |     update(delta, pathfinder, gameState, allBuildings, scene) {
314 |         if (this.isGarrisoned) return;
315 | 
316 |         if (this.mixer) {
317 |             this.mixer.update(delta);
318 |         }
319 | 
320 |         this.updateCommands(gameState);
321 | 
322 |         if (this.state === 'movingToBuild') {
323 |             if (!this.buildingTarget) {
324 |                 this.state = 'idle';
325 |             }
326 |             this.updateMovement(delta, scene, () => {
327 |                 this.state = 'building';
328 |                 if(this.buildingTarget) this.mesh.lookAt(this.buildingTarget.mesh.position);
329 |             });
330 |         } else if (this.state === 'building') {
331 |             if (!this.buildingTarget) {
332 |                 this.state = 'idle';
333 |             } else {
334 |                 const buildRate = (this.buildingTarget.maxHealth / this.buildingTarget.buildTime) * delta;
335 |                 this.buildingTarget.currentHealth += buildRate;
336 |                 if (this.buildingTarget.currentHealth >= this.buildingTarget.maxHealth) {
337 |                     this.buildingTarget.currentHealth = this.buildingTarget.maxHealth;
338 |                     this.buildingTarget.onConstructionComplete(gameState);
339 |                     this.state = 'idle';
340 |                     this.buildingTarget = null;
341 |                 }
342 |             }
343 |         } else {
344 |             super.update(delta, pathfinder, gameState, allBuildings, scene);
345 |         }
346 | 
347 |         this.updateAnimationBasedOnState();
348 |     }
349 |     
350 | }


--------------------------------------------------------------------------------
/src/units/scv.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { SCVBase } from './scv-base.js';
  4 | 
  5 | /** @tweakable Hotkeys for SCV commands. Change these values to customize keybinds. */
  6 | const scvHotkeys = {
  7 |     move: 'M',
  8 |     stop: 'T', // Changed from S
  9 |     hold: 'H',
 10 |     patrol: 'P',
 11 |     gather: 'G',
 12 |     repair: 'R',
 13 |     openBuildMenu: 'B',
 14 |     cancelBuildMenu: 'Escape',
 15 |     // Build menu hotkeys
 16 |     buildCommandCenter: 'C',
 17 |     buildSupplyDepot: 'U',
 18 |     buildRefinery: 'R',
 19 |     buildBarracks: 'B',
 20 | };
 21 | 
 22 | export class SCV extends SCVBase {
 23 |     constructor(position) {
 24 |         super(position);
 25 |         this.name = 'SCV';
 26 |         this.portraitUrl = 'assets/images/scv_portrait.png';
 27 |         this.maxHealth = 60;
 28 |         this.currentHealth = 60;
 29 | 
 30 |         this.carryCapacity = 5;
 31 |         this.gatherTime = 2.0; // seconds to gather
 32 | 
 33 |         this.commandMode = 'basic'; // 'basic' or 'build'
 34 |         this._commands = [];
 35 |         this.buildingTarget = null;
 36 |         this.repairTarget = null;
 37 |         
 38 |         this.sounds = {
 39 |             select: ['extra_scv_ack1', 'extra_scv_ack2'],
 40 |             move: ['extra_SCV_move', 'extra_SCV_move2']
 41 |         };
 42 | 
 43 |         this.mixer = null; // Animation mixer
 44 | 
 45 |         // Try to use GLB model, otherwise fallback to procedural
 46 |         try {
 47 |             const scvAsset = assetManager.get('scv');
 48 |             const { wrapper, model } = this.createMeshFromGLB(scvAsset);
 49 |             this.mesh = wrapper;
 50 |             this.model = model;
 51 | 
 52 |             // Setup animations on the inner model so rotation isn't overwritten
 53 |             if (scvAsset.animations && scvAsset.animations.length) {
 54 |                 this.mixer = new THREE.AnimationMixer(this.model);
 55 |                 // Just play the first animation clip found on a loop.
 56 |                 const action = this.mixer.clipAction(scvAsset.animations[0]);
 57 |                 action.play();
 58 |             }
 59 |         } catch (error) {
 60 |             this.mesh = this.createProceduralMesh();
 61 |         }
 62 | 
 63 |         this.setupModel(this.mesh, position);
 64 |         this.speed = 3.5; // SCVs are a bit slower than marines
 65 |         this.updateCommands({});
 66 |     }
 67 | 
 68 |     get commands() {
 69 |         return this._commands;
 70 |     }
 71 | 
 72 |     updateCommands(gameState) {
 73 |         const commands = new Array(12).fill(null);
 74 | 
 75 |         if (this.commandMode === 'build') {
 76 |             commands[0] = { command: 'build_command_center', hotkey: scvHotkeys.buildCommandCenter, icon: 'assets/images/build_command_center_icon.png', name: 'Build Command Center', cost: { minerals: 400 }, buildTime: 75.6 };
 77 |             commands[1] = { command: 'build_supply_depot', hotkey: scvHotkeys.buildSupplyDepot, icon: 'assets/images/build_supply_depot_icon.png', name: 'Build Supply Depot', cost: { minerals: 100 }, buildTime: 25.2 };
 78 |             commands[2] = { command: 'build_refinery', hotkey: scvHotkeys.buildRefinery, icon: 'assets/images/build_refinery_icon.png', name: 'Build Refinery', cost: { minerals: 100 }, buildTime: 25.2 };
 79 |             commands[3] = { command: 'build_barracks', hotkey: scvHotkeys.buildBarracks, icon: 'assets/images/build_barracks_icon.png', name: 'Build Barracks', cost: { minerals: 150 }, buildTime: 50.4 };
 80 |             commands[11] = { command: 'cancel_build_menu', hotkey: scvHotkeys.cancelBuildMenu, icon: 'assets/images/stop_icon.png', name: 'Cancel' };
 81 |         } else {
 82 |             commands[0] = { command: 'move', hotkey: scvHotkeys.move, icon: 'assets/images/move_icon.png', name: 'Move' };
 83 |             commands[1] = { command: 'stop', hotkey: scvHotkeys.stop, icon: 'assets/images/stop_icon.png', name: 'Stop' };
 84 |             commands[2] = { command: 'hold', hotkey: scvHotkeys.hold, icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' };
 85 |             commands[3] = { command: 'patrol', hotkey: scvHotkeys.patrol, icon: 'assets/images/patrol_icon.png', name: 'Patrol' };
 86 |             commands[4] = { command: 'gather', hotkey: scvHotkeys.gather, icon: 'assets/images/gather_icon.png', name: 'Gather' };
 87 |             commands[5] = { command: 'repair', hotkey: scvHotkeys.repair, icon: 'assets/images/heal_icon.png', name: 'Repair' };
 88 |             commands[6] = { command: 'open_build_menu', hotkey: scvHotkeys.openBuildMenu, icon: 'assets/images/build_basic_structures_icon.png', name: 'Build Structures' };
 89 |         }
 90 | 
 91 |         this._commands = commands;
 92 |     }
 93 | 
 94 |     createMeshFromGLB(asset) {
 95 |         const model = asset.scene.clone();
 96 | 
 97 |         // Scale it down to be the same size as the current SCVs
 98 |         const box = new THREE.Box3().setFromObject(model);
 99 |         const size = box.getSize(new THREE.Vector3());
100 |         const desiredSize = 0.9; // Target largest dimension
101 |         const maxDim = Math.max(size.x, size.y, size.z);
102 |         
103 |         if (maxDim > 0) { // Avoid division by zero
104 |             const scale = desiredSize / maxDim;
105 |             model.scale.set(scale, scale, scale);
106 |         }
107 | 
108 |         // Center the model so it sits on the ground
109 |         const scaledBox = new THREE.Box3().setFromObject(model);
110 |         model.position.y = -scaledBox.min.y;
111 | 
112 |         model.traverse((child) => {
113 |             if (child.isMesh) {
114 |                 child.castShadow = true;
115 |                 child.userData.owner = this;
116 |             }
117 |         });
118 |         
119 |         this.addCarryVisuals(model);
120 | 
121 |         const wrapper = new THREE.Group();
122 |         wrapper.add(model);
123 | 
124 |         return { wrapper, model };
125 |     }
126 | 
127 |     createProceduralMesh() {
128 |         const group = new THREE.Group();
129 |         const scvMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00, metalness: 0.6, roughness: 0.5 });
130 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
131 |         const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x00a1ff, emissive: 0x00a1ff, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 });
132 | 
133 |         // Body
134 |         const bodyGeo = new THREE.BoxGeometry(0.8, 0.6, 1);
135 |         const body = new THREE.Mesh(bodyGeo, scvMaterial);
136 |         body.position.y = 0.4;
137 |         body.castShadow = true;
138 |         group.add(body);
139 | 
140 |         // Cockpit
141 |         const cockpitGeo = new THREE.BoxGeometry(0.5, 0.3, 0.2);
142 |         const cockpit = new THREE.Mesh(cockpitGeo, cockpitMaterial);
143 |         cockpit.position.set(0, 0.6, 0.45);
144 |         group.add(cockpit);
145 | 
146 |         // Arms (simple cylinders for now)
147 |         const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 6);
148 |         const leftArm = new THREE.Mesh(armGeo, darkMaterial);
149 |         leftArm.position.set(0.5, 0.4, 0);
150 |         leftArm.rotation.z = Math.PI / 4;
151 |         leftArm.castShadow = true;
152 |         group.add(leftArm);
153 | 
154 |         const rightArm = leftArm.clone();
155 |         rightArm.position.x = -0.5;
156 |         rightArm.rotation.z = -Math.PI / 4;
157 |         group.add(rightArm);
158 |         
159 |         // Treads/Wheels (represented by boxes)
160 |         const treadGeo = new THREE.BoxGeometry(0.2, 0.3, 1.2);
161 |         const leftTread = new THREE.Mesh(treadGeo, darkMaterial);
162 |         leftTread.position.set(0.5, 0.15, 0);
163 |         leftTread.castShadow = true;
164 |         group.add(leftTread);
165 | 
166 |         const rightTread = leftTread.clone();
167 |         rightTread.position.x = -0.5;
168 |         group.add(rightTread);
169 | 
170 |         group.traverse((child) => {
171 |             if (child instanceof THREE.Mesh) {
172 |                 child.userData.owner = this;
173 |             }
174 |         });
175 | 
176 |         group.scale.set(0.8, 0.8, 0.8);
177 |         this.addCarryVisuals(group);
178 |         return group;
179 |     }
180 | 
181 |     build(buildingInstance, pathfinder, targetPosition = null) {
182 |         this.stopActions();
183 |         this.state = 'movingToBuild';
184 |         this.buildingTarget = buildingInstance;
185 | 
186 |         let finalTargetPos = targetPosition;
187 |         if (!finalTargetPos) {
188 |             const buildingCollider = this.buildingTarget.getCollider();
189 |             const size = buildingCollider.getSize(new THREE.Vector3());
190 |             const buildPosition = this.buildingTarget.mesh.position;
191 |             const radius = Math.max(size.x, size.z) / 2 + 1.5;
192 | 
193 |             finalTargetPos = new THREE.Vector3(
194 |                 buildPosition.x + radius,
195 |                 buildPosition.y,
196 |                 buildPosition.z
197 |             );
198 |         }
199 | 
200 |         const path = pathfinder.findPath(this.mesh.position, finalTargetPos);
201 |         this.setPath(path);
202 |     }
203 | 
204 |     repair(target, pathfinder, targetPosition = null) {
205 |         this.stopActions();
206 |         this.state = 'movingToRepair';
207 |         this.repairTarget = target;
208 | 
209 |         let finalTargetPos = targetPosition;
210 |         if (!finalTargetPos) {
211 |             const collider = this.repairTarget.getCollider();
212 |             const size = collider.getSize(new THREE.Vector3());
213 |             const pos = this.repairTarget.mesh.position;
214 |             const radius = Math.max(size.x, size.z) / 2 + 1.5;
215 | 
216 |             finalTargetPos = new THREE.Vector3(
217 |                 pos.x + radius,
218 |                 pos.y,
219 |                 pos.z
220 |             );
221 |         }
222 | 
223 |         const path = pathfinder.findPath(this.mesh.position, finalTargetPos);
224 |         this.setPath(path);
225 |     }
226 | 
227 |     executeCommand(commandName, gameState, statusCallback) {
228 |         if (commandName === 'repair') {
229 |             statusCallback('Right-click a damaged unit or building to repair.');
230 |         }
231 |     }
232 | 
233 |     update(delta, pathfinder, gameState, allBuildings, scene) {
234 |         if (this.isGarrisoned) return;
235 | 
236 |         this.updateCommands(gameState);
237 | 
238 |         if (this.state === 'movingToBuild') {
239 |             if (!this.buildingTarget) {
240 |                 this.state = 'idle';
241 |                 return;
242 |             }
243 |             this.updateMovement(delta, scene, () => {
244 |                 this.state = 'building';
245 |                 this.mesh.lookAt(this.buildingTarget.mesh.position);
246 |             });
247 |             return;
248 |         }
249 | 
250 |         if (this.state === 'building') {
251 |             if (!this.buildingTarget) {
252 |                 this.state = 'idle';
253 |                 return;
254 |             }
255 |             const buildRate = (this.buildingTarget.maxHealth / this.buildingTarget.buildTime) * delta;
256 |             this.buildingTarget.currentHealth += buildRate;
257 |             if (this.buildingTarget.currentHealth >= this.buildingTarget.maxHealth) {
258 |                 this.buildingTarget.currentHealth = this.buildingTarget.maxHealth;
259 |                 this.buildingTarget.onConstructionComplete(gameState);
260 |                 this.state = 'idle';
261 |                 this.buildingTarget = null;
262 |             }
263 |             return;
264 |         }
265 | 
266 |         if (this.state === 'movingToRepair') {
267 |             if (!this.repairTarget || this.repairTarget.currentHealth >= this.repairTarget.maxHealth) {
268 |                 this.state = 'idle';
269 |                 this.repairTarget = null;
270 |                 return;
271 |             }
272 |             this.updateMovement(delta, scene, () => {
273 |                 this.state = 'repairing';
274 |                 this.mesh.lookAt(this.repairTarget.mesh.position);
275 |             });
276 |             return;
277 |         }
278 | 
279 |         if (this.state === 'repairing') {
280 |             if (!this.repairTarget || this.repairTarget.currentHealth >= this.repairTarget.maxHealth) {
281 |                 this.state = 'idle';
282 |                 this.repairTarget = null;
283 |                 return;
284 |             }
285 |             const repairRate = 10 * delta;
286 |             this.repairTarget.currentHealth += repairRate;
287 |             if (this.repairTarget.currentHealth >= this.repairTarget.maxHealth) {
288 |                 this.repairTarget.currentHealth = this.repairTarget.maxHealth;
289 |                 this.state = 'idle';
290 |                 this.repairTarget = null;
291 |             }
292 |             return;
293 |         }
294 | 
295 |         super.update(delta, pathfinder, gameState, allBuildings, scene);
296 |     }
297 | }


--------------------------------------------------------------------------------
/src/units/siege-tank.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { getTerrainHeight } from '../utils/terrain.js';
  3 | 
  4 | export class SiegeTank {
  5 |     constructor(position) {
  6 |         this.name = 'Siege Tank';
  7 |         this.portraitUrl = 'assets/images/siege_tank_portrait.png';
  8 |         this.maxHealth = 150;
  9 |         this.currentHealth = 150;
 10 |         
 11 |         this.mode = 'tank'; // 'tank', 'siege', 'transforming_to_siege', 'transforming_to_tank'
 12 |         this.state = 'idle'; // 'idle', 'moving', 'attacking'
 13 |         this.animationProgress = 0;
 14 |         this.animationDuration = 2.0; // seconds to transform
 15 | 
 16 |         this.isGarrisoned = false; // Cannot be garrisoned
 17 |         this.isStuckOnDepot = false;
 18 |         this.stuckOnDepotInstance = null;
 19 | 
 20 |         this._commands = [];
 21 | 
 22 |         this.baseY = position.y;
 23 |         this.mesh = this.createMesh();
 24 |         this.mesh.position.copy(position);
 25 | 
 26 |         this.selected = false;
 27 |         this.path = [];
 28 |         this.currentWaypointIndex = 0;
 29 |         this.speed = 3.0;
 30 | 
 31 |         // For hover/drive animation
 32 |         this.driveTime = 0;
 33 |         this.driveFrequency = 15;
 34 |         this.driveAmplitude = 0.05;
 35 | 
 36 |         const selectionGeometry = new THREE.RingGeometry(2.2, 2.4, 32);
 37 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 38 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 39 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 40 |         this.selectionIndicator.position.y = 0.01;
 41 |         this.selectionIndicator.visible = false;
 42 |         this.mesh.add(this.selectionIndicator);
 43 | 
 44 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 45 |     }
 46 |     
 47 |     get commands() {
 48 |         return this._commands;
 49 |     }
 50 | 
 51 |     updateCommands(gameState) {
 52 |         const newCommands = new Array(12).fill(null);
 53 |         if (this.mode === 'tank') {
 54 |             newCommands[0] = { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' };
 55 |             newCommands[1] = { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' };
 56 |             newCommands[2] = { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' };
 57 |             newCommands[3] = { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' };
 58 |             newCommands[4] = { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' };
 59 |             if (gameState.upgrades.siegeModeResearched) {
 60 |                 newCommands[8] = { command: 'siege_mode', hotkey: 'E', icon: 'assets/images/siege_mode_icon.png', name: 'Siege Mode' };
 61 |             }
 62 |         } else if (this.mode === 'siege') {
 63 |             newCommands[4] = { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' };
 64 |             newCommands[8] = { command: 'tank_mode', hotkey: 'E', icon: 'assets/images/tank_mode_icon.png', name: 'Tank Mode' };
 65 |         }
 66 |         // No commands while transforming
 67 |         this._commands = newCommands;
 68 |     }
 69 | 
 70 |     createMesh() {
 71 |         const group = new THREE.Group();
 72 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8aaa, metalness: 0.8, roughness: 0.4 });
 73 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
 74 | 
 75 |         // Body
 76 |         const bodyGeo = new THREE.BoxGeometry(2.5, 1, 3.5);
 77 |         this.body = new THREE.Mesh(bodyGeo, mainMaterial);
 78 |         this.body.position.y = 0.5;
 79 |         group.add(this.body);
 80 | 
 81 |         // Treads
 82 |         const treadGeo = new THREE.BoxGeometry(3, 0.8, 0.8);
 83 |         const leftTread = new THREE.Mesh(treadGeo, darkMaterial);
 84 |         leftTread.position.set(0, 0.4, 1.5);
 85 |         group.add(leftTread);
 86 |         const rightTread = leftTread.clone();
 87 |         rightTread.position.z = -1.5;
 88 |         group.add(rightTread);
 89 |         
 90 |         // Turret
 91 |         this.turret = new THREE.Group();
 92 |         const turretBaseGeo = new THREE.CylinderGeometry(1, 1.2, 0.8, 8);
 93 |         const turretBase = new THREE.Mesh(turretBaseGeo, mainMaterial);
 94 |         this.turret.add(turretBase);
 95 | 
 96 |         const cannonGeo = new THREE.CylinderGeometry(0.2, 0.2, 4, 8);
 97 |         this.cannon = new THREE.Mesh(cannonGeo, darkMaterial);
 98 |         this.cannon.rotation.z = Math.PI / 2;
 99 |         this.cannon.position.x = 2;
100 |         this.turret.add(this.cannon);
101 |         
102 |         this.turret.position.y = 1.4;
103 |         group.add(this.turret);
104 |         
105 |         // Siege mode parts
106 |         this.siegeParts = new THREE.Group();
107 |         const legGeo = new THREE.BoxGeometry(0.4, 1.5, 0.4);
108 |         const leg1 = new THREE.Mesh(legGeo, darkMaterial);
109 |         leg1.position.set(1, -0.75, 1.5);
110 |         this.siegeParts.add(leg1);
111 |         const leg2 = leg1.clone();
112 |         leg2.position.set(-1, -0.75, 1.5);
113 |         this.siegeParts.add(leg2);
114 |         const leg3 = leg1.clone();
115 |         leg3.position.set(1, -0.75, -1.5);
116 |         this.siegeParts.add(leg3);
117 |         const leg4 = leg1.clone();
118 |         leg4.position.set(-1, -0.75, -1.5);
119 |         this.siegeParts.add(leg4);
120 |         
121 |         this.siegeParts.visible = false;
122 |         this.body.add(this.siegeParts);
123 | 
124 |         group.traverse((child) => {
125 |             if (child.isMesh) {
126 |                 child.castShadow = true;
127 |                 child.userData.owner = this;
128 |             }
129 |         });
130 | 
131 |         group.scale.set(0.9, 0.9, 0.9);
132 | 
133 |         return group;
134 |     }
135 | 
136 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
137 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
138 | 
139 |     setPath(path) {
140 |         if (this.mode !== 'tank' || this.isStuckOnDepot) return;
141 |         if (path && path.length > 0) {
142 |             this.path = path;
143 |             this.currentWaypointIndex = 0;
144 |             this.state = 'moving';
145 |         } else {
146 |             this.path = [];
147 |             this.state = 'idle';
148 |         }
149 |     }
150 |     
151 |     executeCommand(commandName, gameState, statusCallback) {
152 |         if (commandName === 'siege_mode' && this.mode === 'tank') {
153 |             if (gameState.upgrades.siegeModeResearched) {
154 |                 this.state = 'idle';
155 |                 this.path = [];
156 |                 this.mode = 'transforming_to_siege';
157 |                 this.animationProgress = 0;
158 |             } else {
159 |                 statusCallback("Siege Mode must be researched first.");
160 |             }
161 |         } else if (commandName === 'tank_mode' && this.mode === 'siege') {
162 |             this.mode = 'transforming_to_tank';
163 |             this.animationProgress = 0;
164 |         }
165 |     }
166 | 
167 |     update(delta, pathfinder, gameState, buildings, scene) {
168 |         this.updateCommands(gameState);
169 | 
170 |         if (this.isStuckOnDepot || this.isGarrisoned) return;
171 | 
172 |         if (this.mode === 'transforming_to_siege') {
173 |             this.animationProgress += delta / this.animationDuration;
174 |             this.siegeParts.visible = true;
175 |             this.siegeParts.scale.set(1, this.animationProgress, 1);
176 |             this.body.position.y = 0.5 + 0.3 * this.animationProgress;
177 |             if (this.animationProgress >= 1) {
178 |                 this.mode = 'siege';
179 |                 this.body.position.y = 0.8;
180 |             }
181 |         } else if (this.mode === 'transforming_to_tank') {
182 |             this.animationProgress += delta / this.animationDuration;
183 |             this.siegeParts.scale.set(1, 1 - this.animationProgress, 1);
184 |             this.body.position.y = 0.8 - 0.3 * this.animationProgress;
185 |             if (this.animationProgress >= 1) {
186 |                 this.mode = 'tank';
187 |                 this.siegeParts.visible = false;
188 |                 this.body.position.y = 0.5;
189 |             }
190 |         }
191 | 
192 |         if (this.state === 'moving' && this.mode === 'tank') {
193 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
194 |         } else if (this.state === 'moving' && this.mode !== 'tank') {
195 |             // Can't move, stop.
196 |             this.state = 'idle';
197 |             this.path = [];
198 |         }
199 |     }
200 | 
201 |     updateMovement(delta, scene, onPathComplete) {
202 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
203 |             if (onPathComplete) onPathComplete();
204 |             return;
205 |         }
206 | 
207 |         const targetPosition = this.path[this.currentWaypointIndex];
208 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
209 |         targetPosition.y = targetY;
210 |         this.baseY = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z);
211 | 
212 |         const currentPos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
213 |         const targetPos2D = new THREE.Vector2(targetPosition.x, targetPosition.z);
214 |         const distance = currentPos2D.distanceTo(targetPos2D);
215 | 
216 |         if (distance < 0.2) {
217 |             this.currentWaypointIndex++;
218 |         } else {
219 |             const direction = targetPosition.clone().sub(this.mesh.position);
220 |             direction.y = 0;
221 |             direction.normalize();
222 | 
223 |             const moveDistance = this.speed * delta;
224 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
225 | 
226 |             if (moveVector.length() > distance) {
227 |                 moveVector.setLength(distance);
228 |             }
229 | 
230 |             this.mesh.position.add(moveVector);
231 | 
232 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
233 |             this.mesh.lookAt(lookAtTarget);
234 | 
235 |             // Bobbing animation for treads
236 |             this.driveTime += delta;
237 |             this.mesh.position.y = this.baseY + Math.abs(Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude);
238 |         }
239 |         
240 |         if (this.currentWaypointIndex >= this.path.length) {
241 |             this.path = [];
242 |             this.mesh.position.y = this.baseY;
243 |             this.driveTime = 0;
244 |             if (onPathComplete) onPathComplete();
245 |         }
246 |     }
247 | }


--------------------------------------------------------------------------------
/src/units/unit.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { getTerrainHeight } from '../utils/terrain.js';
  3 | import { Infantry } from './infantry.js';
  4 | 
  5 | export class Unit extends Infantry {
  6 |     constructor(position) {
  7 |         super(position);
  8 | 
  9 |         this.name = 'Terran Marine';
 10 |         this.portraitUrl = 'assets/images/marine_portrait.png';
 11 |         this.maxHealth = 40;
 12 |         this.currentHealth = 40;
 13 | 
 14 |         this.commands = [
 15 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 16 |             { command: 'stop', hotkey: 'T', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 17 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 18 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 19 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 20 |         ];
 21 |         
 22 |         this.mesh = this.createMesh();
 23 |         this.setup(position);
 24 |     }
 25 | 
 26 |     createMesh() {
 27 |         const group = new THREE.Group();
 28 | 
 29 |         const armorMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8aaa, metalness: 0.6, roughness: 0.5 });
 30 |         const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7, roughness: 0.4 });
 31 |         const visorMaterial = new THREE.MeshStandardMaterial({ color: 0x00d1ff, metalness: 0.9, roughness: 0.2, emissive: 0x00a1ff, emissiveIntensity: 0.6 });
 32 | 
 33 |         // Torso
 34 |         const torsoGeometry = new THREE.CylinderGeometry(0.35, 0.25, 0.8, 8);
 35 |         const torso = new THREE.Mesh(torsoGeometry, armorMaterial);
 36 |         torso.position.y = 0.4;
 37 |         torso.castShadow = true;
 38 |         group.add(torso);
 39 | 
 40 |         // Backpack
 41 |         const backpackGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
 42 |         const backpack = new THREE.Mesh(backpackGeo, armorMaterial);
 43 |         backpack.position.set(0, 0.5, -0.25);
 44 |         backpack.castShadow = true;
 45 |         group.add(backpack);
 46 | 
 47 |         // Head
 48 |         const headGeometry = new THREE.IcosahedronGeometry(0.25, 1);
 49 |         const head = new THREE.Mesh(headGeometry, armorMaterial);
 50 |         head.position.y = 1.0;
 51 |         head.castShadow = true;
 52 |         group.add(head);
 53 |         
 54 |         // Visor
 55 |         const visorGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.05);
 56 |         const visor = new THREE.Mesh(visorGeometry, visorMaterial);
 57 |         visor.position.set(0, 1.0, 0.22);
 58 |         group.add(visor);
 59 | 
 60 |         // Shoulder pads
 61 |         const shoulderGeo = new THREE.SphereGeometry(0.25, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
 62 |         const leftShoulder = new THREE.Mesh(shoulderGeo, armorMaterial);
 63 |         leftShoulder.position.set(0.4, 0.7, 0);
 64 |         leftShoulder.rotation.z = Math.PI / 8;
 65 |         leftShoulder.castShadow = true;
 66 |         group.add(leftShoulder);
 67 | 
 68 |         const rightShoulder = leftShoulder.clone();
 69 |         rightShoulder.position.x = -0.4;
 70 |         rightShoulder.rotation.z = -Math.PI / 8;
 71 |         group.add(rightShoulder);
 72 | 
 73 |         // Gun
 74 |         const gunGroup = new THREE.Group();
 75 |         const gunBodyGeo = new THREE.BoxGeometry(0.15, 0.2, 0.8);
 76 |         const gunBody = new THREE.Mesh(gunBodyGeo, gunMaterial);
 77 |         gunGroup.add(gunBody);
 78 | 
 79 |         const gunBarrelGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8);
 80 |         const gunBarrel = new THREE.Mesh(gunBarrelGeo, gunMaterial);
 81 |         gunBarrel.rotation.x = Math.PI / 2;
 82 |         gunBarrel.position.z = 0.6;
 83 |         gunGroup.add(gunBarrel);
 84 |         
 85 |         gunBody.castShadow = true;
 86 |         gunBarrel.castShadow = true;
 87 |         gunGroup.position.set(0.45, 0.4, 0.4);
 88 |         group.add(gunGroup);
 89 | 
 90 |         group.traverse((child) => {
 91 |             if (child instanceof THREE.Mesh) {
 92 |                 child.userData.owner = this;
 93 |             }
 94 |         });
 95 | 
 96 |         group.scale.set(0.7, 0.7, 0.7);
 97 | 
 98 |         return group;
 99 |     }
100 | }


--------------------------------------------------------------------------------
/src/units/valkyrie.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | 
  4 | export class Valkyrie {
  5 |     constructor(position) {
  6 |         this.name = 'Valkyrie';
  7 |         this.portraitUrl = 'assets/images/valkyrie_portrait.png';
  8 |         this.maxHealth = 200;
  9 |         this.currentHealth = 200;
 10 |         this.isFlying = true;
 11 |         this.hoverHeight = 9;
 12 |         this.armor = 2;
 13 | 
 14 |         this.isGarrisoned = false; // Cannot be garrisoned
 15 |         this.state = 'idle'; // idle, moving, attacking
 16 | 
 17 |         this.commands = [
 18 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 19 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 20 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 21 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 22 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 23 |         ];
 24 | 
 25 |         this.baseY = this.hoverHeight;
 26 |         
 27 |         try {
 28 |             const asset = assetManager.get('valkyrie');
 29 |             this.mesh = this.createMeshFromGLB(asset);
 30 |         } catch (error) {
 31 |             console.warn("Could not load valkyrie model, using procedural fallback.", error);
 32 |             this.mesh = this.createProceduralMesh();
 33 |         }
 34 | 
 35 |         this.mesh.position.copy(position);
 36 |         this.mesh.position.y = this.baseY;
 37 | 
 38 |         this.selected = false;
 39 |         this.path = [];
 40 |         this.currentWaypointIndex = 0;
 41 |         this.speed = 8.5; // Valkyries are fast
 42 | 
 43 |         // For hover/drive animation
 44 |         this.driveTime = 0;
 45 |         this.driveFrequency = 7;
 46 |         this.driveAmplitude = 0.25;
 47 | 
 48 |         const selectionGeometry = new THREE.RingGeometry(2.0, 2.2, 32);
 49 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 50 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 51 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 52 |         this.selectionIndicator.position.y = 0.01;
 53 |         this.selectionIndicator.visible = false;
 54 |         this.selectionIndicator.userData.owner = this;
 55 | 
 56 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 57 |     }
 58 |     
 59 |     createMeshFromGLB(asset) {
 60 |         const model = asset.scene.clone();
 61 | 
 62 |         const box = new THREE.Box3().setFromObject(model);
 63 |         const size = box.getSize(new THREE.Vector3());
 64 |         const desiredSize = 4.5; 
 65 |         const maxDim = Math.max(size.x, size.y, size.z);
 66 |         
 67 |         if (maxDim > 0) {
 68 |             const scale = desiredSize / maxDim;
 69 |             model.scale.set(scale, scale, scale);
 70 |         }
 71 | 
 72 |         const wrapper = new THREE.Group();
 73 |         wrapper.add(model);
 74 | 
 75 |         wrapper.traverse((child) => {
 76 |             if (child.isMesh) {
 77 |                 child.castShadow = true;
 78 |                 child.userData.owner = this;
 79 |             }
 80 |         });
 81 |         
 82 |         return wrapper;
 83 |     }
 84 | 
 85 |     createProceduralMesh() {
 86 |         const group = new THREE.Group();
 87 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x8a9aaa, metalness: 0.8, roughness: 0.4 });
 88 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
 89 |         
 90 |         // Main fuselage
 91 |         const bodyGeo = new THREE.BoxGeometry(1.5, 0.8, 4.5);
 92 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
 93 |         group.add(body);
 94 |         
 95 |         // Wings
 96 |         const wingGeo = new THREE.BoxGeometry(5, 0.3, 1.5);
 97 |         const wings = new THREE.Mesh(wingGeo, mainMaterial);
 98 |         wings.position.y = 0.2;
 99 |         group.add(wings);
100 | 
101 |         // Engines
102 |         const engineGeo = new THREE.CylinderGeometry(0.6, 0.4, 1.2, 8);
103 |         const leftEngine = new THREE.Mesh(engineGeo, darkMaterial);
104 |         leftEngine.rotation.z = Math.PI / 2;
105 |         leftEngine.position.set(-1.5, 0.2, -1.8);
106 |         group.add(leftEngine);
107 |         const rightEngine = leftEngine.clone();
108 |         rightEngine.position.x = 1.5;
109 |         group.add(rightEngine);
110 | 
111 |         // Missile Pods under wings
112 |         const podGeo = new THREE.BoxGeometry(0.4, 0.4, 1.2);
113 |         for(let i = 0; i < 4; i++) {
114 |              const podL = new THREE.Mesh(podGeo, darkMaterial);
115 |              podL.position.set(-2.2 + i * 0.5, -0.3, 0.3);
116 |              wings.add(podL);
117 |              const podR = podL.clone();
118 |              podR.position.x = 2.2 - i * 0.5;
119 |              wings.add(podR);
120 |         }
121 | 
122 |         group.traverse((child) => {
123 |             if (child.isMesh) {
124 |                 child.userData.owner = this;
125 |                 child.castShadow = true;
126 |             }
127 |         });
128 |         
129 |         group.rotation.y = -Math.PI / 2; // Align to Z-forward
130 |         return group;
131 |     }
132 | 
133 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
134 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
135 | 
136 |     setPath(path) {
137 |         if (path && path.length > 0) {
138 |             this.path = path;
139 |             this.currentWaypointIndex = 0;
140 |             this.state = 'moving';
141 |         } else {
142 |             this.path = [];
143 |             this.state = 'idle';
144 |         }
145 |     }
146 |     
147 |     executeCommand(commandName, gameState, statusCallback) {
148 |         // No special commands yet
149 |     }
150 | 
151 |     update(delta, pathfinder, gameState, buildings, scene) {
152 |         if (this.state === 'moving') {
153 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
154 |         } else {
155 |              // Bobbing animation
156 |             this.driveTime += delta;
157 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
158 |         }
159 | 
160 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
161 |     }
162 | 
163 |     updateMovement(delta, scene, onPathComplete) {
164 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
165 |             if (onPathComplete) onPathComplete();
166 |             return;
167 |         }
168 | 
169 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
170 |         targetPosition.y = this.hoverHeight;
171 | 
172 |         const distance = this.mesh.position.distanceTo(targetPosition);
173 | 
174 |         if (distance < 0.2) {
175 |             this.currentWaypointIndex++;
176 |         } else {
177 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
178 |             const moveDistance = this.speed * delta;
179 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
180 | 
181 |             if (moveVector.length() > distance) {
182 |                 moveVector.setLength(distance);
183 |             }
184 | 
185 |             this.mesh.position.add(moveVector);
186 | 
187 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
188 |             this.mesh.lookAt(lookAtTarget);
189 |         }
190 |         
191 |         if (this.currentWaypointIndex >= this.path.length) {
192 |             this.path = [];
193 |             this.state = 'idle';
194 |             if (onPathComplete) onPathComplete();
195 |         }
196 |     }
197 | }


--------------------------------------------------------------------------------
/src/units/vulture.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | import { getTerrainHeight } from '../utils/terrain.js';
  4 | 
  5 | export class Vulture {
  6 |     constructor(position) {
  7 |         this.name = 'Vulture';
  8 |         this.portraitUrl = 'assets/images/vulture_portrait.png';
  9 |         this.maxHealth = 80;
 10 |         this.currentHealth = 80;
 11 |         this.isGarrisoned = false; // Cannot be garrisoned
 12 |         this.isStuckOnDepot = false;
 13 |         this.stuckOnDepotInstance = null;
 14 |         this.state = 'idle'; // idle, moving, attack
 15 | 
 16 |         this.commands = [
 17 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 18 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 19 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 20 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 21 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 22 |         ];
 23 | 
 24 |         this.baseY = position.y + 0.3; // Hover height
 25 | 
 26 |         try {
 27 |             const asset = assetManager.get('vulture');
 28 |             this.mesh = this.createMeshFromGLB(asset);
 29 |         } catch (error) {
 30 |             console.warn("Could not load vulture model, using procedural fallback.", error);
 31 |             this.mesh = this.createProceduralMesh();
 32 |         }
 33 | 
 34 |         this.mesh.position.copy(position);
 35 |         this.mesh.position.y = this.baseY;
 36 | 
 37 |         this.selected = false;
 38 |         this.path = [];
 39 |         this.currentWaypointIndex = 0;
 40 |         this.speed = 6.5; // Vultures are fast
 41 | 
 42 |         // For hover/drive animation
 43 |         this.driveTime = 0;
 44 |         this.driveFrequency = 20;
 45 |         this.driveAmplitude = 0.05;
 46 | 
 47 |         const selectionGeometry = new THREE.RingGeometry(0.9, 1.0, 32);
 48 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 49 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 50 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 51 |         this.selectionIndicator.position.y = position.y + 0.01;
 52 |         this.selectionIndicator.visible = false;
 53 |         // The indicator is added to the scene in index.js to avoid flickering with hover animation
 54 | 
 55 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 56 |     }
 57 |     
 58 |     createMeshFromGLB(asset) {
 59 |         const model = asset.scene.clone();
 60 | 
 61 |         const box = new THREE.Box3().setFromObject(model);
 62 |         const size = box.getSize(new THREE.Vector3());
 63 |         const desiredSize = 2.0;
 64 |         const maxDim = Math.max(size.x, size.y, size.z);
 65 |         
 66 |         if (maxDim > 0) {
 67 |             const scale = desiredSize / maxDim;
 68 |             model.scale.set(scale, scale, scale);
 69 |         }
 70 |         
 71 |         // The GLB model's "front" is now aligned with what lookAt() expects.
 72 |         // It was previously rotated 180 degrees (Math.PI).
 73 |         model.rotation.y = 0;
 74 | 
 75 |         const wrapper = new THREE.Group();
 76 |         wrapper.add(model);
 77 | 
 78 |         wrapper.traverse((child) => {
 79 |             if (child.isMesh) {
 80 |                 child.castShadow = true;
 81 |                 child.userData.owner = this;
 82 |             }
 83 |         });
 84 |         
 85 |         return wrapper;
 86 |     }
 87 | 
 88 |     createProceduralMesh() {
 89 |         const group = new THREE.Group();
 90 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x4a6a8a, metalness: 0.8, roughness: 0.4 });
 91 |         const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.3 });
 92 | 
 93 |         // Body
 94 |         const bodyGeo = new THREE.BoxGeometry(2, 0.4, 1);
 95 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
 96 |         group.add(body);
 97 |         
 98 |         // Cockpit/Seat area
 99 |         const seatGeo = new THREE.BoxGeometry(0.5, 0.3, 0.6);
100 |         const seat = new THREE.Mesh(seatGeo, darkMaterial);
101 |         seat.position.set(-0.2, 0.3, 0);
102 |         group.add(seat);
103 | 
104 |         // Front part
105 |         const frontGeo = new THREE.BoxGeometry(0.8, 0.3, 0.8);
106 |         const front = new THREE.Mesh(frontGeo, mainMaterial);
107 |         front.position.x = 0.8;
108 |         group.add(front);
109 | 
110 |         // Grenade launcher
111 |         const launcherGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
112 |         const launcher = new THREE.Mesh(launcherGeo, darkMaterial);
113 |         launcher.position.set(0.6, -0.2, 0);
114 |         launcher.rotation.z = Math.PI / 2;
115 |         group.add(launcher);
116 | 
117 |         group.traverse((child) => {
118 |             if (child.isMesh) {
119 |                 child.userData.owner = this;
120 |                 child.castShadow = true;
121 |             }
122 |         });
123 | 
124 |         // Rotate procedural mesh to align with lookAt's +Z forward direction
125 |         group.rotation.y = -Math.PI / 2;
126 | 
127 |         return group;
128 |     }
129 | 
130 |     select() {
131 |         this.selected = true;
132 |         this.selectionIndicator.visible = true;
133 |     }
134 | 
135 |     deselect() {
136 |         this.selected = false;
137 |         this.selectionIndicator.visible = false;
138 |     }
139 | 
140 |     setPath(path) {
141 |         if (this.isStuckOnDepot) return;
142 |         if (path && path.length > 0) {
143 |             this.path = path;
144 |             this.currentWaypointIndex = 0;
145 |             this.state = 'moving';
146 |         } else {
147 |             this.path = [];
148 |             this.state = 'idle';
149 |         }
150 |     }
151 | 
152 |     update(delta, pathfinder, gameState, buildings, scene) {
153 |         if (this.isStuckOnDepot) {
154 |             this.state = 'idle';
155 |             this.path = [];
156 |             return;
157 |         }
158 | 
159 |         if (this.state === 'moving') {
160 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
161 |         } else {
162 |              // Stop bobbing animation if idle
163 |             if (this.driveTime !== 0) {
164 |                  this.mesh.position.y = this.baseY;
165 |                  this.driveTime = 0;
166 |             }
167 |         }
168 |         
169 |         // Update selection indicator position to follow the unit on the ground
170 |         if (this.selectionIndicator) {
171 |              this.selectionIndicator.position.x = this.mesh.position.x;
172 |              this.selectionIndicator.position.z = this.mesh.position.z;
173 |              this.selectionIndicator.position.y = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z) + 0.01;
174 |         }
175 |     }
176 | 
177 |     updateMovement(delta, scene, onPathComplete) {
178 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
179 |             if (onPathComplete) onPathComplete();
180 |             return;
181 |         }
182 | 
183 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
184 |         const targetY = getTerrainHeight(scene, targetPosition.x, targetPosition.z);
185 |         targetPosition.y = targetY + 0.3;
186 |         this.baseY = getTerrainHeight(scene, this.mesh.position.x, this.mesh.position.z) + 0.3;
187 | 
188 |         const currentPos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
189 |         const targetPos2D = new THREE.Vector2(targetPosition.x, targetPosition.z);
190 |         const distance = currentPos2D.distanceTo(targetPos2D);
191 | 
192 |         if (distance < 0.2) {
193 |             this.currentWaypointIndex++;
194 |         } else {
195 |             const direction = targetPosition.clone().sub(this.mesh.position);
196 |             direction.normalize();
197 | 
198 |             const moveDistance = this.speed * delta;
199 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
200 | 
201 |             if (moveVector.length() > distance) {
202 |                 moveVector.setLength(distance);
203 |             }
204 | 
205 |             this.mesh.position.add(moveVector);
206 | 
207 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
208 |             this.mesh.lookAt(lookAtTarget);
209 | 
210 |             // Bobbing animation
211 |             this.driveTime += delta;
212 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
213 |         }
214 |         
215 |         if (this.currentWaypointIndex >= this.path.length) {
216 |             this.path = [];
217 |             this.mesh.position.y = this.baseY;
218 |             this.driveTime = 0;
219 |             if (onPathComplete) onPathComplete();
220 |         }
221 |     }
222 | }


--------------------------------------------------------------------------------
/src/units/wraith.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { assetManager } from '../utils/asset-manager.js';
  3 | 
  4 | export class Wraith {
  5 |     constructor(position) {
  6 |         this.name = 'Wraith';
  7 |         this.portraitUrl = 'assets/images/wraith_portrait.png';
  8 |         this.maxHealth = 120;
  9 |         this.currentHealth = 120;
 10 |         this.isFlying = true;
 11 |         this.hoverHeight = 10;
 12 | 
 13 |         this.isGarrisoned = false; // Cannot be garrisoned
 14 |         this.state = 'idle'; // idle, moving, attacking
 15 | 
 16 |         this.commands = [
 17 |             { command: 'move', hotkey: 'M', icon: 'assets/images/move_icon.png', name: 'Move' },
 18 |             { command: 'stop', hotkey: 'S', icon: 'assets/images/stop_icon.png', name: 'Stop' },
 19 |             { command: 'hold', hotkey: 'H', icon: 'assets/images/hold_position_icon.png', name: 'Hold Position' },
 20 |             { command: 'patrol', hotkey: 'P', icon: 'assets/images/patrol_icon.png', name: 'Patrol' },
 21 |             { command: 'attack', hotkey: 'A', icon: 'assets/images/attack_icon.png', name: 'Attack' },
 22 |             null,
 23 |             null,
 24 |             { command: 'cloak', hotkey: 'C', icon: 'assets/images/cloak_icon.png', name: 'Cloak (Research)' },
 25 |         ];
 26 | 
 27 |         this.baseY = this.hoverHeight;
 28 |         
 29 |         try {
 30 |             const asset = assetManager.get('wraith');
 31 |             this.mesh = this.createMeshFromGLB(asset);
 32 |         } catch (error) {
 33 |             console.warn("Could not load wraith model, using procedural fallback.", error);
 34 |             this.mesh = this.createProceduralMesh();
 35 |         }
 36 | 
 37 |         this.mesh.position.copy(position);
 38 |         this.mesh.position.y = this.baseY;
 39 | 
 40 |         this.selected = false;
 41 |         this.path = [];
 42 |         this.currentWaypointIndex = 0;
 43 |         this.speed = 8.0; // Wraiths are fast
 44 | 
 45 |         // For hover/drive animation
 46 |         this.driveTime = 0;
 47 |         this.driveFrequency = 10;
 48 |         this.driveAmplitude = 0.2;
 49 | 
 50 |         const selectionGeometry = new THREE.RingGeometry(1.2, 1.4, 32);
 51 |         const selectionMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
 52 |         this.selectionIndicator = new THREE.Mesh(selectionGeometry, selectionMaterial);
 53 |         this.selectionIndicator.rotation.x = -Math.PI / 2;
 54 |         this.selectionIndicator.position.y = 0.01;
 55 |         this.selectionIndicator.visible = false;
 56 |         // The indicator is a separate mesh added to the scene, not the unit, to stay on the ground
 57 |         this.selectionIndicator.userData.owner = this;
 58 | 
 59 |         this.collider = new THREE.Box3().setFromObject(this.mesh);
 60 |     }
 61 |     
 62 |     createMeshFromGLB(asset) {
 63 |         const model = asset.scene.clone();
 64 | 
 65 |         const box = new THREE.Box3().setFromObject(model);
 66 |         const size = box.getSize(new THREE.Vector3());
 67 |         const desiredSize = 2.5; 
 68 |         const maxDim = Math.max(size.x, size.y, size.z);
 69 |         
 70 |         if (maxDim > 0) {
 71 |             const scale = desiredSize / maxDim;
 72 |             model.scale.set(scale, scale, scale);
 73 |         }
 74 | 
 75 |         const wrapper = new THREE.Group();
 76 |         model.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
 77 |         wrapper.add(model);
 78 | 
 79 |         wrapper.traverse((child) => {
 80 |             if (child.isMesh) {
 81 |                 child.castShadow = true;
 82 |                 child.userData.owner = this;
 83 |             }
 84 |         });
 85 |         
 86 |         return wrapper;
 87 |     }
 88 | 
 89 |     createProceduralMesh() {
 90 |         const wrapper = new THREE.Group();
 91 |         const group = new THREE.Group();
 92 |         const mainMaterial = new THREE.MeshStandardMaterial({ color: 0x6a8aaa, metalness: 0.8, roughness: 0.4 });
 93 |         const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x00a1ff, emissive: 0x00a1ff, emissiveIntensity: 0.5 });
 94 |         
 95 |         const bodyGeo = new THREE.ConeGeometry(0.8, 2.5, 4);
 96 |         const body = new THREE.Mesh(bodyGeo, mainMaterial);
 97 |         body.rotation.x = Math.PI / 2;
 98 |         group.add(body);
 99 |         
100 |         const wingGeo = new THREE.BoxGeometry(3, 0.1, 1.2);
101 |         const wings = new THREE.Mesh(wingGeo, mainMaterial);
102 |         wings.position.z = -0.3;
103 |         group.add(wings);
104 | 
105 |         const cockpitGeo = new THREE.SphereGeometry(0.4, 8, 6, 0, Math.PI * 2, 0, Math.PI/2);
106 |         const cockpit = new THREE.Mesh(cockpitGeo, cockpitMaterial);
107 |         cockpit.position.y = 0.2;
108 |         cockpit.position.z = 0.3;
109 |         group.add(cockpit);
110 | 
111 |         group.traverse((child) => {
112 |             if (child.isMesh) {
113 |                 child.userData.owner = this;
114 |                 child.castShadow = true;
115 |             }
116 |         });
117 | 
118 |         group.rotation.y = Math.PI / 2; // Rotate 180° so forward matches lookAt
119 |         wrapper.add(group);
120 |         return wrapper;
121 |     }
122 | 
123 |     select() { this.selected = true; this.selectionIndicator.visible = true; }
124 |     deselect() { this.selected = false; this.selectionIndicator.visible = false; }
125 | 
126 |     setPath(path) {
127 |         if (path && path.length > 0) {
128 |             this.path = path;
129 |             this.currentWaypointIndex = 0;
130 |             this.state = 'moving';
131 |         } else {
132 |             this.path = [];
133 |             this.state = 'idle';
134 |         }
135 |     }
136 |     
137 |     executeCommand(commandName, gameState, statusCallback) {
138 |         if (commandName === 'cloak') {
139 |             statusCallback("Cloaking field requires research.");
140 |         }
141 |     }
142 | 
143 |     update(delta, pathfinder, gameState, buildings, scene) {
144 |         if (this.state === 'moving') {
145 |             this.updateMovement(delta, scene, () => { this.state = 'idle'; });
146 |         } else {
147 |              // Bobbing animation
148 |             this.driveTime += delta;
149 |             this.mesh.position.y = this.baseY + Math.sin(this.driveTime * this.driveFrequency) * this.driveAmplitude;
150 |         }
151 | 
152 |         this.selectionIndicator.position.set(this.mesh.position.x, 0.01, this.mesh.position.z);
153 |     }
154 | 
155 |     updateMovement(delta, scene, onPathComplete) {
156 |         if (!this.path || this.path.length === 0 || this.currentWaypointIndex >= this.path.length) {
157 |             if (onPathComplete) onPathComplete();
158 |             return;
159 |         }
160 | 
161 |         const targetPosition = this.path[this.currentWaypointIndex].clone();
162 |         targetPosition.y = this.hoverHeight;
163 | 
164 |         const distance = this.mesh.position.distanceTo(targetPosition);
165 | 
166 |         if (distance < 0.2) {
167 |             this.currentWaypointIndex++;
168 |         } else {
169 |             const direction = targetPosition.clone().sub(this.mesh.position).normalize();
170 |             const moveDistance = this.speed * delta;
171 |             const moveVector = direction.clone().multiplyScalar(moveDistance);
172 | 
173 |             if (moveVector.length() > distance) {
174 |                 moveVector.setLength(distance);
175 |             }
176 | 
177 |             this.mesh.position.add(moveVector);
178 | 
179 |             const lookAtTarget = new THREE.Vector3(targetPosition.x, this.mesh.position.y, targetPosition.z);
180 |             this.mesh.lookAt(lookAtTarget);
181 |         }
182 |         
183 |         if (this.currentWaypointIndex >= this.path.length) {
184 |             this.path = [];
185 |             this.state = 'idle';
186 |             if (onPathComplete) onPathComplete();
187 |         }
188 |     }
189 | }


--------------------------------------------------------------------------------
/src/utils/asset-manager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  3 | 
  4 | class AssetManager {
  5 |     constructor() {
  6 |         this.gltfLoader = new GLTFLoader();
  7 |         this.textureLoader = new THREE.TextureLoader();
  8 |         this.fileLoader = new THREE.FileLoader(); // For generic files
  9 |         this.imageLoader = new THREE.ImageLoader();
 10 |         this.audioContext = null;
 11 |         this.loadedAssets = new Map();
 12 |     }
 13 | 
 14 |     _initAudioContext() {
 15 |         if (!this.audioContext) {
 16 |             this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
 17 |         }
 18 |     }
 19 | 
 20 |     resumeAudioContext() {
 21 |         this._initAudioContext();
 22 |         if (this.audioContext.state === 'suspended') {
 23 |             this.audioContext.resume();
 24 |         }
 25 |     }
 26 | 
 27 |     async loadJSON(url, assetName) {
 28 |         if (this.loadedAssets.has(assetName)) {
 29 |             return this.loadedAssets.get(assetName);
 30 |         }
 31 | 
 32 |         try {
 33 |             const response = await fetch(url);
 34 |             if (!response.ok) {
 35 |                 throw new Error(`HTTP ${response.status} ${response.statusText}`);
 36 |             }
 37 |             const json = await response.json();
 38 |             this.loadedAssets.set(assetName, json);
 39 |             console.log(`Loaded JSON: ${assetName} from ${url}`);
 40 |             return json;
 41 |         } catch (error) {
 42 |             console.error(`Failed to load JSON asset '${assetName}' from '${url}': ${error.message}`);
 43 |             throw error;
 44 |         }
 45 |     }
 46 | 
 47 |     async loadGLB(url, assetName) {
 48 |         if (this.loadedAssets.has(assetName)) {
 49 |             return this.loadedAssets.get(assetName);
 50 |         }
 51 |         
 52 |         try {
 53 |             const gltf = await this.gltfLoader.loadAsync(url);
 54 |             
 55 |             const asset = {
 56 |                 scene: gltf.scene,
 57 |                 animations: gltf.animations
 58 |             };
 59 | 
 60 |             this.loadedAssets.set(assetName, asset);
 61 |             console.log(`Loaded GLB: ${assetName} from ${url}`);
 62 |             return asset;
 63 |         } catch (error) {
 64 |             console.error(`Error loading GLB asset '${assetName}' from '${url}'. This may be expected if the file doesn't exist.`, error);
 65 |             throw error; // Re-throw to allow fallback logic
 66 |         }
 67 |     }
 68 | 
 69 |     async loadTexture(url, assetName) {
 70 |         if (this.loadedAssets.has(assetName)) {
 71 |             return this.loadedAssets.get(assetName);
 72 |         }
 73 |         
 74 |         try {
 75 |             const texture = await this.textureLoader.loadAsync(url);
 76 |             this.loadedAssets.set(assetName, texture);
 77 |             console.log(`Loaded Texture: ${assetName} from ${url}`);
 78 |             return texture;
 79 |         } catch (error) {
 80 |             console.error(`Error loading texture asset '${assetName}' from '${url}'. This may be expected if the file doesn't exist.`, error);
 81 |             throw error;
 82 |         }
 83 |     }
 84 | 
 85 |     async loadImage(url, assetName) {
 86 |         if (this.loadedAssets.has(assetName)) {
 87 |             return this.loadedAssets.get(assetName);
 88 |         }
 89 | 
 90 |         try {
 91 |             const image = await this.imageLoader.loadAsync(url);
 92 |             // We don't need to store the image itself, just loading it into the browser cache is enough.
 93 |             // But let's store it anyway in case we need it.
 94 |             this.loadedAssets.set(assetName, image);
 95 |             console.log(`Loaded Image: ${assetName} from ${url}`);
 96 |             return image;
 97 |         } catch (error) {
 98 |             console.error(`Error loading image asset '${assetName}' from '${url}'.`, error);
 99 |             throw error;
100 |         }
101 |     }
102 | 
103 |     async loadSound(url, assetName) {
104 |         this._initAudioContext();
105 |         if (this.loadedAssets.has(assetName)) {
106 |             return this.loadedAssets.get(assetName);
107 |         }
108 |         try {
109 |             const response = await fetch(url);
110 |             if (!response.ok) {
111 |                 throw new Error(`HTTP ${response.status} ${response.statusText}`);
112 |             }
113 |             const arrayBuffer = await response.arrayBuffer();
114 |             const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
115 |             this.loadedAssets.set(assetName, audioBuffer);
116 |             console.log(`Loaded Sound: ${assetName} from ${url}`);
117 |             return audioBuffer;
118 |         } catch (error) {
119 |             console.error(`Failed to load sound '${assetName}' from '${url}': ${error.message}`);
120 |             return null;
121 |         }
122 |     }
123 | 
124 |     async loadVideo(url, assetName) {
125 |         if (this.loadedAssets.has(assetName)) {
126 |             return this.loadedAssets.get(assetName);
127 |         }
128 |         return new Promise((resolve, reject) => {
129 |             const video = document.createElement('video');
130 |             video.preload = 'auto';
131 |             video.crossOrigin = 'anonymous'; // Add for potential cross-origin video sources
132 |             video.src = url;
133 |             video.onloadeddata = () => {
134 |                 this.loadedAssets.set(assetName, video);
135 |                 console.log(`Loaded Video: ${assetName} from ${url}`);
136 |                 resolve(video);
137 |             };
138 |             video.onerror = e => {
139 |                 console.error(`Error loading video asset '${assetName}' from '${url}'.`, e);
140 |                 reject(e);
141 |             };
142 |             video.load(); // Start loading the video data
143 |         });
144 |     }
145 | 
146 |     get(assetName) {
147 |         const asset = this.loadedAssets.get(assetName);
148 |         if (!asset) {
149 |             throw new Error(`Asset not found: ${assetName}. Make sure it was pre-loaded.`);
150 |         }
151 |         return asset;
152 |     }
153 | }
154 | 
155 | // Export a single instance
156 | export const assetManager = new AssetManager();


--------------------------------------------------------------------------------
/src/utils/audio.js:
--------------------------------------------------------------------------------
  1 | import { assetManager } from './asset-manager.js';
  2 | 
  3 | export class AudioManager {
  4 |     constructor() {
  5 |         // The AudioContext is now managed by the AssetManager.
  6 |         // The manager should be initialized before any sounds are played.
  7 |         this.backgroundTrackNames = [];
  8 |         this.scvConstructedSoundNames = [];
  9 |         this.scvMark2ConstructedSoundNames = [];
 10 |         this.firebatSoundNames = [];
 11 |         this.marineSoundNames = [];
 12 |         this.medicSoundNames = [];
 13 |         this.mineralsWarningSoundName = null;
 14 |         this.gasWarningSoundName = null;
 15 |         this.supplyWarningSoundName = null;
 16 |         this.backgroundGain = null;
 17 |         this.currentTrackIndex = 0;
 18 |         this.backgroundPlaying = false;
 19 |         this.backgroundSource = null;
 20 |         this.sfxVolume = 1.0;
 21 |         this.bgmVolume = 0.3;
 22 |     }
 23 | 
 24 |     setBgmVolume(volume) {
 25 |         this.bgmVolume = parseFloat(volume);
 26 |         if (this.backgroundGain) {
 27 |             const audioContext = assetManager.audioContext;
 28 |             if (audioContext) {
 29 |                  this.backgroundGain.gain.setValueAtTime(this.bgmVolume, audioContext.currentTime);
 30 |             }
 31 |         }
 32 |     }
 33 |     
 34 |     setSfxVolume(volume) {
 35 |         this.sfxVolume = parseFloat(volume);
 36 |     }
 37 | 
 38 |     playSound(name, volume = 1.0) {
 39 |         const audioContext = assetManager.audioContext;
 40 |         if (!audioContext || audioContext.state === 'suspended') {
 41 |             // The main game logic should handle resuming the context on user interaction.
 42 |             return;
 43 |         }
 44 | 
 45 |         let audioBuffer;
 46 |         try {
 47 |             audioBuffer = assetManager.get(name);
 48 |         } catch (error) {
 49 |             console.warn(`Could not play sound, asset not found: ${name}`, error);
 50 |             return; // Asset not found or not pre-loaded
 51 |         }
 52 | 
 53 |         if (!audioBuffer) {
 54 |             return;
 55 |         }
 56 | 
 57 |         const source = audioContext.createBufferSource();
 58 |         source.buffer = audioBuffer;
 59 | 
 60 |         const gainNode = audioContext.createGain();
 61 |         gainNode.gain.setValueAtTime(this.sfxVolume * volume, audioContext.currentTime);
 62 | 
 63 |         source.connect(gainNode);
 64 |         gainNode.connect(audioContext.destination);
 65 |         source.start(0);
 66 |     }
 67 |     
 68 |     playUnitSound(units, actionType, probability = 1.0) {
 69 |         if (!units || units.length === 0) return false;
 70 |         if (Math.random() > probability) return false;
 71 | 
 72 |         // Pick a random unit from the selection to make a sound
 73 |         const unit = units[Math.floor(Math.random() * units.length)];
 74 |         
 75 |         if (unit.sounds && unit.sounds[actionType] && unit.sounds[actionType].length > 0) {
 76 |             const soundNames = unit.sounds[actionType];
 77 |             const soundName = soundNames[Math.floor(Math.random() * soundNames.length)];
 78 |             this.playSound(soundName);
 79 |             return true;
 80 |         }
 81 | 
 82 |         return false;
 83 |     }
 84 | 
 85 |     resumeContext() {
 86 |         assetManager.resumeAudioContext();
 87 |     }
 88 | 
 89 |     playRandomSound(names) {
 90 |         if (!Array.isArray(names) || names.length === 0) return;
 91 |         const index = Math.floor(Math.random() * names.length);
 92 |         const name = names[index];
 93 |         this.playSound(name);
 94 |     }
 95 | 
 96 |     async loadWarningSounds(urls) {
 97 |         const promises = [];
 98 |         if (urls.minerals) {
 99 |             this.mineralsWarningSoundName = 'minerals_warning';
100 |             promises.push(assetManager.loadSound(urls.minerals, this.mineralsWarningSoundName));
101 |         }
102 |         if (urls.gas) {
103 |             this.gasWarningSoundName = 'gas_warning';
104 |             promises.push(assetManager.loadSound(urls.gas, this.gasWarningSoundName));
105 |         }
106 |         if (urls.supply) {
107 |             this.supplyWarningSoundName = 'supply_warning';
108 |             promises.push(assetManager.loadSound(urls.supply, this.supplyWarningSoundName));
109 |         }
110 |         await Promise.all(promises);
111 |     }
112 | 
113 |     async loadBackgroundTracks(urls) {
114 |         this.backgroundTrackNames = [];
115 |         const loadPromises = [];
116 |         for (let i = 0; i < urls.length; i++) {
117 |             const name = `background_${i}`;
118 |             this.backgroundTrackNames.push(name);
119 |             loadPromises.push(assetManager.loadSound(urls[i], name));
120 |         }
121 |         await Promise.all(loadPromises);
122 |     }
123 | 
124 |     playBackgroundMusic() {
125 |         const audioContext = assetManager.audioContext;
126 |         if (!audioContext || audioContext.state === 'suspended' || this.backgroundTrackNames.length === 0) {
127 |             console.log('Cannot play background music. AudioContext not ready or no tracks loaded.');
128 |             return;
129 |         }
130 | 
131 |         if (this.backgroundPlaying) return;
132 | 
133 |         if (!this.backgroundGain) {
134 |             this.backgroundGain = audioContext.createGain();
135 |             this.backgroundGain.connect(audioContext.destination);
136 |         }
137 |         this.backgroundGain.gain.setValueAtTime(this.bgmVolume, audioContext.currentTime);
138 | 
139 |         this.backgroundPlaying = true;
140 |         this.currentTrackIndex = Math.floor(Math.random() * this.backgroundTrackNames.length);
141 | 
142 |         const playNext = () => {
143 |             if (!this.backgroundPlaying) return;
144 | 
145 |             // Stop and disconnect previous source if it exists
146 |             if (this.backgroundSource) {
147 |                 try {
148 |                     this.backgroundSource.onended = null; // Prevent re-triggering
149 |                     this.backgroundSource.stop();
150 |                     this.backgroundSource.disconnect();
151 |                 } catch (e) { /* ignore errors if already stopped */ }
152 |             }
153 | 
154 |             const trackName = this.backgroundTrackNames[this.currentTrackIndex];
155 |             let buffer;
156 |             try {
157 |                 buffer = assetManager.get(trackName);
158 |             } catch (e) {
159 |                 console.warn(`Background track not loaded: ${trackName}. Trying next...`, e);
160 |                 this.currentTrackIndex = (this.currentTrackIndex + 1) % this.backgroundTrackNames.length;
161 |                 setTimeout(playNext, 1000); // Wait a moment before trying the next track
162 |                 return;
163 |             }
164 | 
165 |             const source = audioContext.createBufferSource();
166 |             source.buffer = buffer;
167 |             source.connect(this.backgroundGain);
168 | 
169 |             source.onended = () => {
170 |                 if (this.backgroundPlaying) {
171 |                     this.currentTrackIndex = (this.currentTrackIndex + 1) % this.backgroundTrackNames.length;
172 |                     playNext();
173 |                 }
174 |             };
175 | 
176 |             source.start(0);
177 |             this.backgroundSource = source;
178 |         };
179 | 
180 |         playNext();
181 |     }
182 | 
183 |     pauseBackgroundMusic() {
184 |         if (!this.backgroundPlaying) return;
185 |         this.backgroundPlaying = false;
186 |         if (this.backgroundSource) {
187 |             try {
188 |                 this.backgroundSource.onended = null;
189 |                 this.backgroundSource.stop();
190 |                 this.backgroundSource.disconnect();
191 |             } catch (e) { /* ignore errors if already stopped */ }
192 |             this.backgroundSource = null;
193 |         }
194 |     }
195 | 
196 |     resumeBackgroundMusic() {
197 |         if (this.backgroundPlaying) return;
198 |         this.playBackgroundMusic();
199 |     }
200 | }
201 | 
202 | export const audioManager = new AudioManager();


--------------------------------------------------------------------------------
/src/utils/dev-logger.js:
--------------------------------------------------------------------------------
 1 | const logs = [];
 2 | const MAX_LOGS = 200;
 3 | let devLoggerActive = false;
 4 | 
 5 | function updateDevLogModal() {
 6 |     const devLogOutput = document.getElementById('dev-log-output');
 7 |     if (devLogOutput && !devLogOutput.closest('#dev-log-modal').classList.contains('hidden')) {
 8 |         devLogOutput.textContent = devLogger.getLogs().join('\n');
 9 |     }
10 | }
11 | 
12 | export const devLogger = {
13 |     get isActive() {
14 |         return devLoggerActive;
15 |     },
16 |     
17 |     activate() {
18 |         devLoggerActive = true;
19 |         this.log('DevLogger', 'Developer Mode Activated.');
20 |     },
21 |     
22 |     log(source, message) {
23 |         if (!devLoggerActive) return;
24 |         
25 |         const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
26 |         logs.push(`[${timestamp}] [${source}] ${message}`);
27 |         
28 |         if (logs.length > MAX_LOGS) {
29 |             logs.shift();
30 |         }
31 |         
32 |         updateDevLogModal();
33 |     },
34 | 
35 |     getLogs() {
36 |         return logs.slice().reverse();
37 |     },
38 | 
39 |     clearLogs() {
40 |         logs.length = 0;
41 |         updateDevLogModal();
42 |     }
43 | };


--------------------------------------------------------------------------------
/src/utils/map-utils.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | 
 3 | export function createRampGeometry(width, length, height) {
 4 |     const geometry = new THREE.BufferGeometry();
 5 |     const vertices = new Float32Array([
 6 |         -width / 2, height, 0,
 7 |          width / 2, height, 0,
 8 |         -width / 2, 0, -length,
 9 |          width / 2, 0, -length,
10 |     ]);
11 |     geometry.setIndex([0, 2, 1, 2, 3, 1]);
12 |     geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
13 |     geometry.computeVertexNormals();
14 |     return geometry;
15 | }
16 | 
17 | export function createPlateau({ x, z, sizeX, sizeZ, height = 2, orientation = 'north', material, withRamp = false, isObstacle = true }) {
18 |     const meshes = [];
19 |     const plateauGeom = new THREE.BoxGeometry(sizeX, height, sizeZ);
20 |     const plateau = new THREE.Mesh(plateauGeom, material);
21 |     plateau.position.set(x, height / 2, z);
22 |     plateau.castShadow = true;
23 |     plateau.receiveShadow = true;
24 |     meshes.push(plateau);
25 | 
26 |     if (withRamp) {
27 |         const rampLength = 6;
28 |         const rampGeom = createRampGeometry(
29 |             orientation === 'north' || orientation === 'south' ? sizeX : sizeZ,
30 |             rampLength,
31 |             height
32 |         );
33 |         const ramp = new THREE.Mesh(rampGeom, material);
34 |         ramp.name = 'ground';
35 |         switch (orientation) {
36 |             case 'north':
37 |                 ramp.rotation.y = 0;
38 |                 ramp.position.set(x, 0, z - sizeZ / 2 - rampLength / 2);
39 |                 break;
40 |             case 'south':
41 |                 ramp.rotation.y = Math.PI;
42 |                 ramp.position.set(x, 0, z + sizeZ / 2 + rampLength / 2);
43 |                 break;
44 |             case 'east':
45 |                 ramp.rotation.y = -Math.PI / 2;
46 |                 ramp.position.set(x + sizeX / 2 + rampLength / 2, 0, z);
47 |                 break;
48 |             case 'west':
49 |                 ramp.rotation.y = Math.PI / 2;
50 |                 ramp.position.set(x - sizeX / 2 - rampLength / 2, 0, z);
51 |                 break;
52 |             default:
53 |                 break;
54 |         }
55 |         ramp.castShadow = true;
56 |         ramp.receiveShadow = true;
57 |         meshes.push(ramp);
58 |     }
59 | 
60 |     const minX = x - sizeX / 2;
61 |     const maxX = x + sizeX / 2;
62 |     const minZ = z - sizeZ / 2;
63 |     const maxZ = z + sizeZ / 2;
64 | 
65 |     const colliders = [];
66 |     if (isObstacle) {
67 |         colliders.push(new THREE.Box3(
68 |             new THREE.Vector3(minX, 0, minZ),
69 |             new THREE.Vector3(maxX, height, maxZ)
70 |         ));
71 |     } else {
72 |         const thickness = 0.5;
73 |         // North side
74 |         colliders.push(new THREE.Box3(
75 |             new THREE.Vector3(minX, 0, maxZ - thickness),
76 |             new THREE.Vector3(maxX, height, maxZ)
77 |         ));
78 |         // South side
79 |         colliders.push(new THREE.Box3(
80 |             new THREE.Vector3(minX, 0, minZ),
81 |             new THREE.Vector3(maxX, height, minZ + thickness)
82 |         ));
83 |         // East side
84 |         colliders.push(new THREE.Box3(
85 |             new THREE.Vector3(maxX - thickness, 0, minZ),
86 |             new THREE.Vector3(maxX, height, maxZ)
87 |         ));
88 |         // West side
89 |         colliders.push(new THREE.Box3(
90 |             new THREE.Vector3(minX, 0, minZ),
91 |             new THREE.Vector3(minX + thickness, height, maxZ)
92 |         ));
93 |     }
94 | 
95 |     return { meshes, colliders };
96 | }
97 | 
98 | 


--------------------------------------------------------------------------------
/src/utils/pathfinding.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | class GridNode {
  4 |     constructor(x, y, walkable) {
  5 |         this.x = x; // grid x
  6 |         this.y = y; // grid y (maps to world z)
  7 |         this.walkable = walkable;
  8 | 
  9 |         // A* properties
 10 |         this.gCost = 0;
 11 |         this.hCost = 0;
 12 |         this.fCost = 0;
 13 |         this.parent = null;
 14 |     }
 15 | 
 16 |     reset() {
 17 |         this.gCost = 0;
 18 |         this.hCost = 0;
 19 |         this.fCost = 0;
 20 |         this.parent = null;
 21 |     }
 22 | }
 23 | 
 24 | export class Pathfinder {
 25 |     constructor(worldWidth, worldHeight, resolution = 1) {
 26 |         this.resolution = resolution;
 27 |         this.gridWidth = Math.floor(worldWidth / resolution);
 28 |         this.gridHeight = Math.floor(worldHeight / resolution);
 29 |         this.worldWidth = worldWidth;
 30 |         this.worldHeight = worldHeight;
 31 |         this.grid = [];
 32 | 
 33 |         // Create the grid
 34 |         for (let x = 0; x < this.gridWidth; x++) {
 35 |             this.grid[x] = [];
 36 |             for (let y = 0; y < this.gridHeight; y++) {
 37 |                 this.grid[x][y] = new GridNode(x, y, true);
 38 |             }
 39 |         }
 40 |     }
 41 | 
 42 |     worldToGrid(worldPos) {
 43 |         const gridX = Math.floor((worldPos.x + this.worldWidth / 2) / this.resolution);
 44 |         const gridY = Math.floor((worldPos.z + this.worldHeight / 2) / this.resolution);
 45 |         return { x: gridX, y: gridY };
 46 |     }
 47 | 
 48 |     gridToWorld(gridX, gridY) {
 49 |         const worldX = (gridX * this.resolution) - this.worldWidth / 2 + this.resolution / 2;
 50 |         const worldZ = (gridY * this.resolution) - this.worldHeight / 2 + this.resolution / 2;
 51 |         return new THREE.Vector3(worldX, 0, worldZ);
 52 |     }
 53 | 
 54 |     getNode(x, y) {
 55 |         if (x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight) {
 56 |             return this.grid[x][y];
 57 |         }
 58 |         return null;
 59 |     }
 60 |     
 61 |     getNodeFromWorld(worldPos) {
 62 |         const gridCoords = this.worldToGrid(worldPos);
 63 |         return this.getNode(gridCoords.x, gridCoords.y);
 64 |     }
 65 | 
 66 |     updateObstacles(collidables) {
 67 |         // Reset grid
 68 |         for (let x = 0; x < this.gridWidth; x++) {
 69 |             for (let y = 0; y < this.gridHeight; y++) {
 70 |                 this.grid[x][y].walkable = true;
 71 |             }
 72 |         }
 73 | 
 74 |         collidables.forEach(obstacle => {
 75 |             const box = obstacle.getCollider();
 76 |             const minGrid = this.worldToGrid(box.min);
 77 |             const maxGrid = this.worldToGrid(box.max);
 78 | 
 79 |             for (let x = minGrid.x; x <= maxGrid.x; x++) {
 80 |                 for (let y = minGrid.y; y <= maxGrid.y; y++) {
 81 |                     const node = this.getNode(x, y);
 82 |                     if (node) {
 83 |                         node.walkable = false;
 84 |                     }
 85 |                 }
 86 |             }
 87 |         });
 88 |     }
 89 | 
 90 |     findPath(startWorldPos, endWorldPos) {
 91 |         const startNode = this.getNodeFromWorld(startWorldPos);
 92 |         let endNode = this.getNodeFromWorld(endWorldPos);
 93 |         
 94 |         if (!startNode || !endNode) {
 95 |             return null; // Invalid start or end position
 96 |         }
 97 | 
 98 |         // If end node is not walkable, find the nearest walkable node
 99 |         if (!endNode.walkable) {
100 |             let nearestNode = null;
101 |             let minDistance = Infinity;
102 |             for (let x = 0; x < this.gridWidth; x++) {
103 |                 for (let y = 0; y < this.gridHeight; y++) {
104 |                     const node = this.grid[x][y];
105 |                     if (node.walkable) {
106 |                         const dist = endWorldPos.distanceToSquared(this.gridToWorld(node.x, node.y));
107 |                         if (dist < minDistance) {
108 |                             minDistance = dist;
109 |                             nearestNode = node;
110 |                         }
111 |                     }
112 |                 }
113 |             }
114 |             endNode = nearestNode;
115 |             if (!endNode) return null; // No walkable nodes on map
116 |         }
117 |         
118 |         if (startNode === endNode) return [];
119 | 
120 |         for (let x = 0; x < this.gridWidth; x++) {
121 |             for (let y = 0; y < this.gridHeight; y++) {
122 |                 this.grid[x][y].reset();
123 |             }
124 |         }
125 | 
126 |         const openSet = [startNode];
127 |         const closedSet = new Set();
128 | 
129 |         startNode.gCost = 0;
130 |         startNode.hCost = this.getDistance(startNode, endNode);
131 |         startNode.fCost = startNode.gCost + startNode.hCost;
132 | 
133 |         while (openSet.length > 0) {
134 |             let currentNode = openSet[0];
135 |             let currentIndex = 0;
136 |             for (let i = 1; i < openSet.length; i++) {
137 |                 if (openSet[i].fCost < currentNode.fCost || (openSet[i].fCost === currentNode.fCost && openSet[i].hCost < currentNode.hCost)) {
138 |                     currentNode = openSet[i];
139 |                     currentIndex = i;
140 |                 }
141 |             }
142 |             
143 |             openSet.splice(currentIndex, 1);
144 |             closedSet.add(currentNode);
145 | 
146 |             if (currentNode === endNode) {
147 |                 return this.retracePath(startNode, endNode);
148 |             }
149 | 
150 |             this.getNeighbors(currentNode).forEach(neighbor => {
151 |                 if (!neighbor.walkable || closedSet.has(neighbor)) {
152 |                     return;
153 |                 }
154 | 
155 |                 const newMovementCostToNeighbor = currentNode.gCost + this.getDistance(currentNode, neighbor);
156 |                 if (newMovementCostToNeighbor < neighbor.gCost || !openSet.includes(neighbor)) {
157 |                     neighbor.gCost = newMovementCostToNeighbor;
158 |                     neighbor.hCost = this.getDistance(neighbor, endNode);
159 |                     neighbor.fCost = neighbor.gCost + neighbor.hCost;
160 |                     neighbor.parent = currentNode;
161 | 
162 |                     if (!openSet.includes(neighbor)) {
163 |                         openSet.push(neighbor);
164 |                     }
165 |                 }
166 |             });
167 |         }
168 |         
169 |         return null; // No path found
170 |     }
171 |     
172 |     getDistance(nodeA, nodeB) {
173 |         const dstX = Math.abs(nodeA.x - nodeB.x);
174 |         const dstY = Math.abs(nodeA.y - nodeB.y);
175 |         if (dstX > dstY) return 14 * dstY + 10 * (dstX - dstY);
176 |         return 14 * dstX + 10 * (dstY - dstX);
177 |     }
178 | 
179 |     getNeighbors(node) {
180 |         const neighbors = [];
181 |         for (let x = -1; x <= 1; x++) {
182 |             for (let y = -1; y <= 1; y++) {
183 |                 if (x === 0 && y === 0) continue;
184 |                 const checkX = node.x + x;
185 |                 const checkY = node.y + y;
186 |                 const neighborNode = this.getNode(checkX, checkY);
187 |                 if (neighborNode) {
188 |                     neighbors.push(neighborNode);
189 |                 }
190 |             }
191 |         }
192 |         return neighbors;
193 |     }
194 |     
195 |     retracePath(startNode, endNode) {
196 |         const path = [];
197 |         let currentNode = endNode;
198 |         while (currentNode !== startNode) {
199 |             path.push(this.gridToWorld(currentNode.x, currentNode.y));
200 |             currentNode = currentNode.parent;
201 |         }
202 |         path.reverse();
203 |         return path;
204 |     }
205 | }


--------------------------------------------------------------------------------
/src/utils/terrain.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | 
 3 | export function getGroundMeshes(scene) {
 4 |     const grounds = [];
 5 |     scene.traverse(obj => {
 6 |         if (obj.name === 'ground') grounds.push(obj);
 7 |     });
 8 |     return grounds;
 9 | }
10 | 
11 | export function sampleTerrain(scene, x, z) {
12 |     const grounds = getGroundMeshes(scene);
13 |     if (grounds.length === 0) {
14 |         return { height: 0, normal: new THREE.Vector3(0, 1, 0) };
15 |     }
16 | 
17 |     const raycaster = new THREE.Raycaster(
18 |         new THREE.Vector3(x, 1000, z),
19 |         new THREE.Vector3(0, -1, 0)
20 |     );
21 |     const intersects = raycaster.intersectObjects(grounds, true);
22 |     if (intersects.length > 0) {
23 |         const hit = intersects[0];
24 |         const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
25 |         const normal = hit.face.normal.clone().applyMatrix3(normalMatrix).normalize();
26 |         return { height: hit.point.y, normal };
27 |     }
28 | 
29 |     return { height: 0, normal: new THREE.Vector3(0, 1, 0) };
30 | }
31 | 
32 | export function getTerrainHeight(scene, x, z) {
33 |     return sampleTerrain(scene, x, z).height;
34 | }
35 | 


--------------------------------------------------------------------------------